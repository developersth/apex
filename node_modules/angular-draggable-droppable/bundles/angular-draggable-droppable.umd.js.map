{"version":3,"sources":["/Users/macpro/kritsadee/SVN/Cybersoft/apex/node_modules/angular-draggable-droppable/bundles/angular-draggable-droppable.umd.js"],"names":[],"mappings":"AAAA","file":"angular-draggable-droppable.umd.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('rxjs'), require('@angular/common'), require('@angular/core'), require('rxjs/operators')) :\n\ttypeof define === 'function' && define.amd ? define(['rxjs', '@angular/common', '@angular/core', 'rxjs/operators'], factory) :\n\t(global = global || self, global['angular-draggable-droppable'] = factory(global.rxjs, global.ng.common, global.ng.core, global.rxjs.operators));\n}(this, (function (rxjs, common, core, operators) { 'use strict';\n\n\trxjs = rxjs && Object.prototype.hasOwnProperty.call(rxjs, 'default') ? rxjs['default'] : rxjs;\n\tcommon = common && Object.prototype.hasOwnProperty.call(common, 'default') ? common['default'] : common;\n\tcore = core && Object.prototype.hasOwnProperty.call(core, 'default') ? core['default'] : core;\n\toperators = operators && Object.prototype.hasOwnProperty.call(operators, 'default') ? operators['default'] : operators;\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getDef(f, d) {\n\t    if (typeof f === 'undefined') {\n\t        return typeof d === 'undefined' ? f : d;\n\t    }\n\n\t    return f;\n\t}\n\tfunction boolean(func, def) {\n\n\t    func = getDef(func, def);\n\n\t    if (typeof func === 'function') {\n\t        return function f() {\n\t            var arguments$1 = arguments;\n\n\t            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t                args[_key] = arguments$1[_key];\n\t            }\n\n\t            return !!func.apply(this, args);\n\t        };\n\t    }\n\n\t    return !!func ? function () {\n\t        return true;\n\t    } : function () {\n\t        return false;\n\t    };\n\t}\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n\t/**\n\t * Returns `true` if provided input is Element.\n\t * @name isElement\n\t * @param {*} [input]\n\t * @returns {boolean}\n\t */\n\tvar isElement$1 = function (input) {\n\t  return input != null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.nodeType === 1 && _typeof(input.style) === 'object' && _typeof(input.ownerDocument) === 'object';\n\t};\n\n\tfunction indexOfElement(elements, element){\n\t    element = resolveElement(element, true);\n\t    if(!isElement$1(element)) { return -1; }\n\t    for(var i=0; i<elements.length; i++){\n\t        if(elements[i] === element){\n\t            return i;\n\t        }\n\t    }\n\t    return -1;\n\t}\n\n\tfunction hasElement(elements, element){\n\t    return -1 !== indexOfElement(elements, element);\n\t}\n\n\tfunction pushElements(elements, toAdd){\n\n\t    for(var i=0; i<toAdd.length; i++){\n\t        if(!hasElement(elements, toAdd[i]))\n\t            { elements.push(toAdd[i]); }\n\t    }\n\n\t    return toAdd;\n\t}\n\n\tfunction addElements(elements){\n\t    var arguments$1 = arguments;\n\n\t    var toAdd = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) { toAdd[ len ] = arguments$1[ len + 1 ]; }\n\n\t    toAdd = toAdd.map(resolveElement);\n\t    return pushElements(elements, toAdd);\n\t}\n\n\tfunction removeElements(elements){\n\t    var arguments$1 = arguments;\n\n\t    var toRemove = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) { toRemove[ len ] = arguments$1[ len + 1 ]; }\n\n\t    return toRemove.map(resolveElement).reduce(function (last, e){\n\n\t        var index = indexOfElement(elements, e);\n\n\t        if(index !== -1)\n\t            { return last.concat(elements.splice(index, 1)); }\n\t        return last;\n\t    }, []);\n\t}\n\n\tfunction resolveElement(element, noThrow){\n\t    if(typeof element === 'string'){\n\t        try{\n\t            return document.querySelector(element);\n\t        }catch(e){\n\t            throw e;\n\t        }\n\n\t    }\n\n\t    if(!isElement$1(element) && !noThrow){\n\t        throw new TypeError((element + \" is not a DOM element.\"));\n\t    }\n\t    return element;\n\t}\n\n\tfunction createPointCB(object, options) {\n\n\t    // A persistent object (as opposed to returned object) is used to save memory\n\t    // This is good to prevent layout thrashing, or for games, and such\n\n\t    // NOTE\n\t    // This uses IE fixes which should be OK to remove some day. :)\n\t    // Some speed will be gained by removal of these.\n\n\t    // pointCB should be saved in a variable on return\n\t    // This allows the usage of element.removeEventListener\n\n\t    options = options || {};\n\n\t    var allowUpdate = boolean(options.allowUpdate, true);\n\n\t    /*if(typeof options.allowUpdate === 'function'){\n\t        allowUpdate = options.allowUpdate;\n\t    }else{\n\t        allowUpdate = function(){return true;};\n\t    }*/\n\n\t    return function pointCB(event) {\n\n\t        event = event || window.event; // IE-ism\n\t        object.target = event.target || event.srcElement || event.originalTarget;\n\t        object.element = this;\n\t        object.type = event.type;\n\n\t        if (!allowUpdate(event)) {\n\t            return;\n\t        }\n\n\t        // Support touch\n\t        // http://www.creativebloq.com/javascript/make-your-site-work-touch-devices-51411644\n\n\t        if (event.targetTouches) {\n\t            object.x = event.targetTouches[0].clientX;\n\t            object.y = event.targetTouches[0].clientY;\n\t            object.pageX = event.targetTouches[0].pageX;\n\t            object.pageY = event.targetTouches[0].pageY;\n\t            object.screenX = event.targetTouches[0].screenX;\n\t            object.screenY = event.targetTouches[0].screenY;\n\t        } else {\n\n\t            // If pageX/Y aren't available and clientX/Y are,\n\t            // calculate pageX/Y - logic taken from jQuery.\n\t            // (This is to support old IE)\n\t            // NOTE Hopefully this can be removed soon.\n\n\t            if (event.pageX === null && event.clientX !== null) {\n\t                var eventDoc = event.target && event.target.ownerDocument || document;\n\t                var doc = eventDoc.documentElement;\n\t                var body = eventDoc.body;\n\n\t                object.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t                object.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n\t            } else {\n\t                object.pageX = event.pageX;\n\t                object.pageY = event.pageY;\n\t            }\n\n\t            // pageX, and pageY change with page scroll\n\t            // so we're not going to use those for x, and y.\n\t            // NOTE Most browsers also alias clientX/Y with x/y\n\t            // so that's something to consider down the road.\n\n\t            object.x = event.clientX;\n\t            object.y = event.clientY;\n\n\t            object.screenX = event.screenX;\n\t            object.screenY = event.screenY;\n\t        }\n\n\t        object.clientX = object.x;\n\t        object.clientY = object.y;\n\t    };\n\n\t    //NOTE Remember accessibility, Aria roles, and labels.\n\t}\n\n\tfunction createWindowRect() {\n\t    var props = {\n\t        top: { value: 0, enumerable: true },\n\t        left: { value: 0, enumerable: true },\n\t        right: { value: window.innerWidth, enumerable: true },\n\t        bottom: { value: window.innerHeight, enumerable: true },\n\t        width: { value: window.innerWidth, enumerable: true },\n\t        height: { value: window.innerHeight, enumerable: true },\n\t        x: { value: 0, enumerable: true },\n\t        y: { value: 0, enumerable: true }\n\t    };\n\n\t    if (Object.create) {\n\t        return Object.create({}, props);\n\t    } else {\n\t        var rect = {};\n\t        Object.defineProperties(rect, props);\n\t        return rect;\n\t    }\n\t}\n\n\tfunction getClientRect(el) {\n\t    if (el === window) {\n\t        return createWindowRect();\n\t    } else {\n\t        try {\n\t            var rect = el.getBoundingClientRect();\n\t            if (rect.x === undefined) {\n\t                rect.x = rect.left;\n\t                rect.y = rect.top;\n\t            }\n\t            return rect;\n\t        } catch (e) {\n\t            throw new TypeError(\"Can't call getBoundingClientRect on \" + el);\n\t        }\n\t    }\n\t}\n\n\tfunction pointInside(point, el) {\n\t    var rect = getClientRect(el);\n\t    return point.y > rect.top && point.y < rect.bottom && point.x > rect.left && point.x < rect.right;\n\t}\n\n\tvar objectCreate = void 0;\n\tif (typeof Object.create != 'function') {\n\t  objectCreate = function (undefined$1) {\n\t    var Temp = function Temp() {};\n\t    return function (prototype, propertiesObject) {\n\t      if (prototype !== Object(prototype) && prototype !== null) {\n\t        throw TypeError('Argument must be an object, or null');\n\t      }\n\t      Temp.prototype = prototype || {};\n\t      var result = new Temp();\n\t      Temp.prototype = null;\n\t      if (propertiesObject !== undefined$1) {\n\t        Object.defineProperties(result, propertiesObject);\n\t      }\n\n\t      // to imitate the case of Object.create(null)\n\t      if (prototype === null) {\n\t        result.__proto__ = null;\n\t      }\n\t      return result;\n\t    };\n\t  }();\n\t} else {\n\t  objectCreate = Object.create;\n\t}\n\n\tvar objectCreate$1 = objectCreate;\n\n\tvar mouseEventProps = ['altKey', 'button', 'buttons', 'clientX', 'clientY', 'ctrlKey', 'metaKey', 'movementX', 'movementY', 'offsetX', 'offsetY', 'pageX', 'pageY', 'region', 'relatedTarget', 'screenX', 'screenY', 'shiftKey', 'which', 'x', 'y'];\n\n\tfunction createDispatcher(element) {\n\n\t    var defaultSettings = {\n\t        screenX: 0,\n\t        screenY: 0,\n\t        clientX: 0,\n\t        clientY: 0,\n\t        ctrlKey: false,\n\t        shiftKey: false,\n\t        altKey: false,\n\t        metaKey: false,\n\t        button: 0,\n\t        buttons: 1,\n\t        relatedTarget: null,\n\t        region: null\n\t    };\n\n\t    if (element !== undefined) {\n\t        element.addEventListener('mousemove', onMove);\n\t    }\n\n\t    function onMove(e) {\n\t        for (var i = 0; i < mouseEventProps.length; i++) {\n\t            defaultSettings[mouseEventProps[i]] = e[mouseEventProps[i]];\n\t        }\n\t    }\n\n\t    var dispatch = function () {\n\t        if (MouseEvent) {\n\t            return function m1(element, initMove, data) {\n\t                var evt = new MouseEvent('mousemove', createMoveInit(defaultSettings, initMove));\n\n\t                //evt.dispatched = 'mousemove';\n\t                setSpecial(evt, data);\n\n\t                return element.dispatchEvent(evt);\n\t            };\n\t        } else if (typeof document.createEvent === 'function') {\n\t            return function m2(element, initMove, data) {\n\t                var settings = createMoveInit(defaultSettings, initMove);\n\t                var evt = document.createEvent('MouseEvents');\n\n\t                evt.initMouseEvent(\"mousemove\", true, //can bubble\n\t                true, //cancelable\n\t                window, //view\n\t                0, //detail\n\t                settings.screenX, //0, //screenX\n\t                settings.screenY, //0, //screenY\n\t                settings.clientX, //80, //clientX\n\t                settings.clientY, //20, //clientY\n\t                settings.ctrlKey, //false, //ctrlKey\n\t                settings.altKey, //false, //altKey\n\t                settings.shiftKey, //false, //shiftKey\n\t                settings.metaKey, //false, //metaKey\n\t                settings.button, //0, //button\n\t                settings.relatedTarget //null //relatedTarget\n\t                );\n\n\t                //evt.dispatched = 'mousemove';\n\t                setSpecial(evt, data);\n\n\t                return element.dispatchEvent(evt);\n\t            };\n\t        } else if (typeof document.createEventObject === 'function') {\n\t            return function m3(element, initMove, data) {\n\t                var evt = document.createEventObject();\n\t                var settings = createMoveInit(defaultSettings, initMove);\n\t                for (var name in settings) {\n\t                    evt[name] = settings[name];\n\t                }\n\n\t                //evt.dispatched = 'mousemove';\n\t                setSpecial(evt, data);\n\n\t                return element.dispatchEvent(evt);\n\t            };\n\t        }\n\t    }();\n\n\t    function destroy() {\n\t        if (element) { element.removeEventListener('mousemove', onMove, false); }\n\t        defaultSettings = null;\n\t    }\n\n\t    return {\n\t        destroy: destroy,\n\t        dispatch: dispatch\n\t    };\n\t}\n\n\tfunction createMoveInit(defaultSettings, initMove) {\n\t    initMove = initMove || {};\n\t    var settings = objectCreate$1(defaultSettings);\n\t    for (var i = 0; i < mouseEventProps.length; i++) {\n\t        if (initMove[mouseEventProps[i]] !== undefined) { settings[mouseEventProps[i]] = initMove[mouseEventProps[i]]; }\n\t    }\n\n\t    return settings;\n\t}\n\n\tfunction setSpecial(e, data) {\n\t    console.log('data ', data);\n\t    e.data = data || {};\n\t    e.dispatched = 'mousemove';\n\t}\n\n\tvar prefix = [ 'webkit', 'moz', 'ms', 'o' ];\n\n\tvar requestFrame = (function () {\n\n\t    if (typeof window === \"undefined\") {\n\t        return function () {};\n\t    }\n\n\t    for ( var i = 0, limit = prefix.length ; i < limit && ! window.requestAnimationFrame ; ++i ) {\n\t        window.requestAnimationFrame = window[ prefix[ i ] + 'RequestAnimationFrame' ];\n\t    }\n\n\t    if ( ! window.requestAnimationFrame ) {\n\t        var lastTime = 0;\n\n\t        window.requestAnimationFrame = function (callback) {\n\t            var now   = new Date().getTime();\n\t            var ttc   = Math.max( 0, 16 - now - lastTime );\n\t            var timer = window.setTimeout( function () { return callback( now + ttc ); }, ttc );\n\n\t            lastTime = now + ttc;\n\n\t            return timer;\n\t        };\n\t    }\n\n\t    return window.requestAnimationFrame.bind( window );\n\t})();\n\n\tvar cancelFrame = (function () {\n\n\t    if (typeof window === \"undefined\") {\n\t        return function () {};\n\t    }\n\n\t    for ( var i = 0, limit = prefix.length ; i < limit && ! window.cancelAnimationFrame ; ++i ) {\n\t        window.cancelAnimationFrame = window[ prefix[ i ] + 'CancelAnimationFrame' ] || window[ prefix[ i ] + 'CancelRequestAnimationFrame' ];\n\t    }\n\n\t    if ( ! window.cancelAnimationFrame ) {\n\t        window.cancelAnimationFrame = function (timer) {\n\t            window.clearTimeout( timer );\n\t        };\n\t    }\n\n\t    return window.cancelAnimationFrame.bind( window );\n\t})();\n\n\tfunction AutoScroller(elements, options){\n\t    if ( options === void 0 ) options = {};\n\n\t    var self = this;\n\t    var maxSpeed = 4, scrolling = false;\n\n\t    if (typeof options.margin !== 'object') {\n\t        var margin = options.margin || -1;\n\n\t        this.margin = {\n\t            left: margin,\n\t            right: margin,\n\t            top: margin,\n\t            bottom: margin\n\t        };\n\t    } else {\n\t        this.margin = options.margin;\n\t    }\n\n\t    //this.scrolling = false;\n\t    this.scrollWhenOutside = options.scrollWhenOutside || false;\n\n\t    var point = {},\n\t        pointCB = createPointCB(point),\n\t        dispatcher = createDispatcher(),\n\t        down = false;\n\n\t    window.addEventListener('mousemove', pointCB, false);\n\t    window.addEventListener('touchmove', pointCB, false);\n\n\t    if(!isNaN(options.maxSpeed)){\n\t        maxSpeed = options.maxSpeed;\n\t    }\n\n\t    if (typeof maxSpeed !== 'object') {\n\t        maxSpeed = {\n\t            left: maxSpeed,\n\t            right: maxSpeed,\n\t            top: maxSpeed,\n\t            bottom: maxSpeed\n\t        };\n\t    }\n\n\t    this.autoScroll = boolean(options.autoScroll);\n\t    this.syncMove = boolean(options.syncMove, false);\n\n\t    this.destroy = function(forceCleanAnimation) {\n\t        window.removeEventListener('mousemove', pointCB, false);\n\t        window.removeEventListener('touchmove', pointCB, false);\n\t        window.removeEventListener('mousedown', onDown, false);\n\t        window.removeEventListener('touchstart', onDown, false);\n\t        window.removeEventListener('mouseup', onUp, false);\n\t        window.removeEventListener('touchend', onUp, false);\n\t        window.removeEventListener('pointerup', onUp, false);\n\t        window.removeEventListener('mouseleave', onMouseOut, false);\n\n\t        window.removeEventListener('mousemove', onMove, false);\n\t        window.removeEventListener('touchmove', onMove, false);\n\n\t        window.removeEventListener('scroll', setScroll, true);\n\t        elements = [];\n\t        if(forceCleanAnimation){\n\t          cleanAnimation();\n\t        }\n\t    };\n\n\t    this.add = function(){\n\t        var element = [], len = arguments.length;\n\t        while ( len-- ) element[ len ] = arguments[ len ];\n\n\t        addElements.apply(void 0, [ elements ].concat( element ));\n\t        return this;\n\t    };\n\n\t    this.remove = function(){\n\t        var element = [], len = arguments.length;\n\t        while ( len-- ) element[ len ] = arguments[ len ];\n\n\t        return removeElements.apply(void 0, [ elements ].concat( element ));\n\t    };\n\n\t    var hasWindow = null, windowAnimationFrame;\n\n\t    if(Object.prototype.toString.call(elements) !== '[object Array]'){\n\t        elements = [elements];\n\t    }\n\n\t    (function(temp){\n\t        elements = [];\n\t        temp.forEach(function(element){\n\t            if(element === window){\n\t                hasWindow = window;\n\t            }else {\n\t                self.add(element);\n\t            }\n\t        });\n\t    }(elements));\n\n\t    Object.defineProperties(this, {\n\t        down: {\n\t            get: function(){ return down; }\n\t        },\n\t        maxSpeed: {\n\t            get: function(){ return maxSpeed; }\n\t        },\n\t        point: {\n\t            get: function(){ return point; }\n\t        },\n\t        scrolling: {\n\t            get: function(){ return scrolling; }\n\t        }\n\t    });\n\n\t    var current = null, animationFrame;\n\n\t    window.addEventListener('mousedown', onDown, false);\n\t    window.addEventListener('touchstart', onDown, false);\n\t    window.addEventListener('mouseup', onUp, false);\n\t    window.addEventListener('touchend', onUp, false);\n\n\t    /*\n\t    IE does not trigger mouseup event when scrolling.\n\t    It is a known issue that Microsoft won't fix.\n\t    https://connect.microsoft.com/IE/feedback/details/783058/scrollbar-trigger-mousedown-but-not-mouseup\n\t    IE supports pointer events instead\n\t    */\n\t    window.addEventListener('pointerup', onUp, false);\n\n\t    window.addEventListener('mousemove', onMove, false);\n\t    window.addEventListener('touchmove', onMove, false);\n\n\t    window.addEventListener('mouseleave', onMouseOut, false);\n\n\t    window.addEventListener('scroll', setScroll, true);\n\n\t    function setScroll(e){\n\n\t        for(var i=0; i<elements.length; i++){\n\t            if(elements[i] === e.target){\n\t                scrolling = true;\n\t                break;\n\t            }\n\t        }\n\n\t        if(scrolling){\n\t            requestFrame(function (){ return scrolling = false; });\n\t        }\n\t    }\n\n\t    function onDown(){\n\t        down = true;\n\t    }\n\n\t    function onUp(){\n\t        down = false;\n\t        cleanAnimation();\n\t    }\n\t    function cleanAnimation(){\n\t      cancelFrame(animationFrame);\n\t      cancelFrame(windowAnimationFrame);\n\t    }\n\t    function onMouseOut(){\n\t        down = false;\n\t    }\n\n\t    function getTarget(target){\n\t        if(!target){\n\t            return null;\n\t        }\n\n\t        if(current === target){\n\t            return target;\n\t        }\n\n\t        if(hasElement(elements, target)){\n\t            return target;\n\t        }\n\n\t        while(target = target.parentNode){\n\t            if(hasElement(elements, target)){\n\t                return target;\n\t            }\n\t        }\n\n\t        return null;\n\t    }\n\n\t    function getElementUnderPoint(){\n\t        var underPoint = null;\n\n\t        for(var i=0; i<elements.length; i++){\n\t            if(inside(point, elements[i])){\n\t                underPoint = elements[i];\n\t            }\n\t        }\n\n\t        return underPoint;\n\t    }\n\n\n\t    function onMove(event){\n\n\t        if(!self.autoScroll()) { return; }\n\n\t        if(event['dispatched']){ return; }\n\n\t        var target = event.target, body = document.body;\n\n\t        if(current && !inside(point, current)){\n\t            if(!self.scrollWhenOutside){\n\t                current = null;\n\t            }\n\t        }\n\n\t        if(target && target.parentNode === body){\n\t            //The special condition to improve speed.\n\t            target = getElementUnderPoint();\n\t        }else {\n\t            target = getTarget(target);\n\n\t            if(!target){\n\t                target = getElementUnderPoint();\n\t            }\n\t        }\n\n\n\t        if(target && target !== current){\n\t            current = target;\n\t        }\n\n\t        if(hasWindow){\n\t            cancelFrame(windowAnimationFrame);\n\t            windowAnimationFrame = requestFrame(scrollWindow);\n\t        }\n\n\n\t        if(!current){\n\t            return;\n\t        }\n\n\t        cancelFrame(animationFrame);\n\t        animationFrame = requestFrame(scrollTick);\n\t    }\n\n\t    function scrollWindow(){\n\t        autoScroll(hasWindow);\n\n\t        cancelFrame(windowAnimationFrame);\n\t        windowAnimationFrame = requestFrame(scrollWindow);\n\t    }\n\n\t    function scrollTick(){\n\n\t        if(!current){\n\t            return;\n\t        }\n\n\t        autoScroll(current);\n\n\t        cancelFrame(animationFrame);\n\t        animationFrame = requestFrame(scrollTick);\n\n\t    }\n\n\n\t    function autoScroll(el){\n\t        var rect = getClientRect(el), scrollx, scrolly;\n\n\t        if(point.x < rect.left + self.margin.left){\n\t            scrollx = Math.floor(\n\t                Math.max(-1, (point.x - rect.left) / self.margin.left - 1) * self.maxSpeed.left\n\t            );\n\t        }else if(point.x > rect.right - self.margin.right){\n\t            scrollx = Math.ceil(\n\t                Math.min(1, (point.x - rect.right) / self.margin.right + 1) * self.maxSpeed.right\n\t            );\n\t        }else {\n\t            scrollx = 0;\n\t        }\n\n\t        if(point.y < rect.top + self.margin.top){\n\t            scrolly = Math.floor(\n\t                Math.max(-1, (point.y - rect.top) / self.margin.top - 1) * self.maxSpeed.top\n\t            );\n\t        }else if(point.y > rect.bottom - self.margin.bottom){\n\t            scrolly = Math.ceil(\n\t                Math.min(1, (point.y - rect.bottom) / self.margin.bottom + 1) * self.maxSpeed.bottom\n\t            );\n\t        }else {\n\t            scrolly = 0;\n\t        }\n\n\t        if(self.syncMove()){\n\t            /*\n\t            Notes about mousemove event dispatch.\n\t            screen(X/Y) should need to be updated.\n\t            Some other properties might need to be set.\n\t            Keep the syncMove option default false until all inconsistencies are taken care of.\n\t            */\n\t            dispatcher.dispatch(el, {\n\t                pageX: point.pageX + scrollx,\n\t                pageY: point.pageY + scrolly,\n\t                clientX: point.x + scrollx,\n\t                clientY: point.y + scrolly\n\t            });\n\t        }\n\n\t        setTimeout(function (){\n\n\t            if(scrolly){\n\t                scrollY(el, scrolly);\n\t            }\n\n\t            if(scrollx){\n\t                scrollX(el, scrollx);\n\t            }\n\n\t        });\n\t    }\n\n\t    function scrollY(el, amount){\n\t        if(el === window){\n\t            window.scrollTo(el.pageXOffset, el.pageYOffset + amount);\n\t        }else {\n\t            el.scrollTop += amount;\n\t        }\n\t    }\n\n\t    function scrollX(el, amount){\n\t        if(el === window){\n\t            window.scrollTo(el.pageXOffset + amount, el.pageYOffset);\n\t        }else {\n\t            el.scrollLeft += amount;\n\t        }\n\t    }\n\n\t}\n\n\tfunction AutoScrollerFactory(element, options){\n\t    return new AutoScroller(element, options);\n\t}\n\n\tfunction inside(point, el, rect){\n\t    if(!rect){\n\t        return pointInside(point, el);\n\t    }else {\n\t        return (point.y > rect.top && point.y < rect.bottom &&\n\t                point.x > rect.left && point.x < rect.right);\n\t    }\n\t}\n\n\tvar angularDraggableDroppable_umd = createCommonjsModule(function (module, exports) {\n\t(function (global, factory) {\n\t     factory(exports, rxjs, common, AutoScrollerFactory, core, operators) ;\n\t}(commonjsGlobal, (function (exports,rxjs,common,autoScroll,i0,operators) {\n\t    autoScroll = autoScroll && autoScroll.hasOwnProperty('default') ? autoScroll['default'] : autoScroll;\n\n\t    /*! *****************************************************************************\n\t    Copyright (c) Microsoft Corporation. All rights reserved.\n\t    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n\t    this file except in compliance with the License. You may obtain a copy of the\n\t    License at http://www.apache.org/licenses/LICENSE-2.0\n\n\t    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\t    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n\t    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n\t    MERCHANTABLITY OR NON-INFRINGEMENT.\n\n\t    See the Apache Version 2.0 License for specific language governing permissions\n\t    and limitations under the License.\n\t    ***************************************************************************** */\n\t    var __assign = function () {\n\t        __assign = Object.assign || function __assign(t) {\n\t            for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t                s = arguments[i];\n\t                for (var p in s)\n\t                    if (Object.prototype.hasOwnProperty.call(s, p))\n\t                        t[p] = s[p];\n\t            }\n\t            return t;\n\t        };\n\t        return __assign.apply(this, arguments);\n\t    };\n\t    function __read(o, n) {\n\t        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n\t        if (!m)\n\t            return o;\n\t        var i = m.call(o), r, ar = [], e;\n\t        try {\n\t            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n\t                ar.push(r.value);\n\t        }\n\t        catch (error) {\n\t            e = { error: error };\n\t        }\n\t        finally {\n\t            try {\n\t                if (r && !r.done && (m = i[\"return\"]))\n\t                    m.call(i);\n\t            }\n\t            finally {\n\t                if (e)\n\t                    throw e.error;\n\t            }\n\t        }\n\t        return ar;\n\t    }\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    var DraggableHelper = /** @class */ (function () {\n\t        function DraggableHelper() {\n\t            this.currentDrag = new rxjs.Subject();\n\t        }\n\t        DraggableHelper.decorators = [\n\t            { type: i0.Injectable, args: [{\n\t                        providedIn: 'root',\n\t                    },] }\n\t        ];\n\t        /** @nocollapse */ DraggableHelper.ngInjectableDef = i0.defineInjectable({ factory: function DraggableHelper_Factory() { return new DraggableHelper(); }, token: DraggableHelper, providedIn: \"root\" });\n\t        return DraggableHelper;\n\t    }());\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    /**\n\t     * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n\t     * ```html\n\t     * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n\t     * <div mwlDraggable>Drag me!</div>\n\t     * </div>\n\t     * ```\n\t     */\n\t    var DraggableScrollContainerDirective = /** @class */ (function () {\n\t        /**\n\t         * @hidden\n\t         */\n\t        function DraggableScrollContainerDirective(elementRef) {\n\t            this.elementRef = elementRef;\n\t            /**\n\t             * Trigger the DragStart after a long touch in scrollable container when true\n\t             * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n\t             */\n\t            this.activeLongPressDrag = false;\n\t            /**\n\t             * Configuration of a long touch\n\t             * Duration in ms of a long touch before activating DragStart\n\t             * Delta of the\n\t             * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n\t             */\n\t            this.longPressConfig = { duration: 300, delta: 30 };\n\t        }\n\t        DraggableScrollContainerDirective.decorators = [\n\t            { type: i0.Directive, args: [{\n\t                        selector: '[mwlDraggableScrollContainer]',\n\t                    },] }\n\t        ];\n\t        /** @nocollapse */\n\t        DraggableScrollContainerDirective.ctorParameters = function () {\n\t            return [\n\t                { type: i0.ElementRef }\n\t            ];\n\t        };\n\t        DraggableScrollContainerDirective.propDecorators = {\n\t            activeLongPressDrag: [{ type: i0.Input }],\n\t            longPressConfig: [{ type: i0.Input }]\n\t        };\n\t        return DraggableScrollContainerDirective;\n\t    }());\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    /**\n\t     * @param {?} renderer\n\t     * @param {?} element\n\t     * @param {?} classToAdd\n\t     * @return {?}\n\t     */\n\t    function addClass(renderer, element, classToAdd) {\n\t        if (classToAdd) {\n\t            classToAdd\n\t                .split(' ')\n\t                .forEach(( /**\n\t         * @param {?} className\n\t         * @return {?}\n\t         */function (className) {\n\t                return renderer.addClass(element.nativeElement, className);\n\t            }));\n\t        }\n\t    }\n\t    /**\n\t     * @param {?} renderer\n\t     * @param {?} element\n\t     * @param {?} classToRemove\n\t     * @return {?}\n\t     */\n\t    function removeClass(renderer, element, classToRemove) {\n\t        if (classToRemove) {\n\t            classToRemove\n\t                .split(' ')\n\t                .forEach(( /**\n\t         * @param {?} className\n\t         * @return {?}\n\t         */function (className) {\n\t                return renderer.removeClass(element.nativeElement, className);\n\t            }));\n\t        }\n\t    }\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    var DraggableDirective = /** @class */ (function () {\n\t        /**\n\t         * @hidden\n\t         */\n\t        function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n\t            this.element = element;\n\t            this.renderer = renderer;\n\t            this.draggableHelper = draggableHelper;\n\t            this.zone = zone;\n\t            this.vcr = vcr;\n\t            this.scrollContainer = scrollContainer;\n\t            this.document = document;\n\t            /**\n\t             * The axis along which the element is draggable\n\t             */\n\t            this.dragAxis = { x: true, y: true };\n\t            /**\n\t             * Snap all drags to an x / y grid\n\t             */\n\t            this.dragSnapGrid = {};\n\t            /**\n\t             * Show a ghost element that shows the drag when dragging\n\t             */\n\t            this.ghostDragEnabled = true;\n\t            /**\n\t             * Show the original element when ghostDragEnabled is true\n\t             */\n\t            this.showOriginalElementWhileDragging = false;\n\t            /**\n\t             * The cursor to use when hovering over a draggable element\n\t             */\n\t            this.dragCursor = '';\n\t            /*\n\t               * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n\t               */\n\t            this.autoScroll = {\n\t                margin: 20,\n\t            };\n\t            /**\n\t             * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n\t             */\n\t            this.dragPointerDown = new i0.EventEmitter();\n\t            /**\n\t             * Called when the element has started to be dragged.\n\t             * Only called after at least one mouse or touch move event.\n\t             * If you call $event.cancelDrag$.emit() it will cancel the current drag\n\t             */\n\t            this.dragStart = new i0.EventEmitter();\n\t            /**\n\t             * Called after the ghost element has been created\n\t             */\n\t            this.ghostElementCreated = new i0.EventEmitter();\n\t            /**\n\t             * Called when the element is being dragged\n\t             */\n\t            this.dragging = new i0.EventEmitter();\n\t            /**\n\t             * Called after the element is dragged\n\t             */\n\t            this.dragEnd = new i0.EventEmitter();\n\t            /**\n\t             * @hidden\n\t             */\n\t            this.pointerDown$ = new rxjs.Subject();\n\t            /**\n\t             * @hidden\n\t             */\n\t            this.pointerMove$ = new rxjs.Subject();\n\t            /**\n\t             * @hidden\n\t             */\n\t            this.pointerUp$ = new rxjs.Subject();\n\t            this.eventListenerSubscriptions = {};\n\t            this.destroy$ = new rxjs.Subject();\n\t            this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n\t        }\n\t        /**\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.ngOnInit = /**\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                var _this = this;\n\t                this.checkEventListeners();\n\t                /** @type {?} */\n\t                var pointerDragged$ = this.pointerDown$.pipe(operators.filter(( /**\n\t                 * @return {?}\n\t                 */function () { return _this.canDrag(); })), operators.mergeMap(( /**\n\t                 * @param {?} pointerDownEvent\n\t                 * @return {?}\n\t                 */function (pointerDownEvent) {\n\t                    // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n\t                    // stop mouse events propagating up the chain\n\t                    if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {\n\t                        pointerDownEvent.event.stopPropagation();\n\t                    }\n\t                    // hack to prevent text getting selected in safari while dragging\n\t                    /** @type {?} */\n\t                    var globalDragStyle = _this.renderer.createElement('style');\n\t                    _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n\t                    _this.renderer.appendChild(globalDragStyle, _this.renderer.createText(\"\\n          body * {\\n           -moz-user-select: none;\\n           -ms-user-select: none;\\n           -webkit-user-select: none;\\n           user-select: none;\\n          }\\n        \"));\n\t                    requestAnimationFrame(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        _this.document.head.appendChild(globalDragStyle);\n\t                    }));\n\t                    /** @type {?} */\n\t                    var startScrollPosition = _this.getScrollPosition();\n\t                    /** @type {?} */\n\t                    var scrollContainerScroll$ = new rxjs.Observable(( /**\n\t                     * @param {?} observer\n\t                     * @return {?}\n\t                     */function (observer) {\n\t                        /** @type {?} */\n\t                        var scrollContainer = _this.scrollContainer\n\t                            ? _this.scrollContainer.elementRef.nativeElement\n\t                            : 'window';\n\t                        return _this.renderer.listen(scrollContainer, 'scroll', ( /**\n\t                         * @param {?} e\n\t                         * @return {?}\n\t                         */function (e) {\n\t                            return observer.next(e);\n\t                        }));\n\t                    })).pipe(operators.startWith(startScrollPosition), operators.map(( /**\n\t                     * @return {?}\n\t                     */function () { return _this.getScrollPosition(); })));\n\t                    /** @type {?} */\n\t                    var currentDrag$ = new rxjs.Subject();\n\t                    /** @type {?} */\n\t                    var cancelDrag$ = new rxjs.ReplaySubject();\n\t                    _this.zone.run(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        _this.dragPointerDown.next({ x: 0, y: 0 });\n\t                    }));\n\t                    /** @type {?} */\n\t                    var dragComplete$ = rxjs.merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(operators.share());\n\t                    /** @type {?} */\n\t                    var pointerMove = rxjs.combineLatest([\n\t                        _this.pointerMove$,\n\t                        scrollContainerScroll$,\n\t                    ]).pipe(operators.map(( /**\n\t                     * @param {?} __0\n\t                     * @return {?}\n\t                     */function (_a) {\n\t                        var _b = __read(_a, 2), pointerMoveEvent = _b[0], scroll = _b[1];\n\t                        return {\n\t                            currentDrag$: currentDrag$,\n\t                            transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n\t                            transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n\t                            clientX: pointerMoveEvent.clientX,\n\t                            clientY: pointerMoveEvent.clientY,\n\t                            scrollLeft: scroll.left,\n\t                            scrollTop: scroll.top,\n\t                            target: pointerMoveEvent.event.target,\n\t                        };\n\t                    })), operators.map(( /**\n\t                     * @param {?} moveData\n\t                     * @return {?}\n\t                     */function (moveData) {\n\t                        if (_this.dragSnapGrid.x) {\n\t                            moveData.transformX =\n\t                                Math.round(moveData.transformX / _this.dragSnapGrid.x) *\n\t                                    _this.dragSnapGrid.x;\n\t                        }\n\t                        if (_this.dragSnapGrid.y) {\n\t                            moveData.transformY =\n\t                                Math.round(moveData.transformY / _this.dragSnapGrid.y) *\n\t                                    _this.dragSnapGrid.y;\n\t                        }\n\t                        return moveData;\n\t                    })), operators.map(( /**\n\t                     * @param {?} moveData\n\t                     * @return {?}\n\t                     */function (moveData) {\n\t                        if (!_this.dragAxis.x) {\n\t                            moveData.transformX = 0;\n\t                        }\n\t                        if (!_this.dragAxis.y) {\n\t                            moveData.transformY = 0;\n\t                        }\n\t                        return moveData;\n\t                    })), operators.map(( /**\n\t                     * @param {?} moveData\n\t                     * @return {?}\n\t                     */function (moveData) {\n\t                        /** @type {?} */\n\t                        var scrollX = moveData.scrollLeft - startScrollPosition.left;\n\t                        /** @type {?} */\n\t                        var scrollY = moveData.scrollTop - startScrollPosition.top;\n\t                        return __assign({}, moveData, { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n\t                    })), operators.filter(( /**\n\t                     * @param {?} __0\n\t                     * @return {?}\n\t                     */function (_a) {\n\t                        var x = _a.x, y = _a.y, transformX = _a.transformX, transformY = _a.transformY;\n\t                        return !_this.validateDrag ||\n\t                            _this.validateDrag({\n\t                                x: x,\n\t                                y: y,\n\t                                transform: { x: transformX, y: transformY },\n\t                            });\n\t                    })), operators.takeUntil(dragComplete$), operators.share());\n\t                    /** @type {?} */\n\t                    var dragStarted$ = pointerMove.pipe(operators.take(1), operators.share());\n\t                    /** @type {?} */\n\t                    var dragEnded$ = pointerMove.pipe(operators.takeLast(1), operators.share());\n\t                    dragStarted$.subscribe(( /**\n\t                     * @param {?} __0\n\t                     * @return {?}\n\t                     */function (_a) {\n\t                        var clientX = _a.clientX, clientY = _a.clientY, x = _a.x, y = _a.y;\n\t                        _this.zone.run(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.dragStart.next({ cancelDrag$: cancelDrag$ });\n\t                        }));\n\t                        _this.scroller = autoScroll([\n\t                            _this.scrollContainer\n\t                                ? _this.scrollContainer.elementRef.nativeElement\n\t                                : _this.document.defaultView,\n\t                        ], __assign({}, _this.autoScroll, { autoScroll: /**\n\t                                 * @return {?}\n\t                                 */ function () {\n\t                                return true;\n\t                            } }));\n\t                        addClass(_this.renderer, _this.element, _this.dragActiveClass);\n\t                        if (_this.ghostDragEnabled) {\n\t                            /** @type {?} */\n\t                            var rect = _this.element.nativeElement.getBoundingClientRect();\n\t                            /** @type {?} */\n\t                            var clone_1 = ( /** @type {?} */(_this.element.nativeElement.cloneNode(true)));\n\t                            if (!_this.showOriginalElementWhileDragging) {\n\t                                _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');\n\t                            }\n\t                            if (_this.ghostElementAppendTo) {\n\t                                _this.ghostElementAppendTo.appendChild(clone_1);\n\t                            }\n\t                            else {\n\t                                ( /** @type {?} */(_this.element.nativeElement.parentNode)).insertBefore(clone_1, _this.element.nativeElement.nextSibling);\n\t                            }\n\t                            _this.ghostElement = clone_1;\n\t                            _this.document.body.style.cursor = _this.dragCursor;\n\t                            _this.setElementStyles(clone_1, {\n\t                                position: 'fixed',\n\t                                top: rect.top + \"px\",\n\t                                left: rect.left + \"px\",\n\t                                width: rect.width + \"px\",\n\t                                height: rect.height + \"px\",\n\t                                cursor: _this.dragCursor,\n\t                                margin: '0',\n\t                                willChange: 'transform',\n\t                                pointerEvents: 'none',\n\t                            });\n\t                            if (_this.ghostElementTemplate) {\n\t                                /** @type {?} */\n\t                                var viewRef_1 = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);\n\t                                clone_1.innerHTML = '';\n\t                                viewRef_1.rootNodes\n\t                                    .filter(( /**\n\t                             * @param {?} node\n\t                             * @return {?}\n\t                             */function (node) { return node instanceof Node; }))\n\t                                    .forEach(( /**\n\t                             * @param {?} node\n\t                             * @return {?}\n\t                             */function (node) {\n\t                                    clone_1.appendChild(node);\n\t                                }));\n\t                                dragEnded$.subscribe(( /**\n\t                                 * @return {?}\n\t                                 */function () {\n\t                                    _this.vcr.remove(_this.vcr.indexOf(viewRef_1));\n\t                                }));\n\t                            }\n\t                            _this.zone.run(( /**\n\t                             * @return {?}\n\t                             */function () {\n\t                                _this.ghostElementCreated.emit({\n\t                                    clientX: clientX - x,\n\t                                    clientY: clientY - y,\n\t                                    element: clone_1,\n\t                                });\n\t                            }));\n\t                            dragEnded$.subscribe(( /**\n\t                             * @return {?}\n\t                             */function () {\n\t                                ( /** @type {?} */(clone_1.parentElement)).removeChild(clone_1);\n\t                                _this.ghostElement = null;\n\t                                _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');\n\t                            }));\n\t                        }\n\t                        _this.draggableHelper.currentDrag.next(currentDrag$);\n\t                    }));\n\t                    dragEnded$\n\t                        .pipe(operators.mergeMap(( /**\n\t                 * @param {?} dragEndData\n\t                 * @return {?}\n\t                 */function (dragEndData) {\n\t                        /** @type {?} */\n\t                        var dragEndData$ = cancelDrag$.pipe(operators.count(), operators.take(1), operators.map(( /**\n\t                         * @param {?} calledCount\n\t                         * @return {?}\n\t                         */function (calledCount) { return (__assign({}, dragEndData, { dragCancelled: calledCount > 0 })); })));\n\t                        cancelDrag$.complete();\n\t                        return dragEndData$;\n\t                    })))\n\t                        .subscribe(( /**\n\t                 * @param {?} __0\n\t                 * @return {?}\n\t                 */function (_a) {\n\t                        var x = _a.x, y = _a.y, dragCancelled = _a.dragCancelled;\n\t                        _this.scroller.destroy();\n\t                        _this.zone.run(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.dragEnd.next({ x: x, y: y, dragCancelled: dragCancelled });\n\t                        }));\n\t                        removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n\t                        currentDrag$.complete();\n\t                    }));\n\t                    rxjs.merge(dragComplete$, dragEnded$)\n\t                        .pipe(operators.take(1))\n\t                        .subscribe(( /**\n\t                 * @return {?}\n\t                 */function () {\n\t                        requestAnimationFrame(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.document.head.removeChild(globalDragStyle);\n\t                        }));\n\t                    }));\n\t                    return pointerMove;\n\t                })), operators.share());\n\t                rxjs.merge(pointerDragged$.pipe(operators.take(1), operators.map(( /**\n\t                 * @param {?} value\n\t                 * @return {?}\n\t                 */function (value) { return [, value]; }))), pointerDragged$.pipe(operators.pairwise()))\n\t                    .pipe(operators.filter(( /**\n\t             * @param {?} __0\n\t             * @return {?}\n\t             */function (_a) {\n\t                    var _b = __read(_a, 2), previous = _b[0], next = _b[1];\n\t                    if (!previous) {\n\t                        return true;\n\t                    }\n\t                    return previous.x !== next.x || previous.y !== next.y;\n\t                })), operators.map(( /**\n\t                 * @param {?} __0\n\t                 * @return {?}\n\t                 */function (_a) {\n\t                    var _b = __read(_a, 2), previous = _b[0], next = _b[1];\n\t                    return next;\n\t                })))\n\t                    .subscribe(( /**\n\t             * @param {?} __0\n\t             * @return {?}\n\t             */function (_a) {\n\t                    var x = _a.x, y = _a.y, currentDrag$ = _a.currentDrag$, clientX = _a.clientX, clientY = _a.clientY, transformX = _a.transformX, transformY = _a.transformY, target = _a.target;\n\t                    _this.zone.run(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        _this.dragging.next({ x: x, y: y });\n\t                    }));\n\t                    requestAnimationFrame(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        if (_this.ghostElement) {\n\t                            /** @type {?} */\n\t                            var transform = \"translate3d(\" + transformX + \"px, \" + transformY + \"px, 0px)\";\n\t                            _this.setElementStyles(_this.ghostElement, {\n\t                                transform: transform,\n\t                                '-webkit-transform': transform,\n\t                                '-ms-transform': transform,\n\t                                '-moz-transform': transform,\n\t                                '-o-transform': transform,\n\t                            });\n\t                        }\n\t                    }));\n\t                    currentDrag$.next({\n\t                        clientX: clientX,\n\t                        clientY: clientY,\n\t                        dropData: _this.dropData,\n\t                        target: target,\n\t                    });\n\t                }));\n\t            };\n\t        /**\n\t         * @param {?} changes\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.ngOnChanges = /**\n\t         * @param {?} changes\n\t         * @return {?}\n\t         */\n\t            function (changes) {\n\t                if (changes.dragAxis) {\n\t                    this.checkEventListeners();\n\t                }\n\t            };\n\t        /**\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.ngOnDestroy = /**\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                this.unsubscribeEventListeners();\n\t                this.pointerDown$.complete();\n\t                this.pointerMove$.complete();\n\t                this.pointerUp$.complete();\n\t                this.destroy$.next();\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.checkEventListeners = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                var _this = this;\n\t                /** @type {?} */\n\t                var canDrag = this.canDrag();\n\t                /** @type {?} */\n\t                var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\t                if (canDrag && !hasEventListeners) {\n\t                    this.zone.runOutsideAngular(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        _this.eventListenerSubscriptions.mousedown = _this.renderer.listen(_this.element.nativeElement, 'mousedown', ( /**\n\t                         * @param {?} event\n\t                         * @return {?}\n\t                         */function (event) {\n\t                            _this.onMouseDown(event);\n\t                        }));\n\t                        _this.eventListenerSubscriptions.mouseup = _this.renderer.listen('document', 'mouseup', ( /**\n\t                         * @param {?} event\n\t                         * @return {?}\n\t                         */function (event) {\n\t                            _this.onMouseUp(event);\n\t                        }));\n\t                        _this.eventListenerSubscriptions.touchstart = _this.renderer.listen(_this.element.nativeElement, 'touchstart', ( /**\n\t                         * @param {?} event\n\t                         * @return {?}\n\t                         */function (event) {\n\t                            _this.onTouchStart(event);\n\t                        }));\n\t                        _this.eventListenerSubscriptions.touchend = _this.renderer.listen('document', 'touchend', ( /**\n\t                         * @param {?} event\n\t                         * @return {?}\n\t                         */function (event) {\n\t                            _this.onTouchEnd(event);\n\t                        }));\n\t                        _this.eventListenerSubscriptions.touchcancel = _this.renderer.listen('document', 'touchcancel', ( /**\n\t                         * @param {?} event\n\t                         * @return {?}\n\t                         */function (event) {\n\t                            _this.onTouchEnd(event);\n\t                        }));\n\t                        _this.eventListenerSubscriptions.mouseenter = _this.renderer.listen(_this.element.nativeElement, 'mouseenter', ( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.onMouseEnter();\n\t                        }));\n\t                        _this.eventListenerSubscriptions.mouseleave = _this.renderer.listen(_this.element.nativeElement, 'mouseleave', ( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.onMouseLeave();\n\t                        }));\n\t                    }));\n\t                }\n\t                else if (!canDrag && hasEventListeners) {\n\t                    this.unsubscribeEventListeners();\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onMouseDown = /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t            function (event) {\n\t                var _this = this;\n\t                if (event.button === 0) {\n\t                    if (!this.eventListenerSubscriptions.mousemove) {\n\t                        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', ( /**\n\t                         * @param {?} mouseMoveEvent\n\t                         * @return {?}\n\t                         */function (mouseMoveEvent) {\n\t                            _this.pointerMove$.next({\n\t                                event: mouseMoveEvent,\n\t                                clientX: mouseMoveEvent.clientX,\n\t                                clientY: mouseMoveEvent.clientY,\n\t                            });\n\t                        }));\n\t                    }\n\t                    this.pointerDown$.next({\n\t                        event: event,\n\t                        clientX: event.clientX,\n\t                        clientY: event.clientY,\n\t                    });\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onMouseUp = /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t            function (event) {\n\t                if (event.button === 0) {\n\t                    if (this.eventListenerSubscriptions.mousemove) {\n\t                        this.eventListenerSubscriptions.mousemove();\n\t                        delete this.eventListenerSubscriptions.mousemove;\n\t                    }\n\t                    this.pointerUp$.next({\n\t                        event: event,\n\t                        clientX: event.clientX,\n\t                        clientY: event.clientY,\n\t                    });\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onTouchStart = /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t            function (event) {\n\t                var _this = this;\n\t                /** @type {?} */\n\t                var startScrollPosition;\n\t                /** @type {?} */\n\t                var isDragActivated;\n\t                /** @type {?} */\n\t                var hasContainerScrollbar;\n\t                if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n\t                    this.touchStartLongPress) {\n\t                    this.timeLongPress.timerBegin = Date.now();\n\t                    isDragActivated = false;\n\t                    hasContainerScrollbar = this.hasScrollbar();\n\t                    startScrollPosition = this.getScrollPosition();\n\t                }\n\t                if (!this.eventListenerSubscriptions.touchmove) {\n\t                    /** @type {?} */\n\t                    var contextMenuListener_1 = rxjs.fromEvent(this.document, 'contextmenu').subscribe(( /**\n\t                     * @param {?} e\n\t                     * @return {?}\n\t                     */function (e) {\n\t                        e.preventDefault();\n\t                    }));\n\t                    /** @type {?} */\n\t                    var touchMoveListener_1 = rxjs.fromEvent(this.document, 'touchmove', {\n\t                        passive: false,\n\t                    }).subscribe(( /**\n\t                     * @param {?} touchMoveEvent\n\t                     * @return {?}\n\t                     */function (touchMoveEvent) {\n\t                        if (((_this.scrollContainer && _this.scrollContainer.activeLongPressDrag) ||\n\t                            _this.touchStartLongPress) &&\n\t                            !isDragActivated &&\n\t                            hasContainerScrollbar) {\n\t                            isDragActivated = _this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n\t                        }\n\t                        if (((!_this.scrollContainer ||\n\t                            !_this.scrollContainer.activeLongPressDrag) &&\n\t                            !_this.touchStartLongPress) ||\n\t                            !hasContainerScrollbar ||\n\t                            isDragActivated) {\n\t                            touchMoveEvent.preventDefault();\n\t                            _this.pointerMove$.next({\n\t                                event: touchMoveEvent,\n\t                                clientX: touchMoveEvent.targetTouches[0].clientX,\n\t                                clientY: touchMoveEvent.targetTouches[0].clientY,\n\t                            });\n\t                        }\n\t                    }));\n\t                    this.eventListenerSubscriptions.touchmove = ( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        contextMenuListener_1.unsubscribe();\n\t                        touchMoveListener_1.unsubscribe();\n\t                    });\n\t                }\n\t                this.pointerDown$.next({\n\t                    event: event,\n\t                    clientX: event.touches[0].clientX,\n\t                    clientY: event.touches[0].clientY,\n\t                });\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onTouchEnd = /**\n\t         * @private\n\t         * @param {?} event\n\t         * @return {?}\n\t         */\n\t            function (event) {\n\t                if (this.eventListenerSubscriptions.touchmove) {\n\t                    this.eventListenerSubscriptions.touchmove();\n\t                    delete this.eventListenerSubscriptions.touchmove;\n\t                    if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n\t                        this.touchStartLongPress) {\n\t                        this.enableScroll();\n\t                    }\n\t                }\n\t                this.pointerUp$.next({\n\t                    event: event,\n\t                    clientX: event.changedTouches[0].clientX,\n\t                    clientY: event.changedTouches[0].clientY,\n\t                });\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onMouseEnter = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                this.setCursor(this.dragCursor);\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.onMouseLeave = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                this.setCursor('');\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.canDrag = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                return this.dragAxis.x || this.dragAxis.y;\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} value\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.setCursor = /**\n\t         * @private\n\t         * @param {?} value\n\t         * @return {?}\n\t         */\n\t            function (value) {\n\t                if (!this.eventListenerSubscriptions.mousemove) {\n\t                    this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.unsubscribeEventListeners = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                var _this = this;\n\t                Object.keys(this.eventListenerSubscriptions).forEach(( /**\n\t                 * @param {?} type\n\t                 * @return {?}\n\t                 */function (type) {\n\t                    (( /** @type {?} */(_this))).eventListenerSubscriptions[type]();\n\t                    delete (( /** @type {?} */(_this))).eventListenerSubscriptions[type];\n\t                }));\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} element\n\t         * @param {?} styles\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.setElementStyles = /**\n\t         * @private\n\t         * @param {?} element\n\t         * @param {?} styles\n\t         * @return {?}\n\t         */\n\t            function (element, styles) {\n\t                var _this = this;\n\t                Object.keys(styles).forEach(( /**\n\t                 * @param {?} key\n\t                 * @return {?}\n\t                 */function (key) {\n\t                    _this.renderer.setStyle(element, key, styles[key]);\n\t                }));\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.getScrollElement = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                if (this.scrollContainer) {\n\t                    return this.scrollContainer.elementRef.nativeElement;\n\t                }\n\t                else {\n\t                    return this.document.body;\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.getScrollPosition = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                if (this.scrollContainer) {\n\t                    return {\n\t                        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n\t                        left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n\t                    };\n\t                }\n\t                else {\n\t                    return {\n\t                        top: window.pageYOffset || this.document.documentElement.scrollTop,\n\t                        left: window.pageXOffset || this.document.documentElement.scrollLeft,\n\t                    };\n\t                }\n\t            };\n\t        /**\n\t         * @private\n\t         * @param {?} event\n\t         * @param {?} touchMoveEvent\n\t         * @param {?} startScrollPosition\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.shouldBeginDrag = /**\n\t         * @private\n\t         * @param {?} event\n\t         * @param {?} touchMoveEvent\n\t         * @param {?} startScrollPosition\n\t         * @return {?}\n\t         */\n\t            function (event, touchMoveEvent, startScrollPosition) {\n\t                /** @type {?} */\n\t                var moveScrollPosition = this.getScrollPosition();\n\t                /** @type {?} */\n\t                var deltaScroll = {\n\t                    top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n\t                    left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n\t                };\n\t                /** @type {?} */\n\t                var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n\t                /** @type {?} */\n\t                var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n\t                /** @type {?} */\n\t                var deltaTotal = deltaX + deltaY;\n\t                /** @type {?} */\n\t                var longPressConfig = this.touchStartLongPress\n\t                    ? this.touchStartLongPress\n\t                    : /* istanbul ignore next */\n\t                        {\n\t                            delta: this.scrollContainer.longPressConfig.delta,\n\t                            delay: this.scrollContainer.longPressConfig.duration,\n\t                        };\n\t                if (deltaTotal > longPressConfig.delta ||\n\t                    deltaScroll.top > 0 ||\n\t                    deltaScroll.left > 0) {\n\t                    this.timeLongPress.timerBegin = Date.now();\n\t                }\n\t                this.timeLongPress.timerEnd = Date.now();\n\t                /** @type {?} */\n\t                var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\t                if (duration >= longPressConfig.delay) {\n\t                    this.disableScroll();\n\t                    return true;\n\t                }\n\t                return false;\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.enableScroll = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                if (this.scrollContainer) {\n\t                    this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n\t                }\n\t                this.renderer.setStyle(this.document.body, 'overflow', '');\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.disableScroll = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                /* istanbul ignore next */\n\t                if (this.scrollContainer) {\n\t                    this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n\t                }\n\t                this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n\t            };\n\t        /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t        DraggableDirective.prototype.hasScrollbar = /**\n\t         * @private\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                /** @type {?} */\n\t                var scrollContainer = this.getScrollElement();\n\t                /** @type {?} */\n\t                var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n\t                /** @type {?} */\n\t                var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n\t                return containerHasHorizontalScroll || containerHasVerticalScroll;\n\t            };\n\t        DraggableDirective.decorators = [\n\t            { type: i0.Directive, args: [{\n\t                        selector: '[mwlDraggable]',\n\t                    },] }\n\t        ];\n\t        /** @nocollapse */\n\t        DraggableDirective.ctorParameters = function () {\n\t            return [\n\t                { type: i0.ElementRef },\n\t                { type: i0.Renderer2 },\n\t                { type: DraggableHelper },\n\t                { type: i0.NgZone },\n\t                { type: i0.ViewContainerRef },\n\t                { type: DraggableScrollContainerDirective, decorators: [{ type: i0.Optional }] },\n\t                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }\n\t            ];\n\t        };\n\t        DraggableDirective.propDecorators = {\n\t            dropData: [{ type: i0.Input }],\n\t            dragAxis: [{ type: i0.Input }],\n\t            dragSnapGrid: [{ type: i0.Input }],\n\t            ghostDragEnabled: [{ type: i0.Input }],\n\t            showOriginalElementWhileDragging: [{ type: i0.Input }],\n\t            validateDrag: [{ type: i0.Input }],\n\t            dragCursor: [{ type: i0.Input }],\n\t            dragActiveClass: [{ type: i0.Input }],\n\t            ghostElementAppendTo: [{ type: i0.Input }],\n\t            ghostElementTemplate: [{ type: i0.Input }],\n\t            touchStartLongPress: [{ type: i0.Input }],\n\t            autoScroll: [{ type: i0.Input }],\n\t            dragPointerDown: [{ type: i0.Output }],\n\t            dragStart: [{ type: i0.Output }],\n\t            ghostElementCreated: [{ type: i0.Output }],\n\t            dragging: [{ type: i0.Output }],\n\t            dragEnd: [{ type: i0.Output }]\n\t        };\n\t        return DraggableDirective;\n\t    }());\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    /**\n\t     * @param {?} clientX\n\t     * @param {?} clientY\n\t     * @param {?} rect\n\t     * @return {?}\n\t     */\n\t    function isCoordinateWithinRectangle(clientX, clientY, rect) {\n\t        return (clientX >= rect.left &&\n\t            clientX <= rect.right &&\n\t            clientY >= rect.top &&\n\t            clientY <= rect.bottom);\n\t    }\n\t    var DroppableDirective = /** @class */ (function () {\n\t        function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n\t            this.element = element;\n\t            this.draggableHelper = draggableHelper;\n\t            this.zone = zone;\n\t            this.renderer = renderer;\n\t            this.scrollContainer = scrollContainer;\n\t            /**\n\t             * Called when a draggable element starts overlapping the element\n\t             */\n\t            this.dragEnter = new i0.EventEmitter();\n\t            /**\n\t             * Called when a draggable element stops overlapping the element\n\t             */\n\t            this.dragLeave = new i0.EventEmitter();\n\t            /**\n\t             * Called when a draggable element is moved over the element\n\t             */\n\t            this.dragOver = new i0.EventEmitter();\n\t            /**\n\t             * Called when a draggable element is dropped on this element\n\t             */\n\t            this.drop = new i0.EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n\t        }\n\t        /**\n\t         * @return {?}\n\t         */\n\t        DroppableDirective.prototype.ngOnInit = /**\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                var _this = this;\n\t                this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(( /**\n\t                 * @param {?} drag$\n\t                 * @return {?}\n\t                 */function (drag$) {\n\t                    addClass(_this.renderer, _this.element, _this.dragActiveClass);\n\t                    /** @type {?} */\n\t                    var droppableElement = {\n\t                        updateCache: true,\n\t                    };\n\t                    /** @type {?} */\n\t                    var deregisterScrollListener = _this.renderer.listen(_this.scrollContainer\n\t                        ? _this.scrollContainer.elementRef.nativeElement\n\t                        : 'window', 'scroll', ( /**\n\t                 * @return {?}\n\t                 */function () {\n\t                        droppableElement.updateCache = true;\n\t                    }));\n\t                    /** @type {?} */\n\t                    var currentDragDropData;\n\t                    /** @type {?} */\n\t                    var overlaps$ = drag$.pipe(operators.map(( /**\n\t                     * @param {?} __0\n\t                     * @return {?}\n\t                     */function (_a) {\n\t                        var clientX = _a.clientX, clientY = _a.clientY, dropData = _a.dropData, target = _a.target;\n\t                        currentDragDropData = dropData;\n\t                        if (droppableElement.updateCache) {\n\t                            droppableElement.rect = _this.element.nativeElement.getBoundingClientRect();\n\t                            if (_this.scrollContainer) {\n\t                                droppableElement.scrollContainerRect = _this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n\t                            }\n\t                            droppableElement.updateCache = false;\n\t                        }\n\t                        /** @type {?} */\n\t                        var isWithinElement = isCoordinateWithinRectangle(clientX, clientY, ( /** @type {?} */(droppableElement.rect)));\n\t                        /** @type {?} */\n\t                        var isDropAllowed = !_this.validateDrop ||\n\t                            _this.validateDrop({ clientX: clientX, clientY: clientY, target: target });\n\t                        if (droppableElement.scrollContainerRect) {\n\t                            return (isWithinElement &&\n\t                                isDropAllowed &&\n\t                                isCoordinateWithinRectangle(clientX, clientY, ( /** @type {?} */(droppableElement.scrollContainerRect))));\n\t                        }\n\t                        else {\n\t                            return isWithinElement && isDropAllowed;\n\t                        }\n\t                    })));\n\t                    /** @type {?} */\n\t                    var overlapsChanged$ = overlaps$.pipe(operators.distinctUntilChanged());\n\t                    /** @type {?} */\n\t                    var dragOverActive;\n\t                    overlapsChanged$\n\t                        .pipe(operators.filter(( /**\n\t                 * @param {?} overlapsNow\n\t                 * @return {?}\n\t                 */function (overlapsNow) { return overlapsNow; })))\n\t                        .subscribe(( /**\n\t                 * @return {?}\n\t                 */function () {\n\t                        dragOverActive = true;\n\t                        addClass(_this.renderer, _this.element, _this.dragOverClass);\n\t                        _this.zone.run(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.dragEnter.next({\n\t                                dropData: currentDragDropData,\n\t                            });\n\t                        }));\n\t                    }));\n\t                    overlaps$.pipe(operators.filter(( /**\n\t                     * @param {?} overlapsNow\n\t                     * @return {?}\n\t                     */function (overlapsNow) { return overlapsNow; }))).subscribe(( /**\n\t                     * @return {?}\n\t                     */function () {\n\t                        _this.zone.run(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.dragOver.next({\n\t                                dropData: currentDragDropData,\n\t                            });\n\t                        }));\n\t                    }));\n\t                    overlapsChanged$\n\t                        .pipe(operators.pairwise(), operators.filter(( /**\n\t                 * @param {?} __0\n\t                 * @return {?}\n\t                 */function (_a) {\n\t                        var _b = __read(_a, 2), didOverlap = _b[0], overlapsNow = _b[1];\n\t                        return didOverlap && !overlapsNow;\n\t                    })))\n\t                        .subscribe(( /**\n\t                 * @return {?}\n\t                 */function () {\n\t                        dragOverActive = false;\n\t                        removeClass(_this.renderer, _this.element, _this.dragOverClass);\n\t                        _this.zone.run(( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            _this.dragLeave.next({\n\t                                dropData: currentDragDropData,\n\t                            });\n\t                        }));\n\t                    }));\n\t                    drag$.subscribe({\n\t                        complete: ( /**\n\t                         * @return {?}\n\t                         */function () {\n\t                            deregisterScrollListener();\n\t                            removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n\t                            if (dragOverActive) {\n\t                                removeClass(_this.renderer, _this.element, _this.dragOverClass);\n\t                                _this.zone.run(( /**\n\t                                 * @return {?}\n\t                                 */function () {\n\t                                    _this.drop.next({\n\t                                        dropData: currentDragDropData,\n\t                                    });\n\t                                }));\n\t                            }\n\t                        }),\n\t                    });\n\t                }));\n\t            };\n\t        /**\n\t         * @return {?}\n\t         */\n\t        DroppableDirective.prototype.ngOnDestroy = /**\n\t         * @return {?}\n\t         */\n\t            function () {\n\t                if (this.currentDragSubscription) {\n\t                    this.currentDragSubscription.unsubscribe();\n\t                }\n\t            };\n\t        DroppableDirective.decorators = [\n\t            { type: i0.Directive, args: [{\n\t                        selector: '[mwlDroppable]',\n\t                    },] }\n\t        ];\n\t        /** @nocollapse */\n\t        DroppableDirective.ctorParameters = function () {\n\t            return [\n\t                { type: i0.ElementRef },\n\t                { type: DraggableHelper },\n\t                { type: i0.NgZone },\n\t                { type: i0.Renderer2 },\n\t                { type: DraggableScrollContainerDirective, decorators: [{ type: i0.Optional }] }\n\t            ];\n\t        };\n\t        DroppableDirective.propDecorators = {\n\t            dragOverClass: [{ type: i0.Input }],\n\t            dragActiveClass: [{ type: i0.Input }],\n\t            validateDrop: [{ type: i0.Input }],\n\t            dragEnter: [{ type: i0.Output }],\n\t            dragLeave: [{ type: i0.Output }],\n\t            dragOver: [{ type: i0.Output }],\n\t            drop: [{ type: i0.Output }]\n\t        };\n\t        return DroppableDirective;\n\t    }());\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\t    var DragAndDropModule = /** @class */ (function () {\n\t        function DragAndDropModule() {\n\t        }\n\t        DragAndDropModule.decorators = [\n\t            { type: i0.NgModule, args: [{\n\t                        declarations: [\n\t                            DraggableDirective,\n\t                            DroppableDirective,\n\t                            DraggableScrollContainerDirective,\n\t                        ],\n\t                        exports: [\n\t                            DraggableDirective,\n\t                            DroppableDirective,\n\t                            DraggableScrollContainerDirective,\n\t                        ],\n\t                    },] }\n\t        ];\n\t        return DragAndDropModule;\n\t    }());\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\n\t    /**\n\t     * @fileoverview added by tsickle\n\t     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n\t     */\n\n\t    exports.DragAndDropModule = DragAndDropModule;\n\t    exports.c = DraggableHelper;\n\t    exports.d = DraggableScrollContainerDirective;\n\t    exports.b = DraggableDirective;\n\t    exports.a = DroppableDirective;\n\n\t    Object.defineProperty(exports, '__esModule', { value: true });\n\n\t})));\n\n\n\t});\n\n\tvar angularDraggableDroppable_umd$1 = unwrapExports(angularDraggableDroppable_umd);\n\n\treturn angularDraggableDroppable_umd$1;\n\n})));\n"]}