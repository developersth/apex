/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef, Output, EventEmitter, NgZone, Input, Renderer2, Optional, } from '@angular/core';
import { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';
import { DraggableHelper } from './draggable-helper.provider';
import { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';
import { addClass, removeClass } from './util';
/**
 * @param {?} clientX
 * @param {?} clientY
 * @param {?} rect
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
function isCoordinateWithinRectangle(clientX, clientY, rect) {
    return (clientX >= rect.left &&
        clientX <= rect.right &&
        clientY >= rect.top &&
        clientY <= rect.bottom);
}
/**
 * @record
 * @template T
 */
export function DropEvent() { }
if (false) {
    /** @type {?} */
    DropEvent.prototype.dropData;
}
/**
 * @record
 */
export function ValidateDropParams() { }
if (false) {
    /**
     * ClientX value of the mouse location where the drop occurred
     * @type {?}
     */
    ValidateDropParams.prototype.clientX;
    /**
     * ClientY value of the mouse location where the drop occurred
     * @type {?}
     */
    ValidateDropParams.prototype.clientY;
    /**
     * The target of the event where the drop occurred
     * @type {?}
     */
    ValidateDropParams.prototype.target;
}
var DroppableDirective = /** @class */ (function () {
    function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {
        this.element = element;
        this.draggableHelper = draggableHelper;
        this.zone = zone;
        this.renderer = renderer;
        this.scrollContainer = scrollContainer;
        /**
         * Called when a draggable element starts overlapping the element
         */
        this.dragEnter = new EventEmitter();
        /**
         * Called when a draggable element stops overlapping the element
         */
        this.dragLeave = new EventEmitter();
        /**
         * Called when a draggable element is moved over the element
         */
        this.dragOver = new EventEmitter();
        /**
         * Called when a draggable element is dropped on this element
         */
        this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event
    }
    /**
     * @return {?}
     */
    DroppableDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((/**
         * @param {?} drag$
         * @return {?}
         */
        function (drag$) {
            addClass(_this.renderer, _this.element, _this.dragActiveClass);
            /** @type {?} */
            var droppableElement = {
                updateCache: true,
            };
            /** @type {?} */
            var deregisterScrollListener = _this.renderer.listen(_this.scrollContainer
                ? _this.scrollContainer.elementRef.nativeElement
                : 'window', 'scroll', (/**
             * @return {?}
             */
            function () {
                droppableElement.updateCache = true;
            }));
            /** @type {?} */
            var currentDragDropData;
            /** @type {?} */
            var overlaps$ = drag$.pipe(map((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var clientX = _a.clientX, clientY = _a.clientY, dropData = _a.dropData, target = _a.target;
                currentDragDropData = dropData;
                if (droppableElement.updateCache) {
                    droppableElement.rect = _this.element.nativeElement.getBoundingClientRect();
                    if (_this.scrollContainer) {
                        droppableElement.scrollContainerRect = _this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();
                    }
                    droppableElement.updateCache = false;
                }
                /** @type {?} */
                var isWithinElement = isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.rect)));
                /** @type {?} */
                var isDropAllowed = !_this.validateDrop ||
                    _this.validateDrop({ clientX: clientX, clientY: clientY, target: target });
                if (droppableElement.scrollContainerRect) {
                    return (isWithinElement &&
                        isDropAllowed &&
                        isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.scrollContainerRect))));
                }
                else {
                    return isWithinElement && isDropAllowed;
                }
            })));
            /** @type {?} */
            var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());
            /** @type {?} */
            var dragOverActive;
            overlapsChanged$
                .pipe(filter((/**
             * @param {?} overlapsNow
             * @return {?}
             */
            function (overlapsNow) { return overlapsNow; })))
                .subscribe((/**
             * @return {?}
             */
            function () {
                dragOverActive = true;
                addClass(_this.renderer, _this.element, _this.dragOverClass);
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragEnter.next({
                        dropData: currentDragDropData,
                    });
                }));
            }));
            overlaps$.pipe(filter((/**
             * @param {?} overlapsNow
             * @return {?}
             */
            function (overlapsNow) { return overlapsNow; }))).subscribe((/**
             * @return {?}
             */
            function () {
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragOver.next({
                        dropData: currentDragDropData,
                    });
                }));
            }));
            overlapsChanged$
                .pipe(pairwise(), filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = tslib_1.__read(_a, 2), didOverlap = _b[0], overlapsNow = _b[1];
                return didOverlap && !overlapsNow;
            })))
                .subscribe((/**
             * @return {?}
             */
            function () {
                dragOverActive = false;
                removeClass(_this.renderer, _this.element, _this.dragOverClass);
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragLeave.next({
                        dropData: currentDragDropData,
                    });
                }));
            }));
            drag$.subscribe({
                complete: (/**
                 * @return {?}
                 */
                function () {
                    deregisterScrollListener();
                    removeClass(_this.renderer, _this.element, _this.dragActiveClass);
                    if (dragOverActive) {
                        removeClass(_this.renderer, _this.element, _this.dragOverClass);
                        _this.zone.run((/**
                         * @return {?}
                         */
                        function () {
                            _this.drop.next({
                                dropData: currentDragDropData,
                            });
                        }));
                    }
                }),
            });
        }));
    };
    /**
     * @return {?}
     */
    DroppableDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.currentDragSubscription) {
            this.currentDragSubscription.unsubscribe();
        }
    };
    /** @nocollapse */
    DroppableDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DraggableHelper },
        { type: NgZone },
        { type: Renderer2 },
        { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] }
    ]; };
    DroppableDirective.propDecorators = {
        dragOverClass: [{ type: Input }],
        dragActiveClass: [{ type: Input }],
        validateDrop: [{ type: Input }],
        dragEnter: [{ type: Output }],
        dragLeave: [{ type: Output }],
        dragOver: [{ type: Output }],
        drop: [{ type: Output }]
    };
DroppableDirective.ɵfac = function DroppableDirective_Factory(t) { return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8)); };
DroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DroppableDirective, selectors: [["", "mwlDroppable", ""]], inputs: { dragOverClass: "dragOverClass", dragActiveClass: "dragActiveClass", validateDrop: "validateDrop" }, outputs: { dragEnter: "dragEnter", dragLeave: "dragLeave", dragOver: "dragOver", drop: "drop" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlDroppable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DraggableHelper }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{
                type: Optional
            }] }]; }, { dragEnter: [{
            type: Output
        }], dragLeave: [{
            type: Output
        }], dragOver: [{
            type: Output
        }], drop: [{
            type: Output
        }], dragOverClass: [{
            type: Input
        }], dragActiveClass: [{
            type: Input
        }], validateDrop: [{
            type: Input
        }] }); })();
    return DroppableDirective;
}());
export { DroppableDirective };
if (false) {
    /**
     * Added to the element when an element is dragged over it
     * @type {?}
     */
    DroppableDirective.prototype.dragOverClass;
    /**
     * Added to the element any time a draggable element is being dragged
     * @type {?}
     */
    DroppableDirective.prototype.dragActiveClass;
    /**
     * Allow custom behaviour to control when the element is dropped
     * @type {?}
     */
    DroppableDirective.prototype.validateDrop;
    /**
     * Called when a draggable element starts overlapping the element
     * @type {?}
     */
    DroppableDirective.prototype.dragEnter;
    /**
     * Called when a draggable element stops overlapping the element
     * @type {?}
     */
    DroppableDirective.prototype.dragLeave;
    /**
     * Called when a draggable element is moved over the element
     * @type {?}
     */
    DroppableDirective.prototype.dragOver;
    /**
     * Called when a draggable element is dropped on this element
     * @type {?}
     */
    DroppableDirective.prototype.drop;
    /** @type {?} */
    DroppableDirective.prototype.currentDragSubscription;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.draggableHelper;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.scrollContainer;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvYW5ndWxhci1kcmFnZ2FibGUtZHJvcHBhYmxlL2VzbTUvbGliL2Ryb3BwYWJsZS5kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF3Tk0sQUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUJBIiwiZmlsZSI6ImRyb3BwYWJsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgSW5wdXQsIFJlbmRlcmVyMiwgT3B0aW9uYWwsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgcGFpcndpc2UsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlSGVscGVyIH0gZnJvbSAnLi9kcmFnZ2FibGUtaGVscGVyLnByb3ZpZGVyJztcbmltcG9ydCB7IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZ2dhYmxlLXNjcm9sbC1jb250YWluZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IGFkZENsYXNzLCByZW1vdmVDbGFzcyB9IGZyb20gJy4vdXRpbCc7XG4vKipcbiAqIEBwYXJhbSB7P30gY2xpZW50WFxuICogQHBhcmFtIHs/fSBjbGllbnRZXG4gKiBAcGFyYW0gez99IHJlY3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQ29vcmRpbmF0ZVdpdGhpblJlY3RhbmdsZShjbGllbnRYLCBjbGllbnRZLCByZWN0KSB7XG4gICAgcmV0dXJuIChjbGllbnRYID49IHJlY3QubGVmdCAmJlxuICAgICAgICBjbGllbnRYIDw9IHJlY3QucmlnaHQgJiZcbiAgICAgICAgY2xpZW50WSA+PSByZWN0LnRvcCAmJlxuICAgICAgICBjbGllbnRZIDw9IHJlY3QuYm90dG9tKTtcbn1cbi8qKlxuICogQHJlY29yZFxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIERyb3BFdmVudCgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERyb3BFdmVudC5wcm90b3R5cGUuZHJvcERhdGE7XG59XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZhbGlkYXRlRHJvcFBhcmFtcygpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50WCB2YWx1ZSBvZiB0aGUgbW91c2UgbG9jYXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJyZWRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBWYWxpZGF0ZURyb3BQYXJhbXMucHJvdG90eXBlLmNsaWVudFg7XG4gICAgLyoqXG4gICAgICogQ2xpZW50WSB2YWx1ZSBvZiB0aGUgbW91c2UgbG9jYXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJyZWRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBWYWxpZGF0ZURyb3BQYXJhbXMucHJvdG90eXBlLmNsaWVudFk7XG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgd2hlcmUgdGhlIGRyb3Agb2NjdXJyZWRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBWYWxpZGF0ZURyb3BQYXJhbXMucHJvdG90eXBlLnRhcmdldDtcbn1cbnZhciBEcm9wcGFibGVEaXJlY3RpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcHBhYmxlRGlyZWN0aXZlKGVsZW1lbnQsIGRyYWdnYWJsZUhlbHBlciwgem9uZSwgcmVuZGVyZXIsIHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmRyYWdnYWJsZUhlbHBlciA9IGRyYWdnYWJsZUhlbHBlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgc3RhcnRzIG92ZXJsYXBwaW5nIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgc3RvcHMgb3ZlcmxhcHBpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ0xlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBvdmVyIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdPdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSBkcmFnZ2FibGUgZWxlbWVudCBpcyBkcm9wcGVkIG9uIHRoaXMgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcm9wID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLW91dHB1dC1uYW1lZC1hZnRlci1zdGFuZGFyZC1ldmVudFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbiA9IHRoaXMuZHJhZ2dhYmxlSGVscGVyLmN1cnJlbnREcmFnLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZHJhZyRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChkcmFnJCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoX3RoaXMucmVuZGVyZXIsIF90aGlzLmVsZW1lbnQsIF90aGlzLmRyYWdBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgZHJvcHBhYmxlRWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgZGVyZWdpc3RlclNjcm9sbExpc3RlbmVyID0gX3RoaXMucmVuZGVyZXIubGlzdGVuKF90aGlzLnNjcm9sbENvbnRhaW5lclxuICAgICAgICAgICAgICAgID8gX3RoaXMuc2Nyb2xsQ29udGFpbmVyLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgIDogJ3dpbmRvdycsICdzY3JvbGwnLCAoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZHJvcHBhYmxlRWxlbWVudC51cGRhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgY3VycmVudERyYWdEcm9wRGF0YTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBvdmVybGFwcyQgPSBkcmFnJC5waXBlKG1hcCgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WSwgZHJvcERhdGEgPSBfYS5kcm9wRGF0YSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnREcmFnRHJvcERhdGEgPSBkcm9wRGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcHBhYmxlRWxlbWVudC51cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFbGVtZW50LnJlY3QgPSBfdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUVsZW1lbnQuc2Nyb2xsQ29udGFpbmVyUmVjdCA9IF90aGlzLnNjcm9sbENvbnRhaW5lci5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRWxlbWVudC51cGRhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGlzV2l0aGluRWxlbWVudCA9IGlzQ29vcmRpbmF0ZVdpdGhpblJlY3RhbmdsZShjbGllbnRYLCBjbGllbnRZLCAoLyoqIEB0eXBlIHs/fSAqLyAoZHJvcHBhYmxlRWxlbWVudC5yZWN0KSkpO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgaXNEcm9wQWxsb3dlZCA9ICFfdGhpcy52YWxpZGF0ZURyb3AgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsaWRhdGVEcm9wKHsgY2xpZW50WDogY2xpZW50WCwgY2xpZW50WTogY2xpZW50WSwgdGFyZ2V0OiB0YXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3BwYWJsZUVsZW1lbnQuc2Nyb2xsQ29udGFpbmVyUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzV2l0aGluRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wQWxsb3dlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb29yZGluYXRlV2l0aGluUmVjdGFuZ2xlKGNsaWVudFgsIGNsaWVudFksICgvKiogQHR5cGUgez99ICovIChkcm9wcGFibGVFbGVtZW50LnNjcm9sbENvbnRhaW5lclJlY3QpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2l0aGluRWxlbWVudCAmJiBpc0Ryb3BBbGxvd2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHNDaGFuZ2VkJCA9IG92ZXJsYXBzJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGRyYWdPdmVyQWN0aXZlO1xuICAgICAgICAgICAgb3ZlcmxhcHNDaGFuZ2VkJFxuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG92ZXJsYXBzTm93XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAob3ZlcmxhcHNOb3cpIHsgcmV0dXJuIG92ZXJsYXBzTm93OyB9KSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZHJhZ092ZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKF90aGlzLnJlbmRlcmVyLCBfdGhpcy5lbGVtZW50LCBfdGhpcy5kcmFnT3ZlckNsYXNzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bigoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyYWdFbnRlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BEYXRhOiBjdXJyZW50RHJhZ0Ryb3BEYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBvdmVybGFwcyQucGlwZShmaWx0ZXIoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBvdmVybGFwc05vd1xuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKG92ZXJsYXBzTm93KSB7IHJldHVybiBvdmVybGFwc05vdzsgfSkpKS5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJhZ092ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRGF0YTogY3VycmVudERyYWdEcm9wRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb3ZlcmxhcHNDaGFuZ2VkJFxuICAgICAgICAgICAgICAgIC5waXBlKHBhaXJ3aXNlKCksIGZpbHRlcigoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBkaWRPdmVybGFwID0gX2JbMF0sIG92ZXJsYXBzTm93ID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZE92ZXJsYXAgJiYgIW92ZXJsYXBzTm93O1xuICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRyYWdPdmVyQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3RoaXMucmVuZGVyZXIsIF90aGlzLmVsZW1lbnQsIF90aGlzLmRyYWdPdmVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xlYXZlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcERhdGE6IGN1cnJlbnREcmFnRHJvcERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGRyYWckLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6ICgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVyZWdpc3RlclNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF90aGlzLnJlbmRlcmVyLCBfdGhpcy5lbGVtZW50LCBfdGhpcy5kcmFnQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ092ZXJBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF90aGlzLnJlbmRlcmVyLCBfdGhpcy5lbGVtZW50LCBfdGhpcy5kcmFnT3ZlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKCgvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcm9wLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wRGF0YTogY3VycmVudERyYWdEcm9wRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRHJvcHBhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wcGFibGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW213bERyb3BwYWJsZV0nLFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IERyYWdnYWJsZUhlbHBlciB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgICAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgICAgICB7IHR5cGU6IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuICAgIF07IH07XG4gICAgRHJvcHBhYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBkcmFnT3ZlckNsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZHJhZ0FjdGl2ZUNsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgdmFsaWRhdGVEcm9wOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZHJhZ0VudGVyOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIGRyYWdMZWF2ZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBkcmFnT3ZlcjogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBkcm9wOiBbeyB0eXBlOiBPdXRwdXQgfV1cbiAgICB9O1xuICAgIHJldHVybiBEcm9wcGFibGVEaXJlY3RpdmU7XG59KCkpO1xuZXhwb3J0IHsgRHJvcHBhYmxlRGlyZWN0aXZlIH07XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBBZGRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGFuIGVsZW1lbnQgaXMgZHJhZ2dlZCBvdmVyIGl0XG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgRHJvcHBhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5kcmFnT3ZlckNsYXNzO1xuICAgIC8qKlxuICAgICAqIEFkZGVkIHRvIHRoZSBlbGVtZW50IGFueSB0aW1lIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuZHJhZ0FjdGl2ZUNsYXNzO1xuICAgIC8qKlxuICAgICAqIEFsbG93IGN1c3RvbSBiZWhhdmlvdXIgdG8gY29udHJvbCB3aGVuIHRoZSBlbGVtZW50IGlzIGRyb3BwZWRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLnZhbGlkYXRlRHJvcDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRyYWdnYWJsZSBlbGVtZW50IHN0YXJ0cyBvdmVybGFwcGluZyB0aGUgZWxlbWVudFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuZHJhZ0VudGVyO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgc3RvcHMgb3ZlcmxhcHBpbmcgdGhlIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRyYWdMZWF2ZTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRyYWdnYWJsZSBlbGVtZW50IGlzIG1vdmVkIG92ZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRyYWdPdmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgZHJvcHBlZCBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRyb3A7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuY3VycmVudERyYWdTdWJzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLmVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRyYWdnYWJsZUhlbHBlcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuem9uZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERyb3BwYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUucmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEcm9wcGFibGVEaXJlY3RpdmUucHJvdG90eXBlLnNjcm9sbENvbnRhaW5lcjtcbn1cbiJdfQ==