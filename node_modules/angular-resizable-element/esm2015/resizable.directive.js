/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Renderer2, ElementRef, Output, Input, EventEmitter, NgZone, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Subject, Observable, merge, EMPTY } from 'rxjs';
import { map, mergeMap, takeUntil, filter, pairwise, take, share, auditTime, switchMap, startWith, tap } from 'rxjs/operators';
import { IS_TOUCH_DEVICE } from './is-touch-device';
/**
 * @record
 */
import * as Éµngcc0 from '@angular/core';
function PointerEventCoordinate() { }
if (false) {
    /** @type {?} */
    PointerEventCoordinate.prototype.clientX;
    /** @type {?} */
    PointerEventCoordinate.prototype.clientY;
    /** @type {?} */
    PointerEventCoordinate.prototype.event;
}
/**
 * @record
 */
function Coordinate() { }
if (false) {
    /** @type {?} */
    Coordinate.prototype.x;
    /** @type {?} */
    Coordinate.prototype.y;
}
/**
 * @param {?} value1
 * @param {?} value2
 * @param {?=} precision
 * @return {?}
 */
function isNumberCloseTo(value1, value2, precision = 3) {
    /** @type {?} */
    const diff = Math.abs(value1 - value2);
    return diff < precision;
}
/**
 * @param {?} startingRect
 * @param {?} edges
 * @param {?} clientX
 * @param {?} clientY
 * @return {?}
 */
function getNewBoundingRectangle(startingRect, edges, clientX, clientY) {
    /** @type {?} */
    const newBoundingRect = {
        top: startingRect.top,
        bottom: startingRect.bottom,
        left: startingRect.left,
        right: startingRect.right
    };
    if (edges.top) {
        newBoundingRect.top += clientY;
    }
    if (edges.bottom) {
        newBoundingRect.bottom += clientY;
    }
    if (edges.left) {
        newBoundingRect.left += clientX;
    }
    if (edges.right) {
        newBoundingRect.right += clientX;
    }
    newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;
    newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;
    return newBoundingRect;
}
/**
 * @param {?} element
 * @param {?} ghostElementPositioning
 * @return {?}
 */
function getElementRect(element, ghostElementPositioning) {
    /** @type {?} */
    let translateX = 0;
    /** @type {?} */
    let translateY = 0;
    /** @type {?} */
    const style = element.nativeElement.style;
    /** @type {?} */
    const transformProperties = [
        'transform',
        '-ms-transform',
        '-moz-transform',
        '-o-transform'
    ];
    /** @type {?} */
    const transform = transformProperties
        .map(property => style[property])
        .find(value => !!value);
    if (transform && transform.includes('translate')) {
        translateX = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');
        translateY = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');
    }
    if (ghostElementPositioning === 'absolute') {
        return {
            height: element.nativeElement.offsetHeight,
            width: element.nativeElement.offsetWidth,
            top: element.nativeElement.offsetTop - translateY,
            bottom: element.nativeElement.offsetHeight +
                element.nativeElement.offsetTop -
                translateY,
            left: element.nativeElement.offsetLeft - translateX,
            right: element.nativeElement.offsetWidth +
                element.nativeElement.offsetLeft -
                translateX
        };
    }
    else {
        /** @type {?} */
        const boundingRect = element.nativeElement.getBoundingClientRect();
        return {
            height: boundingRect.height,
            width: boundingRect.width,
            top: boundingRect.top - translateY,
            bottom: boundingRect.bottom - translateY,
            left: boundingRect.left - translateX,
            right: boundingRect.right - translateX,
            scrollTop: element.nativeElement.scrollTop,
            scrollLeft: element.nativeElement.scrollLeft
        };
    }
}
/**
 * @param {?} __0
 * @return {?}
 */
function isWithinBoundingY({ clientY, rect }) {
    return clientY >= rect.top && clientY <= rect.bottom;
}
/**
 * @param {?} __0
 * @return {?}
 */
function isWithinBoundingX({ clientX, rect }) {
    return clientX >= rect.left && clientX <= rect.right;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getResizeEdges({ clientX, clientY, elm, allowedEdges, cursorPrecision }) {
    /** @type {?} */
    const elmPosition = elm.nativeElement.getBoundingClientRect();
    /** @type {?} */
    const edges = {};
    if (allowedEdges.left &&
        isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &&
        isWithinBoundingY({ clientY, rect: elmPosition })) {
        edges.left = true;
    }
    if (allowedEdges.right &&
        isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &&
        isWithinBoundingY({ clientY, rect: elmPosition })) {
        edges.right = true;
    }
    if (allowedEdges.top &&
        isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &&
        isWithinBoundingX({ clientX, rect: elmPosition })) {
        edges.top = true;
    }
    if (allowedEdges.bottom &&
        isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &&
        isWithinBoundingX({ clientX, rect: elmPosition })) {
        edges.bottom = true;
    }
    return edges;
}
/**
 * @record
 */
export function ResizeCursors() { }
if (false) {
    /** @type {?} */
    ResizeCursors.prototype.topLeft;
    /** @type {?} */
    ResizeCursors.prototype.topRight;
    /** @type {?} */
    ResizeCursors.prototype.bottomLeft;
    /** @type {?} */
    ResizeCursors.prototype.bottomRight;
    /** @type {?} */
    ResizeCursors.prototype.leftOrRight;
    /** @type {?} */
    ResizeCursors.prototype.topOrBottom;
}
/** @type {?} */
const DEFAULT_RESIZE_CURSORS = Object.freeze({
    topLeft: 'nw-resize',
    topRight: 'ne-resize',
    bottomLeft: 'sw-resize',
    bottomRight: 'se-resize',
    leftOrRight: 'col-resize',
    topOrBottom: 'row-resize'
});
/**
 * @param {?} edges
 * @param {?} cursors
 * @return {?}
 */
function getResizeCursor(edges, cursors) {
    if (edges.left && edges.top) {
        return cursors.topLeft;
    }
    else if (edges.right && edges.top) {
        return cursors.topRight;
    }
    else if (edges.left && edges.bottom) {
        return cursors.bottomLeft;
    }
    else if (edges.right && edges.bottom) {
        return cursors.bottomRight;
    }
    else if (edges.left || edges.right) {
        return cursors.leftOrRight;
    }
    else if (edges.top || edges.bottom) {
        return cursors.topOrBottom;
    }
    else {
        return '';
    }
}
/**
 * @param {?} __0
 * @return {?}
 */
function getEdgesDiff({ edges, initialRectangle, newRectangle }) {
    /** @type {?} */
    const edgesDiff = {};
    Object.keys(edges).forEach(edge => {
        edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);
    });
    return edgesDiff;
}
/** @type {?} */
const RESIZE_ACTIVE_CLASS = 'resize-active';
/** @type {?} */
const RESIZE_LEFT_HOVER_CLASS = 'resize-left-hover';
/** @type {?} */
const RESIZE_RIGHT_HOVER_CLASS = 'resize-right-hover';
/** @type {?} */
const RESIZE_TOP_HOVER_CLASS = 'resize-top-hover';
/** @type {?} */
const RESIZE_BOTTOM_HOVER_CLASS = 'resize-bottom-hover';
/** @type {?} */
const RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';
/** @type {?} */
export const MOUSE_MOVE_THROTTLE_MS = 50;
/**
 * Place this on an element to make it resizable. For example:
 *
 * ```html
 * <div
 *   mwlResizable
 *   [resizeEdges]="{bottom: true, right: true, top: true, left: true}"
 *   [enableGhostResize]="true">
 * </div>
 * ```
 * Or in case they are sibling elements:
 * ```html
 * <div mwlResizable #resizableElement="mwlResizable"></div>
 * <div mwlResizeHandle [resizableContainer]="resizableElement" [resizeEdges]="{bottom: true, right: true}"></div>
 * ```
 */
export class ResizableDirective {
    /**
     * @hidden
     * @param {?} platformId
     * @param {?} renderer
     * @param {?} elm
     * @param {?} zone
     */
    constructor(platformId, renderer, elm, zone) {
        this.platformId = platformId;
        this.renderer = renderer;
        this.elm = elm;
        this.zone = zone;
        /**
         * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
         * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
         */
        this.resizeEdges = {};
        /**
         * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
         */
        this.enableGhostResize = false;
        /**
         * A snap grid that resize events will be locked to.
         *
         * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
         */
        this.resizeSnapGrid = {};
        /**
         * The mouse cursors that will be set on the resize edges
         */
        this.resizeCursors = DEFAULT_RESIZE_CURSORS;
        /**
         * Mouse over thickness to active cursor.
         * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
         */
        this.resizeCursorPrecision = 3;
        /**
         * Define the positioning of the ghost element (can be fixed or absolute)
         */
        this.ghostElementPositioning = 'fixed';
        /**
         * Allow elements to be resized to negative dimensions
         */
        this.allowNegativeResizes = false;
        /**
         * The mouse move throttle in milliseconds, default: 50 ms
         */
        this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;
        /**
         * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
         */
        this.resizeStart = new EventEmitter();
        /**
         * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
         */
        this.resizing = new EventEmitter();
        /**
         * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
         */
        this.resizeEnd = new EventEmitter();
        /**
         * @hidden
         */
        this.mouseup = new Subject();
        /**
         * @hidden
         */
        this.mousedown = new Subject();
        /**
         * @hidden
         */
        this.mousemove = new Subject();
        this.destroy$ = new Subject();
        this.resizeEdges$ = new Subject();
        this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);
        /** @type {?} */
        const mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(({ event }) => {
            if (currentResize) {
                try {
                    event.preventDefault();
                }
                catch (e) {
                    // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere
                    // browser does nothing except of writing errors to console
                }
            }
        }), share());
        /** @type {?} */
        const mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);
        /** @type {?} */
        let currentResize;
        /** @type {?} */
        const removeGhostElement = () => {
            if (currentResize && currentResize.clonedNode) {
                this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);
                this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');
            }
        };
        /** @type {?} */
        const getResizeCursors = () => {
            return Object.assign({}, DEFAULT_RESIZE_CURSORS, this.resizeCursors);
        };
        this.resizeEdges$
            .pipe(startWith(this.resizeEdges), map(() => {
            return (this.resizeEdges &&
                Object.keys(this.resizeEdges).some(edge => !!this.resizeEdges[edge]));
        }), switchMap(legacyResizeEdgesEnabled => legacyResizeEdgesEnabled ? mousemove$ : EMPTY), auditTime(this.mouseMoveThrottleMS), takeUntil(this.destroy$))
            .subscribe(({ clientX, clientY }) => {
            /** @type {?} */
            const resizeEdges = getResizeEdges({
                clientX,
                clientY,
                elm: this.elm,
                allowedEdges: this.resizeEdges,
                cursorPrecision: this.resizeCursorPrecision
            });
            /** @type {?} */
            const resizeCursors = getResizeCursors();
            if (!currentResize) {
                /** @type {?} */
                const cursor = getResizeCursor(resizeEdges, resizeCursors);
                this.renderer.setStyle(this.elm.nativeElement, 'cursor', cursor);
            }
            this.setElementClass(this.elm, RESIZE_LEFT_HOVER_CLASS, resizeEdges.left === true);
            this.setElementClass(this.elm, RESIZE_RIGHT_HOVER_CLASS, resizeEdges.right === true);
            this.setElementClass(this.elm, RESIZE_TOP_HOVER_CLASS, resizeEdges.top === true);
            this.setElementClass(this.elm, RESIZE_BOTTOM_HOVER_CLASS, resizeEdges.bottom === true);
        });
        /** @type {?} */
        const mousedrag = mousedown$
            .pipe(mergeMap(startCoords => {
            /**
             * @param {?} moveCoords
             * @return {?}
             */
            function getDiff(moveCoords) {
                return {
                    clientX: moveCoords.clientX - startCoords.clientX,
                    clientY: moveCoords.clientY - startCoords.clientY
                };
            }
            /** @type {?} */
            const getSnapGrid = () => {
                /** @type {?} */
                const snapGrid = { x: 1, y: 1 };
                if (currentResize) {
                    if (this.resizeSnapGrid.left && currentResize.edges.left) {
                        snapGrid.x = +this.resizeSnapGrid.left;
                    }
                    else if (this.resizeSnapGrid.right &&
                        currentResize.edges.right) {
                        snapGrid.x = +this.resizeSnapGrid.right;
                    }
                    if (this.resizeSnapGrid.top && currentResize.edges.top) {
                        snapGrid.y = +this.resizeSnapGrid.top;
                    }
                    else if (this.resizeSnapGrid.bottom &&
                        currentResize.edges.bottom) {
                        snapGrid.y = +this.resizeSnapGrid.bottom;
                    }
                }
                return snapGrid;
            };
            /**
             * @param {?} coords
             * @param {?} snapGrid
             * @return {?}
             */
            function getGrid(coords, snapGrid) {
                return {
                    x: Math.ceil(coords.clientX / snapGrid.x),
                    y: Math.ceil(coords.clientY / snapGrid.y)
                };
            }
            return ((/** @type {?} */ (merge(mousemove$.pipe(take(1)).pipe(map(coords => [, coords])), mousemove$.pipe(pairwise())))))
                .pipe(map(([previousCoords, newCoords]) => {
                return [
                    previousCoords ? getDiff(previousCoords) : previousCoords,
                    getDiff(newCoords)
                ];
            }))
                .pipe(filter(([previousCoords, newCoords]) => {
                if (!previousCoords) {
                    return true;
                }
                /** @type {?} */
                const snapGrid = getSnapGrid();
                /** @type {?} */
                const previousGrid = getGrid(previousCoords, snapGrid);
                /** @type {?} */
                const newGrid = getGrid(newCoords, snapGrid);
                return (previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y);
            }))
                .pipe(map(([, newCoords]) => {
                /** @type {?} */
                const snapGrid = getSnapGrid();
                return {
                    clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,
                    clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y
                };
            }))
                .pipe(takeUntil(merge(mouseup$, mousedown$)));
        }))
            .pipe(filter(() => !!currentResize));
        mousedrag
            .pipe(map(({ clientX, clientY }) => {
            return getNewBoundingRectangle((/** @type {?} */ (currentResize)).startingRect, (/** @type {?} */ (currentResize)).edges, clientX, clientY);
        }))
            .pipe(filter((newBoundingRect) => {
            return (this.allowNegativeResizes ||
                !!(newBoundingRect.height &&
                    newBoundingRect.width &&
                    newBoundingRect.height > 0 &&
                    newBoundingRect.width > 0));
        }))
            .pipe(filter((newBoundingRect) => {
            return this.validateResize
                ? this.validateResize({
                    rectangle: newBoundingRect,
                    edges: getEdgesDiff({
                        edges: (/** @type {?} */ (currentResize)).edges,
                        initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                        newRectangle: newBoundingRect
                    })
                })
                : true;
        }), takeUntil(this.destroy$))
            .subscribe((newBoundingRect) => {
            if (currentResize && currentResize.clonedNode) {
                this.renderer.setStyle(currentResize.clonedNode, 'height', `${newBoundingRect.height}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'width', `${newBoundingRect.width}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'top', `${newBoundingRect.top}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'left', `${newBoundingRect.left}px`);
            }
            if (this.resizing.observers.length > 0) {
                this.zone.run(() => {
                    this.resizing.emit({
                        edges: getEdgesDiff({
                            edges: (/** @type {?} */ (currentResize)).edges,
                            initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                            newRectangle: newBoundingRect
                        }),
                        rectangle: newBoundingRect
                    });
                });
            }
            (/** @type {?} */ (currentResize)).currentRect = newBoundingRect;
        });
        mousedown$
            .pipe(map(({ clientX, clientY, edges }) => {
            return (edges ||
                getResizeEdges({
                    clientX,
                    clientY,
                    elm: this.elm,
                    allowedEdges: this.resizeEdges,
                    cursorPrecision: this.resizeCursorPrecision
                }));
        }))
            .pipe(filter((edges) => {
            return Object.keys(edges).length > 0;
        }), takeUntil(this.destroy$))
            .subscribe((edges) => {
            if (currentResize) {
                removeGhostElement();
            }
            /** @type {?} */
            const startingRect = getElementRect(this.elm, this.ghostElementPositioning);
            currentResize = {
                edges,
                startingRect,
                currentRect: startingRect
            };
            /** @type {?} */
            const resizeCursors = getResizeCursors();
            /** @type {?} */
            const cursor = getResizeCursor(currentResize.edges, resizeCursors);
            this.renderer.setStyle(document.body, 'cursor', cursor);
            this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);
            if (this.enableGhostResize) {
                currentResize.clonedNode = this.elm.nativeElement.cloneNode(true);
                this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);
                this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'hidden');
                this.renderer.setStyle(currentResize.clonedNode, 'position', this.ghostElementPositioning);
                this.renderer.setStyle(currentResize.clonedNode, 'left', `${currentResize.startingRect.left}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'top', `${currentResize.startingRect.top}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'height', `${currentResize.startingRect.height}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'width', `${currentResize.startingRect.width}px`);
                this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));
                this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);
                (/** @type {?} */ (currentResize.clonedNode)).scrollTop = (/** @type {?} */ (currentResize.startingRect
                    .scrollTop));
                (/** @type {?} */ (currentResize.clonedNode)).scrollLeft = (/** @type {?} */ (currentResize.startingRect
                    .scrollLeft));
            }
            if (this.resizeStart.observers.length > 0) {
                this.zone.run(() => {
                    this.resizeStart.emit({
                        edges: getEdgesDiff({
                            edges,
                            initialRectangle: startingRect,
                            newRectangle: startingRect
                        }),
                        rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)
                    });
                });
            }
        });
        mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (currentResize) {
                this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);
                this.renderer.setStyle(document.body, 'cursor', '');
                this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');
                if (this.resizeEnd.observers.length > 0) {
                    this.zone.run(() => {
                        this.resizeEnd.emit({
                            edges: getEdgesDiff({
                                edges: (/** @type {?} */ (currentResize)).edges,
                                initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                                newRectangle: (/** @type {?} */ (currentResize)).currentRect
                            }),
                            rectangle: (/** @type {?} */ (currentResize)).currentRect
                        });
                    });
                }
                removeGhostElement();
                currentResize = null;
            }
        });
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.resizeEdges) {
            this.resizeEdges$.next(this.resizeEdges);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        // browser check for angular universal, because it doesn't know what document is
        if (isPlatformBrowser(this.platformId)) {
            this.renderer.setStyle(document.body, 'cursor', '');
        }
        this.mousedown.complete();
        this.mouseup.complete();
        this.mousemove.complete();
        this.resizeEdges$.complete();
        this.destroy$.next();
    }
    /**
     * @private
     * @param {?} elm
     * @param {?} name
     * @param {?} add
     * @return {?}
     */
    setElementClass(elm, name, add) {
        if (add) {
            this.renderer.addClass(elm.nativeElement, name);
        }
        else {
            this.renderer.removeClass(elm.nativeElement, name);
        }
    }
}
ResizableDirective.Éµfac = function ResizableDirective_Factory(t) { return new (t || ResizableDirective)(Éµngcc0.ÉµÉµdirectiveInject(PLATFORM_ID), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.Renderer2), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone)); };
ResizableDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({ type: ResizableDirective, selectors: [["", "mwlResizable", ""]], inputs: { resizeEdges: "resizeEdges", enableGhostResize: "enableGhostResize", resizeSnapGrid: "resizeSnapGrid", resizeCursors: "resizeCursors", resizeCursorPrecision: "resizeCursorPrecision", ghostElementPositioning: "ghostElementPositioning", allowNegativeResizes: "allowNegativeResizes", mouseMoveThrottleMS: "mouseMoveThrottleMS", validateResize: "validateResize" }, outputs: { resizeStart: "resizeStart", resizing: "resizing", resizeEnd: "resizeEnd" }, exportAs: ["mwlResizable"], features: [Éµngcc0.ÉµÉµNgOnChangesFeature()] });
/** @nocollapse */
ResizableDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone }
];
ResizableDirective.propDecorators = {
    validateResize: [{ type: Input }],
    resizeEdges: [{ type: Input }],
    enableGhostResize: [{ type: Input }],
    resizeSnapGrid: [{ type: Input }],
    resizeCursors: [{ type: Input }],
    resizeCursorPrecision: [{ type: Input }],
    ghostElementPositioning: [{ type: Input }],
    allowNegativeResizes: [{ type: Input }],
    mouseMoveThrottleMS: [{ type: Input }],
    resizeStart: [{ type: Output }],
    resizing: [{ type: Output }],
    resizeEnd: [{ type: Output }]
};
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(ResizableDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlResizable]',
                exportAs: 'mwlResizable'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: Éµngcc0.Renderer2 }, { type: Éµngcc0.ElementRef }, { type: Éµngcc0.NgZone }]; }, { resizeEdges: [{
            type: Input
        }], enableGhostResize: [{
            type: Input
        }], resizeSnapGrid: [{
            type: Input
        }], resizeCursors: [{
            type: Input
        }], resizeCursorPrecision: [{
            type: Input
        }], ghostElementPositioning: [{
            type: Input
        }], allowNegativeResizes: [{
            type: Input
        }], mouseMoveThrottleMS: [{
            type: Input
        }], resizeStart: [{
            type: Output
        }], resizing: [{
            type: Output
        }], resizeEnd: [{
            type: Output
        }], validateResize: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * A function that will be called before each resize event. Return `true` to allow the resize event to propagate or `false` to cancel it
     * @type {?}
     */
    ResizableDirective.prototype.validateResize;
    /**
     * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
     * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
     * @type {?}
     */
    ResizableDirective.prototype.resizeEdges;
    /**
     * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
     * @type {?}
     */
    ResizableDirective.prototype.enableGhostResize;
    /**
     * A snap grid that resize events will be locked to.
     *
     * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
     * @type {?}
     */
    ResizableDirective.prototype.resizeSnapGrid;
    /**
     * The mouse cursors that will be set on the resize edges
     * @type {?}
     */
    ResizableDirective.prototype.resizeCursors;
    /**
     * Mouse over thickness to active cursor.
     * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
     * @type {?}
     */
    ResizableDirective.prototype.resizeCursorPrecision;
    /**
     * Define the positioning of the ghost element (can be fixed or absolute)
     * @type {?}
     */
    ResizableDirective.prototype.ghostElementPositioning;
    /**
     * Allow elements to be resized to negative dimensions
     * @type {?}
     */
    ResizableDirective.prototype.allowNegativeResizes;
    /**
     * The mouse move throttle in milliseconds, default: 50 ms
     * @type {?}
     */
    ResizableDirective.prototype.mouseMoveThrottleMS;
    /**
     * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizeStart;
    /**
     * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizing;
    /**
     * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizeEnd;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mouseup;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mousedown;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mousemove;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.pointerEventListeners;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.resizeEdges$;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.renderer;
    /** @type {?} */
    ResizableDirective.prototype.elm;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.zone;
}
class PointerEventListeners {
    // tslint:disable-line
    /**
     * @param {?} renderer
     * @param {?} zone
     * @return {?}
     */
    static getInstance(renderer, zone) {
        if (!PointerEventListeners.instance) {
            PointerEventListeners.instance = new PointerEventListeners(renderer, zone);
        }
        return PointerEventListeners.instance;
    }
    /**
     * @param {?} renderer
     * @param {?} zone
     */
    constructor(renderer, zone) {
        this.pointerDown = new Observable((observer) => {
            /** @type {?} */
            let unsubscribeMouseDown;
            /** @type {?} */
            let unsubscribeTouchStart;
            zone.runOutsideAngular(() => {
                unsubscribeMouseDown = renderer.listen('document', 'mousedown', (event) => {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchStart = renderer.listen('document', 'touchstart', (event) => {
                        observer.next({
                            clientX: event.touches[0].clientX,
                            clientY: event.touches[0].clientY,
                            event
                        });
                    });
                }
            });
            return () => {
                unsubscribeMouseDown();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchStart))();
                }
            };
        }).pipe(share());
        this.pointerMove = new Observable((observer) => {
            /** @type {?} */
            let unsubscribeMouseMove;
            /** @type {?} */
            let unsubscribeTouchMove;
            zone.runOutsideAngular(() => {
                unsubscribeMouseMove = renderer.listen('document', 'mousemove', (event) => {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchMove = renderer.listen('document', 'touchmove', (event) => {
                        observer.next({
                            clientX: event.targetTouches[0].clientX,
                            clientY: event.targetTouches[0].clientY,
                            event
                        });
                    });
                }
            });
            return () => {
                unsubscribeMouseMove();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchMove))();
                }
            };
        }).pipe(share());
        this.pointerUp = new Observable((observer) => {
            /** @type {?} */
            let unsubscribeMouseUp;
            /** @type {?} */
            let unsubscribeTouchEnd;
            /** @type {?} */
            let unsubscribeTouchCancel;
            zone.runOutsideAngular(() => {
                unsubscribeMouseUp = renderer.listen('document', 'mouseup', (event) => {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchEnd = renderer.listen('document', 'touchend', (event) => {
                        observer.next({
                            clientX: event.changedTouches[0].clientX,
                            clientY: event.changedTouches[0].clientY,
                            event
                        });
                    });
                    unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', (event) => {
                        observer.next({
                            clientX: event.changedTouches[0].clientX,
                            clientY: event.changedTouches[0].clientY,
                            event
                        });
                    });
                }
            });
            return () => {
                unsubscribeMouseUp();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchEnd))();
                    (/** @type {?} */ (unsubscribeTouchCancel))();
                }
            };
        }).pipe(share());
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    PointerEventListeners.instance;
    /** @type {?} */
    PointerEventListeners.prototype.pointerDown;
    /** @type {?} */
    PointerEventListeners.prototype.pointerMove;
    /** @type {?} */
    PointerEventListeners.prototype.pointerUp;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvYW5ndWxhci1yZXNpemFibGUtZWxlbWVudC9lc20yMDE1L3Jlc2l6YWJsZS5kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThuQkMsdW9CQU1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXFCQSIsImZpbGUiOiJyZXNpemFibGUuZGlyZWN0aXZlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIE91dHB1dCwgSW5wdXQsIEV2ZW50RW1pdHRlciwgTmdab25lLCBJbmplY3QsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJqZWN0LCBPYnNlcnZhYmxlLCBtZXJnZSwgRU1QVFkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIHRha2VVbnRpbCwgZmlsdGVyLCBwYWlyd2lzZSwgdGFrZSwgc2hhcmUsIGF1ZGl0VGltZSwgc3dpdGNoTWFwLCBzdGFydFdpdGgsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElTX1RPVUNIX0RFVklDRSB9IGZyb20gJy4vaXMtdG91Y2gtZGV2aWNlJztcbi8qKlxuICogQHJlY29yZFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRDb29yZGluYXRlKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuY2xpZW50WDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuY2xpZW50WTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuZXZlbnQ7XG59XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZnVuY3Rpb24gQ29vcmRpbmF0ZSgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENvb3JkaW5hdGUucHJvdG90eXBlLng7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENvb3JkaW5hdGUucHJvdG90eXBlLnk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWUxXG4gKiBAcGFyYW0gez99IHZhbHVlMlxuICogQHBhcmFtIHs/PX0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc051bWJlckNsb3NlVG8odmFsdWUxLCB2YWx1ZTIsIHByZWNpc2lvbiA9IDMpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHZhbHVlMSAtIHZhbHVlMik7XG4gICAgcmV0dXJuIGRpZmYgPCBwcmVjaXNpb247XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RhcnRpbmdSZWN0XG4gKiBAcGFyYW0gez99IGVkZ2VzXG4gKiBAcGFyYW0gez99IGNsaWVudFhcbiAqIEBwYXJhbSB7P30gY2xpZW50WVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TmV3Qm91bmRpbmdSZWN0YW5nbGUoc3RhcnRpbmdSZWN0LCBlZGdlcywgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBjb25zdCBuZXdCb3VuZGluZ1JlY3QgPSB7XG4gICAgICAgIHRvcDogc3RhcnRpbmdSZWN0LnRvcCxcbiAgICAgICAgYm90dG9tOiBzdGFydGluZ1JlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0OiBzdGFydGluZ1JlY3QubGVmdCxcbiAgICAgICAgcmlnaHQ6IHN0YXJ0aW5nUmVjdC5yaWdodFxuICAgIH07XG4gICAgaWYgKGVkZ2VzLnRvcCkge1xuICAgICAgICBuZXdCb3VuZGluZ1JlY3QudG9wICs9IGNsaWVudFk7XG4gICAgfVxuICAgIGlmIChlZGdlcy5ib3R0b20pIHtcbiAgICAgICAgbmV3Qm91bmRpbmdSZWN0LmJvdHRvbSArPSBjbGllbnRZO1xuICAgIH1cbiAgICBpZiAoZWRnZXMubGVmdCkge1xuICAgICAgICBuZXdCb3VuZGluZ1JlY3QubGVmdCArPSBjbGllbnRYO1xuICAgIH1cbiAgICBpZiAoZWRnZXMucmlnaHQpIHtcbiAgICAgICAgbmV3Qm91bmRpbmdSZWN0LnJpZ2h0ICs9IGNsaWVudFg7XG4gICAgfVxuICAgIG5ld0JvdW5kaW5nUmVjdC5oZWlnaHQgPSBuZXdCb3VuZGluZ1JlY3QuYm90dG9tIC0gbmV3Qm91bmRpbmdSZWN0LnRvcDtcbiAgICBuZXdCb3VuZGluZ1JlY3Qud2lkdGggPSBuZXdCb3VuZGluZ1JlY3QucmlnaHQgLSBuZXdCb3VuZGluZ1JlY3QubGVmdDtcbiAgICByZXR1cm4gbmV3Qm91bmRpbmdSZWN0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gZ2hvc3RFbGVtZW50UG9zaXRpb25pbmdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRSZWN0KGVsZW1lbnQsIGdob3N0RWxlbWVudFBvc2l0aW9uaW5nKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGxldCB0cmFuc2xhdGVYID0gMDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgbGV0IHRyYW5zbGF0ZVkgPSAwO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydGllcyA9IFtcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICctbXMtdHJhbnNmb3JtJyxcbiAgICAgICAgJy1tb3otdHJhbnNmb3JtJyxcbiAgICAgICAgJy1vLXRyYW5zZm9ybSdcbiAgICBdO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1Qcm9wZXJ0aWVzXG4gICAgICAgIC5tYXAocHJvcGVydHkgPT4gc3R5bGVbcHJvcGVydHldKVxuICAgICAgICAuZmluZCh2YWx1ZSA9PiAhIXZhbHVlKTtcbiAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybS5pbmNsdWRlcygndHJhbnNsYXRlJykpIHtcbiAgICAgICAgdHJhbnNsYXRlWCA9IHRyYW5zZm9ybS5yZXBsYWNlKC8uKnRyYW5zbGF0ZTM/ZD9cXCgoLT9bMC05XSopcHgsICgtP1swLTldKilweC4qLywgJyQxJyk7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2Zvcm0ucmVwbGFjZSgvLip0cmFuc2xhdGUzP2Q/XFwoKC0/WzAtOV0qKXB4LCAoLT9bMC05XSopcHguKi8sICckMicpO1xuICAgIH1cbiAgICBpZiAoZ2hvc3RFbGVtZW50UG9zaXRpb25pbmcgPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICB0b3A6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRUb3AgLSB0cmFuc2xhdGVZLFxuICAgICAgICAgICAgYm90dG9tOiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0ICtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0VG9wIC1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZLFxuICAgICAgICAgICAgbGVmdDogZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgLSB0cmFuc2xhdGVYLFxuICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCArXG4gICAgICAgICAgICAgICAgZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgLVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCAtIHRyYW5zbGF0ZVksXG4gICAgICAgICAgICBib3R0b206IGJvdW5kaW5nUmVjdC5ib3R0b20gLSB0cmFuc2xhdGVZLFxuICAgICAgICAgICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgLSB0cmFuc2xhdGVYLFxuICAgICAgICAgICAgcmlnaHQ6IGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyYW5zbGF0ZVgsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBfXzBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzV2l0aGluQm91bmRpbmdZKHsgY2xpZW50WSwgcmVjdCB9KSB7XG4gICAgcmV0dXJuIGNsaWVudFkgPj0gcmVjdC50b3AgJiYgY2xpZW50WSA8PSByZWN0LmJvdHRvbTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBfXzBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzV2l0aGluQm91bmRpbmdYKHsgY2xpZW50WCwgcmVjdCB9KSB7XG4gICAgcmV0dXJuIGNsaWVudFggPj0gcmVjdC5sZWZ0ICYmIGNsaWVudFggPD0gcmVjdC5yaWdodDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBfXzBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZUVkZ2VzKHsgY2xpZW50WCwgY2xpZW50WSwgZWxtLCBhbGxvd2VkRWRnZXMsIGN1cnNvclByZWNpc2lvbiB9KSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGNvbnN0IGVsbVBvc2l0aW9uID0gZWxtLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGNvbnN0IGVkZ2VzID0ge307XG4gICAgaWYgKGFsbG93ZWRFZGdlcy5sZWZ0ICYmXG4gICAgICAgIGlzTnVtYmVyQ2xvc2VUbyhjbGllbnRYLCBlbG1Qb3NpdGlvbi5sZWZ0LCBjdXJzb3JQcmVjaXNpb24pICYmXG4gICAgICAgIGlzV2l0aGluQm91bmRpbmdZKHsgY2xpZW50WSwgcmVjdDogZWxtUG9zaXRpb24gfSkpIHtcbiAgICAgICAgZWRnZXMubGVmdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChhbGxvd2VkRWRnZXMucmlnaHQgJiZcbiAgICAgICAgaXNOdW1iZXJDbG9zZVRvKGNsaWVudFgsIGVsbVBvc2l0aW9uLnJpZ2h0LCBjdXJzb3JQcmVjaXNpb24pICYmXG4gICAgICAgIGlzV2l0aGluQm91bmRpbmdZKHsgY2xpZW50WSwgcmVjdDogZWxtUG9zaXRpb24gfSkpIHtcbiAgICAgICAgZWRnZXMucmlnaHQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dlZEVkZ2VzLnRvcCAmJlxuICAgICAgICBpc051bWJlckNsb3NlVG8oY2xpZW50WSwgZWxtUG9zaXRpb24udG9wLCBjdXJzb3JQcmVjaXNpb24pICYmXG4gICAgICAgIGlzV2l0aGluQm91bmRpbmdYKHsgY2xpZW50WCwgcmVjdDogZWxtUG9zaXRpb24gfSkpIHtcbiAgICAgICAgZWRnZXMudG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRFZGdlcy5ib3R0b20gJiZcbiAgICAgICAgaXNOdW1iZXJDbG9zZVRvKGNsaWVudFksIGVsbVBvc2l0aW9uLmJvdHRvbSwgY3Vyc29yUHJlY2lzaW9uKSAmJlxuICAgICAgICBpc1dpdGhpbkJvdW5kaW5nWCh7IGNsaWVudFgsIHJlY3Q6IGVsbVBvc2l0aW9uIH0pKSB7XG4gICAgICAgIGVkZ2VzLmJvdHRvbSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlcztcbn1cbi8qKlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gUmVzaXplQ3Vyc29ycygpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIFJlc2l6ZUN1cnNvcnMucHJvdG90eXBlLnRvcExlZnQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIFJlc2l6ZUN1cnNvcnMucHJvdG90eXBlLnRvcFJpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemVDdXJzb3JzLnByb3RvdHlwZS5ib3R0b21MZWZ0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemVDdXJzb3JzLnByb3RvdHlwZS5ib3R0b21SaWdodDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUmVzaXplQ3Vyc29ycy5wcm90b3R5cGUubGVmdE9yUmlnaHQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIFJlc2l6ZUN1cnNvcnMucHJvdG90eXBlLnRvcE9yQm90dG9tO1xufVxuLyoqIEB0eXBlIHs/fSAqL1xuY29uc3QgREVGQVVMVF9SRVNJWkVfQ1VSU09SUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRvcExlZnQ6ICdudy1yZXNpemUnLFxuICAgIHRvcFJpZ2h0OiAnbmUtcmVzaXplJyxcbiAgICBib3R0b21MZWZ0OiAnc3ctcmVzaXplJyxcbiAgICBib3R0b21SaWdodDogJ3NlLXJlc2l6ZScsXG4gICAgbGVmdE9yUmlnaHQ6ICdjb2wtcmVzaXplJyxcbiAgICB0b3BPckJvdHRvbTogJ3Jvdy1yZXNpemUnXG59KTtcbi8qKlxuICogQHBhcmFtIHs/fSBlZGdlc1xuICogQHBhcmFtIHs/fSBjdXJzb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRSZXNpemVDdXJzb3IoZWRnZXMsIGN1cnNvcnMpIHtcbiAgICBpZiAoZWRnZXMubGVmdCAmJiBlZGdlcy50b3ApIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcnMudG9wTGVmdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWRnZXMucmlnaHQgJiYgZWRnZXMudG9wKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3JzLnRvcFJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlZGdlcy5sZWZ0ICYmIGVkZ2VzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gY3Vyc29ycy5ib3R0b21MZWZ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlZGdlcy5yaWdodCAmJiBlZGdlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcnMuYm90dG9tUmlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVkZ2VzLmxlZnQgfHwgZWRnZXMucmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcnMubGVmdE9yUmlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVkZ2VzLnRvcCB8fCBlZGdlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcnMudG9wT3JCb3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0RWRnZXNEaWZmKHsgZWRnZXMsIGluaXRpYWxSZWN0YW5nbGUsIG5ld1JlY3RhbmdsZSB9KSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGNvbnN0IGVkZ2VzRGlmZiA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGVkZ2VzKS5mb3JFYWNoKGVkZ2UgPT4ge1xuICAgICAgICBlZGdlc0RpZmZbZWRnZV0gPSAobmV3UmVjdGFuZ2xlW2VkZ2VdIHx8IDApIC0gKGluaXRpYWxSZWN0YW5nbGVbZWRnZV0gfHwgMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkZ2VzRGlmZjtcbn1cbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IFJFU0laRV9BQ1RJVkVfQ0xBU1MgPSAncmVzaXplLWFjdGl2ZSc7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBSRVNJWkVfTEVGVF9IT1ZFUl9DTEFTUyA9ICdyZXNpemUtbGVmdC1ob3Zlcic7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBSRVNJWkVfUklHSFRfSE9WRVJfQ0xBU1MgPSAncmVzaXplLXJpZ2h0LWhvdmVyJztcbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IFJFU0laRV9UT1BfSE9WRVJfQ0xBU1MgPSAncmVzaXplLXRvcC1ob3Zlcic7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBSRVNJWkVfQk9UVE9NX0hPVkVSX0NMQVNTID0gJ3Jlc2l6ZS1ib3R0b20taG92ZXInO1xuLyoqIEB0eXBlIHs/fSAqL1xuY29uc3QgUkVTSVpFX0dIT1NUX0VMRU1FTlRfQ0xBU1MgPSAncmVzaXplLWdob3N0LWVsZW1lbnQnO1xuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IE1PVVNFX01PVkVfVEhST1RUTEVfTVMgPSA1MDtcbi8qKlxuICogUGxhY2UgdGhpcyBvbiBhbiBlbGVtZW50IHRvIG1ha2UgaXQgcmVzaXphYmxlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2XG4gKiAgIG13bFJlc2l6YWJsZVxuICogICBbcmVzaXplRWRnZXNdPVwie2JvdHRvbTogdHJ1ZSwgcmlnaHQ6IHRydWUsIHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZX1cIlxuICogICBbZW5hYmxlR2hvc3RSZXNpemVdPVwidHJ1ZVwiPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqIE9yIGluIGNhc2UgdGhleSBhcmUgc2libGluZyBlbGVtZW50czpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbXdsUmVzaXphYmxlICNyZXNpemFibGVFbGVtZW50PVwibXdsUmVzaXphYmxlXCI+PC9kaXY+XG4gKiA8ZGl2IG13bFJlc2l6ZUhhbmRsZSBbcmVzaXphYmxlQ29udGFpbmVyXT1cInJlc2l6YWJsZUVsZW1lbnRcIiBbcmVzaXplRWRnZXNdPVwie2JvdHRvbTogdHJ1ZSwgcmlnaHQ6IHRydWV9XCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6YWJsZURpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1JZFxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IGVsbVxuICAgICAqIEBwYXJhbSB7P30gem9uZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtSWQsIHJlbmRlcmVyLCBlbG0sIHpvbmUpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlZGdlcyB0aGF0IGFuIGVsZW1lbnQgY2FuIGJlIHJlc2l6ZWQgZnJvbS4gUGFzcyBhbiBvYmplY3QgbGlrZSBge3RvcDogdHJ1ZSwgYm90dG9tOiBmYWxzZX1gLiBCeSBkZWZhdWx0IG5vIGVkZ2VzIGNhbiBiZSByZXNpemVkLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYSByZXNpemUgaGFuZGxlIGluc3RlYWQgdGhhdCBwb3NpdGlvbnMgaXRzZWxmIHRvIHRoZSBzaWRlIG9mIHRoZSBlbGVtZW50IHlvdSB3b3VsZCBsaWtlIHRvIHJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemVFZGdlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgYSB0ZW1wb3JhcnkgcmVzaXppbmcgZWZmZWN0IG9mIHRoZSBlbGVtZW50IGluIGJldHdlZW4gdGhlIGByZXNpemVTdGFydGAgYW5kIGByZXNpemVFbmRgIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5hYmxlR2hvc3RSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc25hcCBncmlkIHRoYXQgcmVzaXplIGV2ZW50cyB3aWxsIGJlIGxvY2tlZCB0by5cbiAgICAgICAgICpcbiAgICAgICAgICogZS5nLiB0byBvbmx5IGFsbG93IHRoZSBlbGVtZW50IHRvIGJlIHJlc2l6ZWQgZXZlcnkgMTBweCBzZXQgaXQgdG8gYHtsZWZ0OiAxMCwgcmlnaHQ6IDEwfWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplU25hcEdyaWQgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3VzZSBjdXJzb3JzIHRoYXQgd2lsbCBiZSBzZXQgb24gdGhlIHJlc2l6ZSBlZGdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemVDdXJzb3JzID0gREVGQVVMVF9SRVNJWkVfQ1VSU09SUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG92ZXIgdGhpY2tuZXNzIHRvIGFjdGl2ZSBjdXJzb3IuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGludmFsaWQgd2hlbiB5b3UgbWlncmF0ZSB0byB1c2UgcmVzaXplIGhhbmRsZXMgaW5zdGVhZCBvZiBzZXR0aW5nIHJlc2l6ZUVkZ2VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZUN1cnNvclByZWNpc2lvbiA9IDM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBnaG9zdCBlbGVtZW50IChjYW4gYmUgZml4ZWQgb3IgYWJzb2x1dGUpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudFBvc2l0aW9uaW5nID0gJ2ZpeGVkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93IGVsZW1lbnRzIHRvIGJlIHJlc2l6ZWQgdG8gbmVnYXRpdmUgZGltZW5zaW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd05lZ2F0aXZlUmVzaXplcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdXNlIG1vdmUgdGhyb3R0bGUgaW4gbWlsbGlzZWNvbmRzLCBkZWZhdWx0OiA1MCBtc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaHJvdHRsZU1TID0gTU9VU0VfTU9WRV9USFJPVFRMRV9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb3VzZSBpcyBwcmVzc2VkIGFuZCBhIHJlc2l6ZSBldmVudCBpcyBhYm91dCB0byBiZWdpbi4gYCRldmVudGAgaXMgYSBgUmVzaXplRXZlbnRgIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYXMgdGhlIG1vdXNlIGlzIGRyYWdnZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQgaGFzIGJlZ3VuLiBgJGV2ZW50YCBpcyBhIGBSZXNpemVFdmVudGAgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhZnRlciB0aGUgbW91c2UgaXMgcmVsZWFzZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQuIGAkZXZlbnRgIGlzIGEgYFJlc2l6ZUV2ZW50YCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2V1cCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlbW92ZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZUVkZ2VzJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzID0gUG9pbnRlckV2ZW50TGlzdGVuZXJzLmdldEluc3RhbmNlKHJlbmRlcmVyLCB6b25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbW91c2Vkb3duJCA9IG1lcmdlKHRoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzLnBvaW50ZXJEb3duLCB0aGlzLm1vdXNlZG93bik7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbW91c2Vtb3ZlJCA9IG1lcmdlKHRoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzLnBvaW50ZXJNb3ZlLCB0aGlzLm1vdXNlbW92ZSkucGlwZSh0YXAoKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNpemUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFkZGluZyB0cnktY2F0Y2ggbm90IHRvIHNlZSBlcnJvcnMgaW4gY29uc29sZSBpZiB0aGVyZSBpcyBhIHBhc3NpdmUgbGlzdGVuZXIgZm9yIHNhbWUgZXZlbnQgc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgZG9lcyBub3RoaW5nIGV4Y2VwdCBvZiB3cml0aW5nIGVycm9ycyB0byBjb25zb2xlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgc2hhcmUoKSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbW91c2V1cCQgPSBtZXJnZSh0aGlzLnBvaW50ZXJFdmVudExpc3RlbmVycy5wb2ludGVyVXAsIHRoaXMubW91c2V1cCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IGN1cnJlbnRSZXNpemU7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcmVtb3ZlR2hvc3RFbGVtZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNpemUgJiYgY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbG0ubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsbS5uYXRpdmVFbGVtZW50LCAndmlzaWJpbGl0eScsICdpbmhlcml0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZ2V0UmVzaXplQ3Vyc29ycyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1JFU0laRV9DVVJTT1JTLCB0aGlzLnJlc2l6ZUN1cnNvcnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2l6ZUVkZ2VzJFxuICAgICAgICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMucmVzaXplRWRnZXMpLCBtYXAoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJlc2l6ZUVkZ2VzICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZXNpemVFZGdlcykuc29tZShlZGdlID0+ICEhdGhpcy5yZXNpemVFZGdlc1tlZGdlXSkpO1xuICAgICAgICB9KSwgc3dpdGNoTWFwKGxlZ2FjeVJlc2l6ZUVkZ2VzRW5hYmxlZCA9PiBsZWdhY3lSZXNpemVFZGdlc0VuYWJsZWQgPyBtb3VzZW1vdmUkIDogRU1QVFkpLCBhdWRpdFRpbWUodGhpcy5tb3VzZU1vdmVUaHJvdHRsZU1TKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBjbGllbnRYLCBjbGllbnRZIH0pID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUVkZ2VzID0gZ2V0UmVzaXplRWRnZXMoe1xuICAgICAgICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICAgICAgICBlbG06IHRoaXMuZWxtLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRFZGdlczogdGhpcy5yZXNpemVFZGdlcyxcbiAgICAgICAgICAgICAgICBjdXJzb3JQcmVjaXNpb246IHRoaXMucmVzaXplQ3Vyc29yUHJlY2lzaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUN1cnNvcnMgPSBnZXRSZXNpemVDdXJzb3JzKCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZ2V0UmVzaXplQ3Vyc29yKHJlc2l6ZUVkZ2VzLCByZXNpemVDdXJzb3JzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsICdjdXJzb3InLCBjdXJzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50Q2xhc3ModGhpcy5lbG0sIFJFU0laRV9MRUZUX0hPVkVSX0NMQVNTLCByZXNpemVFZGdlcy5sZWZ0ID09PSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudENsYXNzKHRoaXMuZWxtLCBSRVNJWkVfUklHSFRfSE9WRVJfQ0xBU1MsIHJlc2l6ZUVkZ2VzLnJpZ2h0ID09PSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudENsYXNzKHRoaXMuZWxtLCBSRVNJWkVfVE9QX0hPVkVSX0NMQVNTLCByZXNpemVFZGdlcy50b3AgPT09IHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50Q2xhc3ModGhpcy5lbG0sIFJFU0laRV9CT1RUT01fSE9WRVJfQ0xBU1MsIHJlc2l6ZUVkZ2VzLmJvdHRvbSA9PT0gdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IG1vdXNlZHJhZyA9IG1vdXNlZG93biRcbiAgICAgICAgICAgIC5waXBlKG1lcmdlTWFwKHN0YXJ0Q29vcmRzID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBtb3ZlQ29vcmRzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREaWZmKG1vdmVDb29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBtb3ZlQ29vcmRzLmNsaWVudFggLSBzdGFydENvb3Jkcy5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBtb3ZlQ29vcmRzLmNsaWVudFkgLSBzdGFydENvb3Jkcy5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGdldFNuYXBHcmlkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwR3JpZCA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6ZVNuYXBHcmlkLmxlZnQgJiYgY3VycmVudFJlc2l6ZS5lZGdlcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZC54ID0gK3RoaXMucmVzaXplU25hcEdyaWQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVNuYXBHcmlkLnJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzaXplLmVkZ2VzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZC54ID0gK3RoaXMucmVzaXplU25hcEdyaWQucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplU25hcEdyaWQudG9wICYmIGN1cnJlbnRSZXNpemUuZWRnZXMudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZC55ID0gK3RoaXMucmVzaXplU25hcEdyaWQudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplU25hcEdyaWQuYm90dG9tICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzaXplLmVkZ2VzLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQueSA9ICt0aGlzLnJlc2l6ZVNuYXBHcmlkLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcEdyaWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGNvb3Jkc1xuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbmFwR3JpZFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0R3JpZChjb29yZHMsIHNuYXBHcmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5jZWlsKGNvb3Jkcy5jbGllbnRYIC8gc25hcEdyaWQueCksXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGguY2VpbChjb29yZHMuY2xpZW50WSAvIHNuYXBHcmlkLnkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKC8qKiBAdHlwZSB7P30gKi8gKG1lcmdlKG1vdXNlbW92ZSQucGlwZSh0YWtlKDEpKS5waXBlKG1hcChjb29yZHMgPT4gWywgY29vcmRzXSkpLCBtb3VzZW1vdmUkLnBpcGUocGFpcndpc2UoKSkpKSkpXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKChbcHJldmlvdXNDb29yZHMsIG5ld0Nvb3Jkc10pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Nvb3JkcyA/IGdldERpZmYocHJldmlvdXNDb29yZHMpIDogcHJldmlvdXNDb29yZHMsXG4gICAgICAgICAgICAgICAgICAgIGdldERpZmYobmV3Q29vcmRzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoKFtwcmV2aW91c0Nvb3JkcywgbmV3Q29vcmRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNDb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwR3JpZCA9IGdldFNuYXBHcmlkKCk7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzR3JpZCA9IGdldEdyaWQocHJldmlvdXNDb29yZHMsIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3R3JpZCA9IGdldEdyaWQobmV3Q29vcmRzLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwcmV2aW91c0dyaWQueCAhPT0gbmV3R3JpZC54IHx8IHByZXZpb3VzR3JpZC55ICE9PSBuZXdHcmlkLnkpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKChbLCBuZXdDb29yZHNdKSA9PiB7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBHcmlkID0gZ2V0U25hcEdyaWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBNYXRoLnJvdW5kKG5ld0Nvb3Jkcy5jbGllbnRYIC8gc25hcEdyaWQueCkgKiBzbmFwR3JpZC54LFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBNYXRoLnJvdW5kKG5ld0Nvb3Jkcy5jbGllbnRZIC8gc25hcEdyaWQueSkgKiBzbmFwR3JpZC55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbChtZXJnZShtb3VzZXVwJCwgbW91c2Vkb3duJCkpKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gISFjdXJyZW50UmVzaXplKSk7XG4gICAgICAgIG1vdXNlZHJhZ1xuICAgICAgICAgICAgLnBpcGUobWFwKCh7IGNsaWVudFgsIGNsaWVudFkgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5ld0JvdW5kaW5nUmVjdGFuZ2xlKCgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplKSkuc3RhcnRpbmdSZWN0LCAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmVkZ2VzLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKG5ld0JvdW5kaW5nUmVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFsbG93TmVnYXRpdmVSZXNpemVzIHx8XG4gICAgICAgICAgICAgICAgISEobmV3Qm91bmRpbmdSZWN0LmhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGluZ1JlY3Qud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRpbmdSZWN0LmhlaWdodCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRpbmdSZWN0LndpZHRoID4gMCkpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigobmV3Qm91bmRpbmdSZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVJlc2l6ZVxuICAgICAgICAgICAgICAgID8gdGhpcy52YWxpZGF0ZVJlc2l6ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogbmV3Qm91bmRpbmdSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlczogZ2V0RWRnZXNEaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJlY3RhbmdsZTogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5zdGFydGluZ1JlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICB9KSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgobmV3Qm91bmRpbmdSZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSAmJiBjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ2hlaWdodCcsIGAke25ld0JvdW5kaW5nUmVjdC5oZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ3dpZHRoJywgYCR7bmV3Qm91bmRpbmdSZWN0LndpZHRofXB4YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICd0b3AnLCBgJHtuZXdCb3VuZGluZ1JlY3QudG9wfXB4YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICdsZWZ0JywgYCR7bmV3Qm91bmRpbmdSZWN0LmxlZnR9cHhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6aW5nLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXppbmcuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogZ2V0RWRnZXNEaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5lZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUmVjdGFuZ2xlOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLnN0YXJ0aW5nUmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplKSkuY3VycmVudFJlY3QgPSBuZXdCb3VuZGluZ1JlY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBtb3VzZWRvd24kXG4gICAgICAgICAgICAucGlwZShtYXAoKHsgY2xpZW50WCwgY2xpZW50WSwgZWRnZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChlZGdlcyB8fFxuICAgICAgICAgICAgICAgIGdldFJlc2l6ZUVkZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgZWxtOiB0aGlzLmVsbSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZEVkZ2VzOiB0aGlzLnJlc2l6ZUVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JQcmVjaXNpb246IHRoaXMucmVzaXplQ3Vyc29yUHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoZWRnZXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlZGdlcykubGVuZ3RoID4gMDtcbiAgICAgICAgfSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUdob3N0RWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdSZWN0ID0gZ2V0RWxlbWVudFJlY3QodGhpcy5lbG0sIHRoaXMuZ2hvc3RFbGVtZW50UG9zaXRpb25pbmcpO1xuICAgICAgICAgICAgY3VycmVudFJlc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICBzdGFydGluZ1JlY3QsXG4gICAgICAgICAgICAgICAgY3VycmVudFJlY3Q6IHN0YXJ0aW5nUmVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUN1cnNvcnMgPSBnZXRSZXNpemVDdXJzb3JzKCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBnZXRSZXNpemVDdXJzb3IoY3VycmVudFJlc2l6ZS5lZGdlcywgcmVzaXplQ3Vyc29ycyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCBjdXJzb3IpO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50Q2xhc3ModGhpcy5lbG0sIFJFU0laRV9BQ1RJVkVfQ0xBU1MsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2hvc3RSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzaXplLmNsb25lZE5vZGUgPSB0aGlzLmVsbS5uYXRpdmVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsbS5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAncG9zaXRpb24nLCB0aGlzLmdob3N0RWxlbWVudFBvc2l0aW9uaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ2xlZnQnLCBgJHtjdXJyZW50UmVzaXplLnN0YXJ0aW5nUmVjdC5sZWZ0fXB4YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICd0b3AnLCBgJHtjdXJyZW50UmVzaXplLnN0YXJ0aW5nUmVjdC50b3B9cHhgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ2hlaWdodCcsIGAke2N1cnJlbnRSZXNpemUuc3RhcnRpbmdSZWN0LmhlaWdodH1weGApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAnd2lkdGgnLCBgJHtjdXJyZW50UmVzaXplLnN0YXJ0aW5nUmVjdC53aWR0aH1weGApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAnY3Vyc29yJywgZ2V0UmVzaXplQ3Vyc29yKGN1cnJlbnRSZXNpemUuZWRnZXMsIHJlc2l6ZUN1cnNvcnMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgUkVTSVpFX0dIT1NUX0VMRU1FTlRfQ0xBU1MpO1xuICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpKS5zY3JvbGxUb3AgPSAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZS5zdGFydGluZ1JlY3RcbiAgICAgICAgICAgICAgICAgICAgLnNjcm9sbFRvcCkpO1xuICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpKS5zY3JvbGxMZWZ0ID0gKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUuc3RhcnRpbmdSZWN0XG4gICAgICAgICAgICAgICAgICAgIC5zY3JvbGxMZWZ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemVTdGFydC5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVN0YXJ0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGdldEVkZ2VzRGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJlY3RhbmdsZTogc3RhcnRpbmdSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY3RhbmdsZTogc3RhcnRpbmdSZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogZ2V0TmV3Qm91bmRpbmdSZWN0YW5nbGUoc3RhcnRpbmdSZWN0LCB7fSwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtb3VzZXVwJC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsbS5uYXRpdmVFbGVtZW50LCBSRVNJWkVfQUNUSVZFX0NMQVNTKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsbS5uYXRpdmVFbGVtZW50LCAnY3Vyc29yJywgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6ZUVuZC5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplRW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBnZXRFZGdlc0RpZmYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5lZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJlY3RhbmdsZTogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5zdGFydGluZ1JlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY3RhbmdsZTogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5jdXJyZW50UmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5jdXJyZW50UmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVHaG9zdEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzaXplID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucmVzaXplRWRnZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplRWRnZXMkLm5leHQodGhpcy5yZXNpemVFZGdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIC8vIGJyb3dzZXIgY2hlY2sgZm9yIGFuZ3VsYXIgdW5pdmVyc2FsLCBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB3aGF0IGRvY3VtZW50IGlzXG4gICAgICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZWRvd24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5tb3VzZXVwLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMubW91c2Vtb3ZlLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMucmVzaXplRWRnZXMkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZWxtXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhZGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldEVsZW1lbnRDbGFzcyhlbG0sIG5hbWUsIGFkZCkge1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsbS5uYXRpdmVFbGVtZW50LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxtLm5hdGl2ZUVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuUmVzaXphYmxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbXdsUmVzaXphYmxlXScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtd2xSZXNpemFibGUnXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVzaXphYmxlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQTEFURk9STV9JRCxdIH1dIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuUmVzaXphYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZhbGlkYXRlUmVzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemVFZGdlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZW5hYmxlR2hvc3RSZXNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlc2l6ZVNuYXBHcmlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemVDdXJzb3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemVDdXJzb3JQcmVjaXNpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdob3N0RWxlbWVudFBvc2l0aW9uaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbGxvd05lZ2F0aXZlUmVzaXplczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbW91c2VNb3ZlVGhyb3R0bGVNUzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVzaXplU3RhcnQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICByZXNpemluZzogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHJlc2l6ZUVuZDogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBlYWNoIHJlc2l6ZSBldmVudC4gUmV0dXJuIGB0cnVlYCB0byBhbGxvdyB0aGUgcmVzaXplIGV2ZW50IHRvIHByb3BhZ2F0ZSBvciBgZmFsc2VgIHRvIGNhbmNlbCBpdFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUudmFsaWRhdGVSZXNpemU7XG4gICAgLyoqXG4gICAgICogVGhlIGVkZ2VzIHRoYXQgYW4gZWxlbWVudCBjYW4gYmUgcmVzaXplZCBmcm9tLiBQYXNzIGFuIG9iamVjdCBsaWtlIGB7dG9wOiB0cnVlLCBib3R0b206IGZhbHNlfWAuIEJ5IGRlZmF1bHQgbm8gZWRnZXMgY2FuIGJlIHJlc2l6ZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGEgcmVzaXplIGhhbmRsZSBpbnN0ZWFkIHRoYXQgcG9zaXRpb25zIGl0c2VsZiB0byB0aGUgc2lkZSBvZiB0aGUgZWxlbWVudCB5b3Ugd291bGQgbGlrZSB0byByZXNpemVcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6ZUVkZ2VzO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIGEgdGVtcG9yYXJ5IHJlc2l6aW5nIGVmZmVjdCBvZiB0aGUgZWxlbWVudCBpbiBiZXR3ZWVuIHRoZSBgcmVzaXplU3RhcnRgIGFuZCBgcmVzaXplRW5kYCBldmVudHMuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5lbmFibGVHaG9zdFJlc2l6ZTtcbiAgICAvKipcbiAgICAgKiBBIHNuYXAgZ3JpZCB0aGF0IHJlc2l6ZSBldmVudHMgd2lsbCBiZSBsb2NrZWQgdG8uXG4gICAgICpcbiAgICAgKiBlLmcuIHRvIG9ubHkgYWxsb3cgdGhlIGVsZW1lbnQgdG8gYmUgcmVzaXplZCBldmVyeSAxMHB4IHNldCBpdCB0byBge2xlZnQ6IDEwLCByaWdodDogMTB9YFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUucmVzaXplU25hcEdyaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG1vdXNlIGN1cnNvcnMgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgcmVzaXplIGVkZ2VzXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVDdXJzb3JzO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIG92ZXIgdGhpY2tuZXNzIHRvIGFjdGl2ZSBjdXJzb3IuXG4gICAgICogQGRlcHJlY2F0ZWQgaW52YWxpZCB3aGVuIHlvdSBtaWdyYXRlIHRvIHVzZSByZXNpemUgaGFuZGxlcyBpbnN0ZWFkIG9mIHNldHRpbmcgcmVzaXplRWRnZXMgb24gdGhlIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6ZUN1cnNvclByZWNpc2lvbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBnaG9zdCBlbGVtZW50IChjYW4gYmUgZml4ZWQgb3IgYWJzb2x1dGUpXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5naG9zdEVsZW1lbnRQb3NpdGlvbmluZztcbiAgICAvKipcbiAgICAgKiBBbGxvdyBlbGVtZW50cyB0byBiZSByZXNpemVkIHRvIG5lZ2F0aXZlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmFsbG93TmVnYXRpdmVSZXNpemVzO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3VzZSBtb3ZlIHRocm90dGxlIGluIG1pbGxpc2Vjb25kcywgZGVmYXVsdDogNTAgbXNcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLm1vdXNlTW92ZVRocm90dGxlTVM7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgYW5kIGEgcmVzaXplIGV2ZW50IGlzIGFib3V0IHRvIGJlZ2luLiBgJGV2ZW50YCBpcyBhIGBSZXNpemVFdmVudGAgb2JqZWN0LlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUucmVzaXplU3RhcnQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFzIHRoZSBtb3VzZSBpcyBkcmFnZ2VkIGFmdGVyIGEgcmVzaXplIGV2ZW50IGhhcyBiZWd1bi4gYCRldmVudGAgaXMgYSBgUmVzaXplRXZlbnRgIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6aW5nO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgbW91c2UgaXMgcmVsZWFzZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQuIGAkZXZlbnRgIGlzIGEgYFJlc2l6ZUV2ZW50YCBvYmplY3QuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVFbmQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubW91c2V1cDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5tb3VzZWRvd247XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubW91c2Vtb3ZlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5wb2ludGVyRXZlbnRMaXN0ZW5lcnM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRlc3Ryb3kkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVFZGdlcyQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnBsYXRmb3JtSWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlbmRlcmVyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmVsbTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuem9uZTtcbn1cbmNsYXNzIFBvaW50ZXJFdmVudExpc3RlbmVycyB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IHpvbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZShyZW5kZXJlciwgem9uZSkge1xuICAgICAgICBpZiAoIVBvaW50ZXJFdmVudExpc3RlbmVycy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgUG9pbnRlckV2ZW50TGlzdGVuZXJzLmluc3RhbmNlID0gbmV3IFBvaW50ZXJFdmVudExpc3RlbmVycyhyZW5kZXJlciwgem9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudExpc3RlbmVycy5pbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gem9uZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd24gPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGxldCB1bnN1YnNjcmliZU1vdXNlRG93bjtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGxldCB1bnN1YnNjcmliZVRvdWNoU3RhcnQ7XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlRG93biA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoSVNfVE9VQ0hfREVWSUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlVG91Y2hTdGFydCA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAndG91Y2hzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlRG93bigpO1xuICAgICAgICAgICAgICAgIGlmIChJU19UT1VDSF9ERVZJQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHVuc3Vic2NyaWJlVG91Y2hTdGFydCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkucGlwZShzaGFyZSgpKTtcbiAgICAgICAgdGhpcy5wb2ludGVyTW92ZSA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgbGV0IHVuc3Vic2NyaWJlTW91c2VNb3ZlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgbGV0IHVuc3Vic2NyaWJlVG91Y2hNb3ZlO1xuICAgICAgICAgICAgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNb3VzZU1vdmUgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ21vdXNlbW92ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVRvdWNoTW92ZSA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAndG91Y2htb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlTW91c2VNb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodW5zdWJzY3JpYmVUb3VjaE1vdmUpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnBpcGUoc2hhcmUoKSk7XG4gICAgICAgIHRoaXMucG9pbnRlclVwID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBsZXQgdW5zdWJzY3JpYmVNb3VzZVVwO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgbGV0IHVuc3Vic2NyaWJlVG91Y2hFbmQ7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBsZXQgdW5zdWJzY3JpYmVUb3VjaENhbmNlbDtcbiAgICAgICAgICAgIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlTW91c2VVcCA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2V1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVRvdWNoRW5kID0gcmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICd0b3VjaGVuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlVG91Y2hDYW5jZWwgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ3RvdWNoY2FuY2VsJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNb3VzZVVwKCk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodW5zdWJzY3JpYmVUb3VjaEVuZCkpKCk7XG4gICAgICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovICh1bnN1YnNjcmliZVRvdWNoQ2FuY2VsKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5waXBlKHNoYXJlKCkpO1xuICAgIH1cbn1cbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9pbnRlckV2ZW50TGlzdGVuZXJzLmluc3RhbmNlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJEb3duO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJNb3ZlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJVcDtcbn1cbiJdfQ==