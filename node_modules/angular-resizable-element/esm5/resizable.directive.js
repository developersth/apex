/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, Renderer2, ElementRef, Output, Input, EventEmitter, NgZone, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Subject, Observable, merge, EMPTY } from 'rxjs';
import { map, mergeMap, takeUntil, filter, pairwise, take, share, auditTime, switchMap, startWith, tap } from 'rxjs/operators';
import { IS_TOUCH_DEVICE } from './is-touch-device';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
function PointerEventCoordinate() { }
if (false) {
    /** @type {?} */
    PointerEventCoordinate.prototype.clientX;
    /** @type {?} */
    PointerEventCoordinate.prototype.clientY;
    /** @type {?} */
    PointerEventCoordinate.prototype.event;
}
/**
 * @record
 */
function Coordinate() { }
if (false) {
    /** @type {?} */
    Coordinate.prototype.x;
    /** @type {?} */
    Coordinate.prototype.y;
}
/**
 * @param {?} value1
 * @param {?} value2
 * @param {?=} precision
 * @return {?}
 */
function isNumberCloseTo(value1, value2, precision) {
    if (precision === void 0) { precision = 3; }
    /** @type {?} */
    var diff = Math.abs(value1 - value2);
    return diff < precision;
}
/**
 * @param {?} startingRect
 * @param {?} edges
 * @param {?} clientX
 * @param {?} clientY
 * @return {?}
 */
function getNewBoundingRectangle(startingRect, edges, clientX, clientY) {
    /** @type {?} */
    var newBoundingRect = {
        top: startingRect.top,
        bottom: startingRect.bottom,
        left: startingRect.left,
        right: startingRect.right
    };
    if (edges.top) {
        newBoundingRect.top += clientY;
    }
    if (edges.bottom) {
        newBoundingRect.bottom += clientY;
    }
    if (edges.left) {
        newBoundingRect.left += clientX;
    }
    if (edges.right) {
        newBoundingRect.right += clientX;
    }
    newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;
    newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;
    return newBoundingRect;
}
/**
 * @param {?} element
 * @param {?} ghostElementPositioning
 * @return {?}
 */
function getElementRect(element, ghostElementPositioning) {
    /** @type {?} */
    var translateX = 0;
    /** @type {?} */
    var translateY = 0;
    /** @type {?} */
    var style = element.nativeElement.style;
    /** @type {?} */
    var transformProperties = [
        'transform',
        '-ms-transform',
        '-moz-transform',
        '-o-transform'
    ];
    /** @type {?} */
    var transform = transformProperties
        .map(function (property) { return style[property]; })
        .find(function (value) { return !!value; });
    if (transform && transform.includes('translate')) {
        translateX = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');
        translateY = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');
    }
    if (ghostElementPositioning === 'absolute') {
        return {
            height: element.nativeElement.offsetHeight,
            width: element.nativeElement.offsetWidth,
            top: element.nativeElement.offsetTop - translateY,
            bottom: element.nativeElement.offsetHeight +
                element.nativeElement.offsetTop -
                translateY,
            left: element.nativeElement.offsetLeft - translateX,
            right: element.nativeElement.offsetWidth +
                element.nativeElement.offsetLeft -
                translateX
        };
    }
    else {
        /** @type {?} */
        var boundingRect = element.nativeElement.getBoundingClientRect();
        return {
            height: boundingRect.height,
            width: boundingRect.width,
            top: boundingRect.top - translateY,
            bottom: boundingRect.bottom - translateY,
            left: boundingRect.left - translateX,
            right: boundingRect.right - translateX,
            scrollTop: element.nativeElement.scrollTop,
            scrollLeft: element.nativeElement.scrollLeft
        };
    }
}
/**
 * @param {?} __0
 * @return {?}
 */
function isWithinBoundingY(_a) {
    var clientY = _a.clientY, rect = _a.rect;
    return clientY >= rect.top && clientY <= rect.bottom;
}
/**
 * @param {?} __0
 * @return {?}
 */
function isWithinBoundingX(_a) {
    var clientX = _a.clientX, rect = _a.rect;
    return clientX >= rect.left && clientX <= rect.right;
}
/**
 * @param {?} __0
 * @return {?}
 */
function getResizeEdges(_a) {
    var clientX = _a.clientX, clientY = _a.clientY, elm = _a.elm, allowedEdges = _a.allowedEdges, cursorPrecision = _a.cursorPrecision;
    /** @type {?} */
    var elmPosition = elm.nativeElement.getBoundingClientRect();
    /** @type {?} */
    var edges = {};
    if (allowedEdges.left &&
        isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &&
        isWithinBoundingY({ clientY: clientY, rect: elmPosition })) {
        edges.left = true;
    }
    if (allowedEdges.right &&
        isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &&
        isWithinBoundingY({ clientY: clientY, rect: elmPosition })) {
        edges.right = true;
    }
    if (allowedEdges.top &&
        isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &&
        isWithinBoundingX({ clientX: clientX, rect: elmPosition })) {
        edges.top = true;
    }
    if (allowedEdges.bottom &&
        isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &&
        isWithinBoundingX({ clientX: clientX, rect: elmPosition })) {
        edges.bottom = true;
    }
    return edges;
}
/**
 * @record
 */
export function ResizeCursors() { }
if (false) {
    /** @type {?} */
    ResizeCursors.prototype.topLeft;
    /** @type {?} */
    ResizeCursors.prototype.topRight;
    /** @type {?} */
    ResizeCursors.prototype.bottomLeft;
    /** @type {?} */
    ResizeCursors.prototype.bottomRight;
    /** @type {?} */
    ResizeCursors.prototype.leftOrRight;
    /** @type {?} */
    ResizeCursors.prototype.topOrBottom;
}
/** @type {?} */
var DEFAULT_RESIZE_CURSORS = Object.freeze({
    topLeft: 'nw-resize',
    topRight: 'ne-resize',
    bottomLeft: 'sw-resize',
    bottomRight: 'se-resize',
    leftOrRight: 'col-resize',
    topOrBottom: 'row-resize'
});
/**
 * @param {?} edges
 * @param {?} cursors
 * @return {?}
 */
function getResizeCursor(edges, cursors) {
    if (edges.left && edges.top) {
        return cursors.topLeft;
    }
    else if (edges.right && edges.top) {
        return cursors.topRight;
    }
    else if (edges.left && edges.bottom) {
        return cursors.bottomLeft;
    }
    else if (edges.right && edges.bottom) {
        return cursors.bottomRight;
    }
    else if (edges.left || edges.right) {
        return cursors.leftOrRight;
    }
    else if (edges.top || edges.bottom) {
        return cursors.topOrBottom;
    }
    else {
        return '';
    }
}
/**
 * @param {?} __0
 * @return {?}
 */
function getEdgesDiff(_a) {
    var edges = _a.edges, initialRectangle = _a.initialRectangle, newRectangle = _a.newRectangle;
    /** @type {?} */
    var edgesDiff = {};
    Object.keys(edges).forEach(function (edge) {
        edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);
    });
    return edgesDiff;
}
/** @type {?} */
var RESIZE_ACTIVE_CLASS = 'resize-active';
/** @type {?} */
var RESIZE_LEFT_HOVER_CLASS = 'resize-left-hover';
/** @type {?} */
var RESIZE_RIGHT_HOVER_CLASS = 'resize-right-hover';
/** @type {?} */
var RESIZE_TOP_HOVER_CLASS = 'resize-top-hover';
/** @type {?} */
var RESIZE_BOTTOM_HOVER_CLASS = 'resize-bottom-hover';
/** @type {?} */
var RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';
/** @type {?} */
export var MOUSE_MOVE_THROTTLE_MS = 50;
/**
 * Place this on an element to make it resizable. For example:
 *
 * ```html
 * <div
 *   mwlResizable
 *   [resizeEdges]="{bottom: true, right: true, top: true, left: true}"
 *   [enableGhostResize]="true">
 * </div>
 * ```
 * Or in case they are sibling elements:
 * ```html
 * <div mwlResizable #resizableElement="mwlResizable"></div>
 * <div mwlResizeHandle [resizableContainer]="resizableElement" [resizeEdges]="{bottom: true, right: true}"></div>
 * ```
 */
var ResizableDirective = /** @class */ (function () {
    /**
     * @hidden
     */
    function ResizableDirective(platformId, renderer, elm, zone) {
        this.platformId = platformId;
        this.renderer = renderer;
        this.elm = elm;
        this.zone = zone;
        /**
         * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
         * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
         */
        this.resizeEdges = {};
        /**
         * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
         */
        this.enableGhostResize = false;
        /**
         * A snap grid that resize events will be locked to.
         *
         * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
         */
        this.resizeSnapGrid = {};
        /**
         * The mouse cursors that will be set on the resize edges
         */
        this.resizeCursors = DEFAULT_RESIZE_CURSORS;
        /**
         * Mouse over thickness to active cursor.
         * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
         */
        this.resizeCursorPrecision = 3;
        /**
         * Define the positioning of the ghost element (can be fixed or absolute)
         */
        this.ghostElementPositioning = 'fixed';
        /**
         * Allow elements to be resized to negative dimensions
         */
        this.allowNegativeResizes = false;
        /**
         * The mouse move throttle in milliseconds, default: 50 ms
         */
        this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;
        /**
         * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
         */
        this.resizeStart = new EventEmitter();
        /**
         * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
         */
        this.resizing = new EventEmitter();
        /**
         * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
         */
        this.resizeEnd = new EventEmitter();
        /**
         * @hidden
         */
        this.mouseup = new Subject();
        /**
         * @hidden
         */
        this.mousedown = new Subject();
        /**
         * @hidden
         */
        this.mousemove = new Subject();
        this.destroy$ = new Subject();
        this.resizeEdges$ = new Subject();
        this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    ResizableDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);
        /** @type {?} */
        var mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(function (_a) {
            var event = _a.event;
            if (currentResize) {
                try {
                    event.preventDefault();
                }
                catch (e) {
                    // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere
                    // browser does nothing except of writing errors to console
                }
            }
        }), share());
        /** @type {?} */
        var mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);
        /** @type {?} */
        var currentResize;
        /** @type {?} */
        var removeGhostElement = function () {
            if (currentResize && currentResize.clonedNode) {
                _this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);
                _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'inherit');
            }
        };
        /** @type {?} */
        var getResizeCursors = function () {
            return tslib_1.__assign({}, DEFAULT_RESIZE_CURSORS, _this.resizeCursors);
        };
        this.resizeEdges$
            .pipe(startWith(this.resizeEdges), map(function () {
            return (_this.resizeEdges &&
                Object.keys(_this.resizeEdges).some(function (edge) { return !!_this.resizeEdges[edge]; }));
        }), switchMap(function (legacyResizeEdgesEnabled) {
            return legacyResizeEdgesEnabled ? mousemove$ : EMPTY;
        }), auditTime(this.mouseMoveThrottleMS), takeUntil(this.destroy$))
            .subscribe(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY;
            /** @type {?} */
            var resizeEdges = getResizeEdges({
                clientX: clientX,
                clientY: clientY,
                elm: _this.elm,
                allowedEdges: _this.resizeEdges,
                cursorPrecision: _this.resizeCursorPrecision
            });
            /** @type {?} */
            var resizeCursors = getResizeCursors();
            if (!currentResize) {
                /** @type {?} */
                var cursor = getResizeCursor(resizeEdges, resizeCursors);
                _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', cursor);
            }
            _this.setElementClass(_this.elm, RESIZE_LEFT_HOVER_CLASS, resizeEdges.left === true);
            _this.setElementClass(_this.elm, RESIZE_RIGHT_HOVER_CLASS, resizeEdges.right === true);
            _this.setElementClass(_this.elm, RESIZE_TOP_HOVER_CLASS, resizeEdges.top === true);
            _this.setElementClass(_this.elm, RESIZE_BOTTOM_HOVER_CLASS, resizeEdges.bottom === true);
        });
        /** @type {?} */
        var mousedrag = mousedown$
            .pipe(mergeMap(function (startCoords) {
            /**
             * @param {?} moveCoords
             * @return {?}
             */
            function getDiff(moveCoords) {
                return {
                    clientX: moveCoords.clientX - startCoords.clientX,
                    clientY: moveCoords.clientY - startCoords.clientY
                };
            }
            /** @type {?} */
            var getSnapGrid = function () {
                /** @type {?} */
                var snapGrid = { x: 1, y: 1 };
                if (currentResize) {
                    if (_this.resizeSnapGrid.left && currentResize.edges.left) {
                        snapGrid.x = +_this.resizeSnapGrid.left;
                    }
                    else if (_this.resizeSnapGrid.right &&
                        currentResize.edges.right) {
                        snapGrid.x = +_this.resizeSnapGrid.right;
                    }
                    if (_this.resizeSnapGrid.top && currentResize.edges.top) {
                        snapGrid.y = +_this.resizeSnapGrid.top;
                    }
                    else if (_this.resizeSnapGrid.bottom &&
                        currentResize.edges.bottom) {
                        snapGrid.y = +_this.resizeSnapGrid.bottom;
                    }
                }
                return snapGrid;
            };
            /**
             * @param {?} coords
             * @param {?} snapGrid
             * @return {?}
             */
            function getGrid(coords, snapGrid) {
                return {
                    x: Math.ceil(coords.clientX / snapGrid.x),
                    y: Math.ceil(coords.clientY / snapGrid.y)
                };
            }
            return ((/** @type {?} */ (merge(mousemove$.pipe(take(1)).pipe(map(function (coords) { return [, coords]; })), mousemove$.pipe(pairwise())))))
                .pipe(map(function (_a) {
                var _b = tslib_1.__read(_a, 2), previousCoords = _b[0], newCoords = _b[1];
                return [
                    previousCoords ? getDiff(previousCoords) : previousCoords,
                    getDiff(newCoords)
                ];
            }))
                .pipe(filter(function (_a) {
                var _b = tslib_1.__read(_a, 2), previousCoords = _b[0], newCoords = _b[1];
                if (!previousCoords) {
                    return true;
                }
                /** @type {?} */
                var snapGrid = getSnapGrid();
                /** @type {?} */
                var previousGrid = getGrid(previousCoords, snapGrid);
                /** @type {?} */
                var newGrid = getGrid(newCoords, snapGrid);
                return (previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y);
            }))
                .pipe(map(function (_a) {
                var _b = tslib_1.__read(_a, 2), newCoords = _b[1];
                /** @type {?} */
                var snapGrid = getSnapGrid();
                return {
                    clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,
                    clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y
                };
            }))
                .pipe(takeUntil(merge(mouseup$, mousedown$)));
        }))
            .pipe(filter(function () { return !!currentResize; }));
        mousedrag
            .pipe(map(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY;
            return getNewBoundingRectangle((/** @type {?} */ (currentResize)).startingRect, (/** @type {?} */ (currentResize)).edges, clientX, clientY);
        }))
            .pipe(filter(function (newBoundingRect) {
            return (_this.allowNegativeResizes ||
                !!(newBoundingRect.height &&
                    newBoundingRect.width &&
                    newBoundingRect.height > 0 &&
                    newBoundingRect.width > 0));
        }))
            .pipe(filter(function (newBoundingRect) {
            return _this.validateResize
                ? _this.validateResize({
                    rectangle: newBoundingRect,
                    edges: getEdgesDiff({
                        edges: (/** @type {?} */ (currentResize)).edges,
                        initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                        newRectangle: newBoundingRect
                    })
                })
                : true;
        }), takeUntil(this.destroy$))
            .subscribe(function (newBoundingRect) {
            if (currentResize && currentResize.clonedNode) {
                _this.renderer.setStyle(currentResize.clonedNode, 'height', newBoundingRect.height + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'width', newBoundingRect.width + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'top', newBoundingRect.top + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'left', newBoundingRect.left + "px");
            }
            if (_this.resizing.observers.length > 0) {
                _this.zone.run(function () {
                    _this.resizing.emit({
                        edges: getEdgesDiff({
                            edges: (/** @type {?} */ (currentResize)).edges,
                            initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                            newRectangle: newBoundingRect
                        }),
                        rectangle: newBoundingRect
                    });
                });
            }
            (/** @type {?} */ (currentResize)).currentRect = newBoundingRect;
        });
        mousedown$
            .pipe(map(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY, edges = _a.edges;
            return (edges ||
                getResizeEdges({
                    clientX: clientX,
                    clientY: clientY,
                    elm: _this.elm,
                    allowedEdges: _this.resizeEdges,
                    cursorPrecision: _this.resizeCursorPrecision
                }));
        }))
            .pipe(filter(function (edges) {
            return Object.keys(edges).length > 0;
        }), takeUntil(this.destroy$))
            .subscribe(function (edges) {
            if (currentResize) {
                removeGhostElement();
            }
            /** @type {?} */
            var startingRect = getElementRect(_this.elm, _this.ghostElementPositioning);
            currentResize = {
                edges: edges,
                startingRect: startingRect,
                currentRect: startingRect
            };
            /** @type {?} */
            var resizeCursors = getResizeCursors();
            /** @type {?} */
            var cursor = getResizeCursor(currentResize.edges, resizeCursors);
            _this.renderer.setStyle(document.body, 'cursor', cursor);
            _this.setElementClass(_this.elm, RESIZE_ACTIVE_CLASS, true);
            if (_this.enableGhostResize) {
                currentResize.clonedNode = _this.elm.nativeElement.cloneNode(true);
                _this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);
                _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'hidden');
                _this.renderer.setStyle(currentResize.clonedNode, 'position', _this.ghostElementPositioning);
                _this.renderer.setStyle(currentResize.clonedNode, 'left', currentResize.startingRect.left + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'top', currentResize.startingRect.top + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'height', currentResize.startingRect.height + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'width', currentResize.startingRect.width + "px");
                _this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));
                _this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);
                (/** @type {?} */ (currentResize.clonedNode)).scrollTop = (/** @type {?} */ (currentResize.startingRect
                    .scrollTop));
                (/** @type {?} */ (currentResize.clonedNode)).scrollLeft = (/** @type {?} */ (currentResize.startingRect
                    .scrollLeft));
            }
            if (_this.resizeStart.observers.length > 0) {
                _this.zone.run(function () {
                    _this.resizeStart.emit({
                        edges: getEdgesDiff({
                            edges: edges,
                            initialRectangle: startingRect,
                            newRectangle: startingRect
                        }),
                        rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)
                    });
                });
            }
        });
        mouseup$.pipe(takeUntil(this.destroy$)).subscribe(function () {
            if (currentResize) {
                _this.renderer.removeClass(_this.elm.nativeElement, RESIZE_ACTIVE_CLASS);
                _this.renderer.setStyle(document.body, 'cursor', '');
                _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', '');
                if (_this.resizeEnd.observers.length > 0) {
                    _this.zone.run(function () {
                        _this.resizeEnd.emit({
                            edges: getEdgesDiff({
                                edges: (/** @type {?} */ (currentResize)).edges,
                                initialRectangle: (/** @type {?} */ (currentResize)).startingRect,
                                newRectangle: (/** @type {?} */ (currentResize)).currentRect
                            }),
                            rectangle: (/** @type {?} */ (currentResize)).currentRect
                        });
                    });
                }
                removeGhostElement();
                currentResize = null;
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ResizableDirective.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.resizeEdges) {
            this.resizeEdges$.next(this.resizeEdges);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    ResizableDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        // browser check for angular universal, because it doesn't know what document is
        if (isPlatformBrowser(this.platformId)) {
            this.renderer.setStyle(document.body, 'cursor', '');
        }
        this.mousedown.complete();
        this.mouseup.complete();
        this.mousemove.complete();
        this.resizeEdges$.complete();
        this.destroy$.next();
    };
    /**
     * @private
     * @param {?} elm
     * @param {?} name
     * @param {?} add
     * @return {?}
     */
    ResizableDirective.prototype.setElementClass = /**
     * @private
     * @param {?} elm
     * @param {?} name
     * @param {?} add
     * @return {?}
     */
    function (elm, name, add) {
        if (add) {
            this.renderer.addClass(elm.nativeElement, name);
        }
        else {
            this.renderer.removeClass(elm.nativeElement, name);
        }
    };
    /** @nocollapse */
    ResizableDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: NgZone }
    ]; };
    ResizableDirective.propDecorators = {
        validateResize: [{ type: Input }],
        resizeEdges: [{ type: Input }],
        enableGhostResize: [{ type: Input }],
        resizeSnapGrid: [{ type: Input }],
        resizeCursors: [{ type: Input }],
        resizeCursorPrecision: [{ type: Input }],
        ghostElementPositioning: [{ type: Input }],
        allowNegativeResizes: [{ type: Input }],
        mouseMoveThrottleMS: [{ type: Input }],
        resizeStart: [{ type: Output }],
        resizing: [{ type: Output }],
        resizeEnd: [{ type: Output }]
    };
ResizableDirective.ɵfac = function ResizableDirective_Factory(t) { return new (t || ResizableDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ResizableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ResizableDirective, selectors: [["", "mwlResizable", ""]], inputs: { resizeEdges: "resizeEdges", enableGhostResize: "enableGhostResize", resizeSnapGrid: "resizeSnapGrid", resizeCursors: "resizeCursors", resizeCursorPrecision: "resizeCursorPrecision", ghostElementPositioning: "ghostElementPositioning", allowNegativeResizes: "allowNegativeResizes", mouseMoveThrottleMS: "mouseMoveThrottleMS", validateResize: "validateResize" }, outputs: { resizeStart: "resizeStart", resizing: "resizing", resizeEnd: "resizeEnd" }, exportAs: ["mwlResizable"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizableDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlResizable]',
                exportAs: 'mwlResizable'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { resizeEdges: [{
            type: Input
        }], enableGhostResize: [{
            type: Input
        }], resizeSnapGrid: [{
            type: Input
        }], resizeCursors: [{
            type: Input
        }], resizeCursorPrecision: [{
            type: Input
        }], ghostElementPositioning: [{
            type: Input
        }], allowNegativeResizes: [{
            type: Input
        }], mouseMoveThrottleMS: [{
            type: Input
        }], resizeStart: [{
            type: Output
        }], resizing: [{
            type: Output
        }], resizeEnd: [{
            type: Output
        }], validateResize: [{
            type: Input
        }] }); })();
    return ResizableDirective;
}());
export { ResizableDirective };
if (false) {
    /**
     * A function that will be called before each resize event. Return `true` to allow the resize event to propagate or `false` to cancel it
     * @type {?}
     */
    ResizableDirective.prototype.validateResize;
    /**
     * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
     * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
     * @type {?}
     */
    ResizableDirective.prototype.resizeEdges;
    /**
     * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
     * @type {?}
     */
    ResizableDirective.prototype.enableGhostResize;
    /**
     * A snap grid that resize events will be locked to.
     *
     * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
     * @type {?}
     */
    ResizableDirective.prototype.resizeSnapGrid;
    /**
     * The mouse cursors that will be set on the resize edges
     * @type {?}
     */
    ResizableDirective.prototype.resizeCursors;
    /**
     * Mouse over thickness to active cursor.
     * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
     * @type {?}
     */
    ResizableDirective.prototype.resizeCursorPrecision;
    /**
     * Define the positioning of the ghost element (can be fixed or absolute)
     * @type {?}
     */
    ResizableDirective.prototype.ghostElementPositioning;
    /**
     * Allow elements to be resized to negative dimensions
     * @type {?}
     */
    ResizableDirective.prototype.allowNegativeResizes;
    /**
     * The mouse move throttle in milliseconds, default: 50 ms
     * @type {?}
     */
    ResizableDirective.prototype.mouseMoveThrottleMS;
    /**
     * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizeStart;
    /**
     * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizing;
    /**
     * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
     * @type {?}
     */
    ResizableDirective.prototype.resizeEnd;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mouseup;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mousedown;
    /**
     * @hidden
     * @type {?}
     */
    ResizableDirective.prototype.mousemove;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.pointerEventListeners;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.resizeEdges$;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.renderer;
    /** @type {?} */
    ResizableDirective.prototype.elm;
    /**
     * @type {?}
     * @private
     */
    ResizableDirective.prototype.zone;
}
var PointerEventListeners = /** @class */ (function () {
    function PointerEventListeners(renderer, zone) {
        this.pointerDown = new Observable(function (observer) {
            /** @type {?} */
            var unsubscribeMouseDown;
            /** @type {?} */
            var unsubscribeTouchStart;
            zone.runOutsideAngular(function () {
                unsubscribeMouseDown = renderer.listen('document', 'mousedown', function (event) {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event: event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchStart = renderer.listen('document', 'touchstart', function (event) {
                        observer.next({
                            clientX: event.touches[0].clientX,
                            clientY: event.touches[0].clientY,
                            event: event
                        });
                    });
                }
            });
            return function () {
                unsubscribeMouseDown();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchStart))();
                }
            };
        }).pipe(share());
        this.pointerMove = new Observable(function (observer) {
            /** @type {?} */
            var unsubscribeMouseMove;
            /** @type {?} */
            var unsubscribeTouchMove;
            zone.runOutsideAngular(function () {
                unsubscribeMouseMove = renderer.listen('document', 'mousemove', function (event) {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event: event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchMove = renderer.listen('document', 'touchmove', function (event) {
                        observer.next({
                            clientX: event.targetTouches[0].clientX,
                            clientY: event.targetTouches[0].clientY,
                            event: event
                        });
                    });
                }
            });
            return function () {
                unsubscribeMouseMove();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchMove))();
                }
            };
        }).pipe(share());
        this.pointerUp = new Observable(function (observer) {
            /** @type {?} */
            var unsubscribeMouseUp;
            /** @type {?} */
            var unsubscribeTouchEnd;
            /** @type {?} */
            var unsubscribeTouchCancel;
            zone.runOutsideAngular(function () {
                unsubscribeMouseUp = renderer.listen('document', 'mouseup', function (event) {
                    observer.next({
                        clientX: event.clientX,
                        clientY: event.clientY,
                        event: event
                    });
                });
                if (IS_TOUCH_DEVICE) {
                    unsubscribeTouchEnd = renderer.listen('document', 'touchend', function (event) {
                        observer.next({
                            clientX: event.changedTouches[0].clientX,
                            clientY: event.changedTouches[0].clientY,
                            event: event
                        });
                    });
                    unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', function (event) {
                        observer.next({
                            clientX: event.changedTouches[0].clientX,
                            clientY: event.changedTouches[0].clientY,
                            event: event
                        });
                    });
                }
            });
            return function () {
                unsubscribeMouseUp();
                if (IS_TOUCH_DEVICE) {
                    (/** @type {?} */ (unsubscribeTouchEnd))();
                    (/** @type {?} */ (unsubscribeTouchCancel))();
                }
            };
        }).pipe(share());
    }
    // tslint:disable-line
    /**
     * @param {?} renderer
     * @param {?} zone
     * @return {?}
     */
    PointerEventListeners.getInstance = 
    // tslint:disable-line
    /**
     * @param {?} renderer
     * @param {?} zone
     * @return {?}
     */
    function (renderer, zone) {
        if (!PointerEventListeners.instance) {
            PointerEventListeners.instance = new PointerEventListeners(renderer, zone);
        }
        return PointerEventListeners.instance;
    };
    return PointerEventListeners;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    PointerEventListeners.instance;
    /** @type {?} */
    PointerEventListeners.prototype.pointerDown;
    /** @type {?} */
    PointerEventListeners.prototype.pointerMove;
    /** @type {?} */
    PointerEventListeners.prototype.pointerUp;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvYW5ndWxhci1yZXNpemFibGUtZWxlbWVudC9lc201L3Jlc2l6YWJsZS5kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BcXFCTSxBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBcUJBIiwiZmlsZSI6InJlc2l6YWJsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIE91dHB1dCwgSW5wdXQsIEV2ZW50RW1pdHRlciwgTmdab25lLCBJbmplY3QsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJqZWN0LCBPYnNlcnZhYmxlLCBtZXJnZSwgRU1QVFkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIHRha2VVbnRpbCwgZmlsdGVyLCBwYWlyd2lzZSwgdGFrZSwgc2hhcmUsIGF1ZGl0VGltZSwgc3dpdGNoTWFwLCBzdGFydFdpdGgsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElTX1RPVUNIX0RFVklDRSB9IGZyb20gJy4vaXMtdG91Y2gtZGV2aWNlJztcbi8qKlxuICogQHJlY29yZFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRDb29yZGluYXRlKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuY2xpZW50WDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuY2xpZW50WTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUG9pbnRlckV2ZW50Q29vcmRpbmF0ZS5wcm90b3R5cGUuZXZlbnQ7XG59XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZnVuY3Rpb24gQ29vcmRpbmF0ZSgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENvb3JkaW5hdGUucHJvdG90eXBlLng7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENvb3JkaW5hdGUucHJvdG90eXBlLnk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWUxXG4gKiBAcGFyYW0gez99IHZhbHVlMlxuICogQHBhcmFtIHs/PX0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc051bWJlckNsb3NlVG8odmFsdWUxLCB2YWx1ZTIsIHByZWNpc2lvbikge1xuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAzOyB9XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnModmFsdWUxIC0gdmFsdWUyKTtcbiAgICByZXR1cm4gZGlmZiA8IHByZWNpc2lvbjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdGFydGluZ1JlY3RcbiAqIEBwYXJhbSB7P30gZWRnZXNcbiAqIEBwYXJhbSB7P30gY2xpZW50WFxuICogQHBhcmFtIHs/fSBjbGllbnRZXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXROZXdCb3VuZGluZ1JlY3RhbmdsZShzdGFydGluZ1JlY3QsIGVkZ2VzLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBuZXdCb3VuZGluZ1JlY3QgPSB7XG4gICAgICAgIHRvcDogc3RhcnRpbmdSZWN0LnRvcCxcbiAgICAgICAgYm90dG9tOiBzdGFydGluZ1JlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0OiBzdGFydGluZ1JlY3QubGVmdCxcbiAgICAgICAgcmlnaHQ6IHN0YXJ0aW5nUmVjdC5yaWdodFxuICAgIH07XG4gICAgaWYgKGVkZ2VzLnRvcCkge1xuICAgICAgICBuZXdCb3VuZGluZ1JlY3QudG9wICs9IGNsaWVudFk7XG4gICAgfVxuICAgIGlmIChlZGdlcy5ib3R0b20pIHtcbiAgICAgICAgbmV3Qm91bmRpbmdSZWN0LmJvdHRvbSArPSBjbGllbnRZO1xuICAgIH1cbiAgICBpZiAoZWRnZXMubGVmdCkge1xuICAgICAgICBuZXdCb3VuZGluZ1JlY3QubGVmdCArPSBjbGllbnRYO1xuICAgIH1cbiAgICBpZiAoZWRnZXMucmlnaHQpIHtcbiAgICAgICAgbmV3Qm91bmRpbmdSZWN0LnJpZ2h0ICs9IGNsaWVudFg7XG4gICAgfVxuICAgIG5ld0JvdW5kaW5nUmVjdC5oZWlnaHQgPSBuZXdCb3VuZGluZ1JlY3QuYm90dG9tIC0gbmV3Qm91bmRpbmdSZWN0LnRvcDtcbiAgICBuZXdCb3VuZGluZ1JlY3Qud2lkdGggPSBuZXdCb3VuZGluZ1JlY3QucmlnaHQgLSBuZXdCb3VuZGluZ1JlY3QubGVmdDtcbiAgICByZXR1cm4gbmV3Qm91bmRpbmdSZWN0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gZ2hvc3RFbGVtZW50UG9zaXRpb25pbmdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRSZWN0KGVsZW1lbnQsIGdob3N0RWxlbWVudFBvc2l0aW9uaW5nKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciB0cmFuc2xhdGVYID0gMDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIHRyYW5zbGF0ZVkgPSAwO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0aWVzID0gW1xuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJy1tcy10cmFuc2Zvcm0nLFxuICAgICAgICAnLW1vei10cmFuc2Zvcm0nLFxuICAgICAgICAnLW8tdHJhbnNmb3JtJ1xuICAgIF07XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1Qcm9wZXJ0aWVzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3BlcnR5KSB7IHJldHVybiBzdHlsZVtwcm9wZXJ0eV07IH0pXG4gICAgICAgIC5maW5kKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gISF2YWx1ZTsgfSk7XG4gICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0uaW5jbHVkZXMoJ3RyYW5zbGF0ZScpKSB7XG4gICAgICAgIHRyYW5zbGF0ZVggPSB0cmFuc2Zvcm0ucmVwbGFjZSgvLip0cmFuc2xhdGUzP2Q/XFwoKC0/WzAtOV0qKXB4LCAoLT9bMC05XSopcHguKi8sICckMScpO1xuICAgICAgICB0cmFuc2xhdGVZID0gdHJhbnNmb3JtLnJlcGxhY2UoLy4qdHJhbnNsYXRlMz9kP1xcKCgtP1swLTldKilweCwgKC0/WzAtOV0qKXB4LiovLCAnJDInKTtcbiAgICB9XG4gICAgaWYgKGdob3N0RWxlbWVudFBvc2l0aW9uaW5nID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgdG9wOiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0VG9wIC0gdHJhbnNsYXRlWSxcbiAgICAgICAgICAgIGJvdHRvbTogZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCArXG4gICAgICAgICAgICAgICAgZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFRvcCAtXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWSxcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IC0gdHJhbnNsYXRlWCxcbiAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggK1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IC1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wIC0gdHJhbnNsYXRlWSxcbiAgICAgICAgICAgIGJvdHRvbTogYm91bmRpbmdSZWN0LmJvdHRvbSAtIHRyYW5zbGF0ZVksXG4gICAgICAgICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCAtIHRyYW5zbGF0ZVgsXG4gICAgICAgICAgICByaWdodDogYm91bmRpbmdSZWN0LnJpZ2h0IC0gdHJhbnNsYXRlWCxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNXaXRoaW5Cb3VuZGluZ1koX2EpIHtcbiAgICB2YXIgY2xpZW50WSA9IF9hLmNsaWVudFksIHJlY3QgPSBfYS5yZWN0O1xuICAgIHJldHVybiBjbGllbnRZID49IHJlY3QudG9wICYmIGNsaWVudFkgPD0gcmVjdC5ib3R0b207XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1dpdGhpbkJvdW5kaW5nWChfYSkge1xuICAgIHZhciBjbGllbnRYID0gX2EuY2xpZW50WCwgcmVjdCA9IF9hLnJlY3Q7XG4gICAgcmV0dXJuIGNsaWVudFggPj0gcmVjdC5sZWZ0ICYmIGNsaWVudFggPD0gcmVjdC5yaWdodDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBfXzBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZUVkZ2VzKF9hKSB7XG4gICAgdmFyIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WSwgZWxtID0gX2EuZWxtLCBhbGxvd2VkRWRnZXMgPSBfYS5hbGxvd2VkRWRnZXMsIGN1cnNvclByZWNpc2lvbiA9IF9hLmN1cnNvclByZWNpc2lvbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGVsbVBvc2l0aW9uID0gZWxtLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBlZGdlcyA9IHt9O1xuICAgIGlmIChhbGxvd2VkRWRnZXMubGVmdCAmJlxuICAgICAgICBpc051bWJlckNsb3NlVG8oY2xpZW50WCwgZWxtUG9zaXRpb24ubGVmdCwgY3Vyc29yUHJlY2lzaW9uKSAmJlxuICAgICAgICBpc1dpdGhpbkJvdW5kaW5nWSh7IGNsaWVudFk6IGNsaWVudFksIHJlY3Q6IGVsbVBvc2l0aW9uIH0pKSB7XG4gICAgICAgIGVkZ2VzLmxlZnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dlZEVkZ2VzLnJpZ2h0ICYmXG4gICAgICAgIGlzTnVtYmVyQ2xvc2VUbyhjbGllbnRYLCBlbG1Qb3NpdGlvbi5yaWdodCwgY3Vyc29yUHJlY2lzaW9uKSAmJlxuICAgICAgICBpc1dpdGhpbkJvdW5kaW5nWSh7IGNsaWVudFk6IGNsaWVudFksIHJlY3Q6IGVsbVBvc2l0aW9uIH0pKSB7XG4gICAgICAgIGVkZ2VzLnJpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRFZGdlcy50b3AgJiZcbiAgICAgICAgaXNOdW1iZXJDbG9zZVRvKGNsaWVudFksIGVsbVBvc2l0aW9uLnRvcCwgY3Vyc29yUHJlY2lzaW9uKSAmJlxuICAgICAgICBpc1dpdGhpbkJvdW5kaW5nWCh7IGNsaWVudFg6IGNsaWVudFgsIHJlY3Q6IGVsbVBvc2l0aW9uIH0pKSB7XG4gICAgICAgIGVkZ2VzLnRvcCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChhbGxvd2VkRWRnZXMuYm90dG9tICYmXG4gICAgICAgIGlzTnVtYmVyQ2xvc2VUbyhjbGllbnRZLCBlbG1Qb3NpdGlvbi5ib3R0b20sIGN1cnNvclByZWNpc2lvbikgJiZcbiAgICAgICAgaXNXaXRoaW5Cb3VuZGluZ1goeyBjbGllbnRYOiBjbGllbnRYLCByZWN0OiBlbG1Qb3NpdGlvbiB9KSkge1xuICAgICAgICBlZGdlcy5ib3R0b20gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXM7XG59XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlc2l6ZUN1cnNvcnMoKSB7IH1cbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemVDdXJzb3JzLnByb3RvdHlwZS50b3BMZWZ0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemVDdXJzb3JzLnByb3RvdHlwZS50b3BSaWdodDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUmVzaXplQ3Vyc29ycy5wcm90b3R5cGUuYm90dG9tTGVmdDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUmVzaXplQ3Vyc29ycy5wcm90b3R5cGUuYm90dG9tUmlnaHQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIFJlc2l6ZUN1cnNvcnMucHJvdG90eXBlLmxlZnRPclJpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemVDdXJzb3JzLnByb3RvdHlwZS50b3BPckJvdHRvbTtcbn1cbi8qKiBAdHlwZSB7P30gKi9cbnZhciBERUZBVUxUX1JFU0laRV9DVVJTT1JTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdG9wTGVmdDogJ253LXJlc2l6ZScsXG4gICAgdG9wUmlnaHQ6ICduZS1yZXNpemUnLFxuICAgIGJvdHRvbUxlZnQ6ICdzdy1yZXNpemUnLFxuICAgIGJvdHRvbVJpZ2h0OiAnc2UtcmVzaXplJyxcbiAgICBsZWZ0T3JSaWdodDogJ2NvbC1yZXNpemUnLFxuICAgIHRvcE9yQm90dG9tOiAncm93LXJlc2l6ZSdcbn0pO1xuLyoqXG4gKiBAcGFyYW0gez99IGVkZ2VzXG4gKiBAcGFyYW0gez99IGN1cnNvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZUN1cnNvcihlZGdlcywgY3Vyc29ycykge1xuICAgIGlmIChlZGdlcy5sZWZ0ICYmIGVkZ2VzLnRvcCkge1xuICAgICAgICByZXR1cm4gY3Vyc29ycy50b3BMZWZ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlZGdlcy5yaWdodCAmJiBlZGdlcy50b3ApIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcnMudG9wUmlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVkZ2VzLmxlZnQgJiYgZWRnZXMuYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3JzLmJvdHRvbUxlZnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVkZ2VzLnJpZ2h0ICYmIGVkZ2VzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gY3Vyc29ycy5ib3R0b21SaWdodDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWRnZXMubGVmdCB8fCBlZGdlcy5yaWdodCkge1xuICAgICAgICByZXR1cm4gY3Vyc29ycy5sZWZ0T3JSaWdodDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWRnZXMudG9wIHx8IGVkZ2VzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gY3Vyc29ycy50b3BPckJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRFZGdlc0RpZmYoX2EpIHtcbiAgICB2YXIgZWRnZXMgPSBfYS5lZGdlcywgaW5pdGlhbFJlY3RhbmdsZSA9IF9hLmluaXRpYWxSZWN0YW5nbGUsIG5ld1JlY3RhbmdsZSA9IF9hLm5ld1JlY3RhbmdsZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGVkZ2VzRGlmZiA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGVkZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGVkZ2VzRGlmZltlZGdlXSA9IChuZXdSZWN0YW5nbGVbZWRnZV0gfHwgMCkgLSAoaW5pdGlhbFJlY3RhbmdsZVtlZGdlXSB8fCAwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRnZXNEaWZmO1xufVxuLyoqIEB0eXBlIHs/fSAqL1xudmFyIFJFU0laRV9BQ1RJVkVfQ0xBU1MgPSAncmVzaXplLWFjdGl2ZSc7XG4vKiogQHR5cGUgez99ICovXG52YXIgUkVTSVpFX0xFRlRfSE9WRVJfQ0xBU1MgPSAncmVzaXplLWxlZnQtaG92ZXInO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIFJFU0laRV9SSUdIVF9IT1ZFUl9DTEFTUyA9ICdyZXNpemUtcmlnaHQtaG92ZXInO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIFJFU0laRV9UT1BfSE9WRVJfQ0xBU1MgPSAncmVzaXplLXRvcC1ob3Zlcic7XG4vKiogQHR5cGUgez99ICovXG52YXIgUkVTSVpFX0JPVFRPTV9IT1ZFUl9DTEFTUyA9ICdyZXNpemUtYm90dG9tLWhvdmVyJztcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBSRVNJWkVfR0hPU1RfRUxFTUVOVF9DTEFTUyA9ICdyZXNpemUtZ2hvc3QtZWxlbWVudCc7XG4vKiogQHR5cGUgez99ICovXG5leHBvcnQgdmFyIE1PVVNFX01PVkVfVEhST1RUTEVfTVMgPSA1MDtcbi8qKlxuICogUGxhY2UgdGhpcyBvbiBhbiBlbGVtZW50IHRvIG1ha2UgaXQgcmVzaXphYmxlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2XG4gKiAgIG13bFJlc2l6YWJsZVxuICogICBbcmVzaXplRWRnZXNdPVwie2JvdHRvbTogdHJ1ZSwgcmlnaHQ6IHRydWUsIHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZX1cIlxuICogICBbZW5hYmxlR2hvc3RSZXNpemVdPVwidHJ1ZVwiPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqIE9yIGluIGNhc2UgdGhleSBhcmUgc2libGluZyBlbGVtZW50czpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbXdsUmVzaXphYmxlICNyZXNpemFibGVFbGVtZW50PVwibXdsUmVzaXphYmxlXCI+PC9kaXY+XG4gKiA8ZGl2IG13bFJlc2l6ZUhhbmRsZSBbcmVzaXphYmxlQ29udGFpbmVyXT1cInJlc2l6YWJsZUVsZW1lbnRcIiBbcmVzaXplRWRnZXNdPVwie2JvdHRvbTogdHJ1ZSwgcmlnaHQ6IHRydWV9XCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xudmFyIFJlc2l6YWJsZURpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzaXphYmxlRGlyZWN0aXZlKHBsYXRmb3JtSWQsIHJlbmRlcmVyLCBlbG0sIHpvbmUpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlZGdlcyB0aGF0IGFuIGVsZW1lbnQgY2FuIGJlIHJlc2l6ZWQgZnJvbS4gUGFzcyBhbiBvYmplY3QgbGlrZSBge3RvcDogdHJ1ZSwgYm90dG9tOiBmYWxzZX1gLiBCeSBkZWZhdWx0IG5vIGVkZ2VzIGNhbiBiZSByZXNpemVkLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYSByZXNpemUgaGFuZGxlIGluc3RlYWQgdGhhdCBwb3NpdGlvbnMgaXRzZWxmIHRvIHRoZSBzaWRlIG9mIHRoZSBlbGVtZW50IHlvdSB3b3VsZCBsaWtlIHRvIHJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemVFZGdlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgYSB0ZW1wb3JhcnkgcmVzaXppbmcgZWZmZWN0IG9mIHRoZSBlbGVtZW50IGluIGJldHdlZW4gdGhlIGByZXNpemVTdGFydGAgYW5kIGByZXNpemVFbmRgIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5hYmxlR2hvc3RSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc25hcCBncmlkIHRoYXQgcmVzaXplIGV2ZW50cyB3aWxsIGJlIGxvY2tlZCB0by5cbiAgICAgICAgICpcbiAgICAgICAgICogZS5nLiB0byBvbmx5IGFsbG93IHRoZSBlbGVtZW50IHRvIGJlIHJlc2l6ZWQgZXZlcnkgMTBweCBzZXQgaXQgdG8gYHtsZWZ0OiAxMCwgcmlnaHQ6IDEwfWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplU25hcEdyaWQgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3VzZSBjdXJzb3JzIHRoYXQgd2lsbCBiZSBzZXQgb24gdGhlIHJlc2l6ZSBlZGdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemVDdXJzb3JzID0gREVGQVVMVF9SRVNJWkVfQ1VSU09SUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG92ZXIgdGhpY2tuZXNzIHRvIGFjdGl2ZSBjdXJzb3IuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGludmFsaWQgd2hlbiB5b3UgbWlncmF0ZSB0byB1c2UgcmVzaXplIGhhbmRsZXMgaW5zdGVhZCBvZiBzZXR0aW5nIHJlc2l6ZUVkZ2VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZUN1cnNvclByZWNpc2lvbiA9IDM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBnaG9zdCBlbGVtZW50IChjYW4gYmUgZml4ZWQgb3IgYWJzb2x1dGUpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudFBvc2l0aW9uaW5nID0gJ2ZpeGVkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93IGVsZW1lbnRzIHRvIGJlIHJlc2l6ZWQgdG8gbmVnYXRpdmUgZGltZW5zaW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd05lZ2F0aXZlUmVzaXplcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdXNlIG1vdmUgdGhyb3R0bGUgaW4gbWlsbGlzZWNvbmRzLCBkZWZhdWx0OiA1MCBtc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaHJvdHRsZU1TID0gTU9VU0VfTU9WRV9USFJPVFRMRV9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb3VzZSBpcyBwcmVzc2VkIGFuZCBhIHJlc2l6ZSBldmVudCBpcyBhYm91dCB0byBiZWdpbi4gYCRldmVudGAgaXMgYSBgUmVzaXplRXZlbnRgIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYXMgdGhlIG1vdXNlIGlzIGRyYWdnZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQgaGFzIGJlZ3VuLiBgJGV2ZW50YCBpcyBhIGBSZXNpemVFdmVudGAgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhZnRlciB0aGUgbW91c2UgaXMgcmVsZWFzZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQuIGAkZXZlbnRgIGlzIGEgYFJlc2l6ZUV2ZW50YCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2V1cCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlbW92ZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZUVkZ2VzJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzID0gUG9pbnRlckV2ZW50TGlzdGVuZXJzLmdldEluc3RhbmNlKHJlbmRlcmVyLCB6b25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG1vdXNlZG93biQgPSBtZXJnZSh0aGlzLnBvaW50ZXJFdmVudExpc3RlbmVycy5wb2ludGVyRG93biwgdGhpcy5tb3VzZWRvd24pO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBtb3VzZW1vdmUkID0gbWVyZ2UodGhpcy5wb2ludGVyRXZlbnRMaXN0ZW5lcnMucG9pbnRlck1vdmUsIHRoaXMubW91c2Vtb3ZlKS5waXBlKHRhcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IF9hLmV2ZW50O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNpemUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFkZGluZyB0cnktY2F0Y2ggbm90IHRvIHNlZSBlcnJvcnMgaW4gY29uc29sZSBpZiB0aGVyZSBpcyBhIHBhc3NpdmUgbGlzdGVuZXIgZm9yIHNhbWUgZXZlbnQgc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgZG9lcyBub3RoaW5nIGV4Y2VwdCBvZiB3cml0aW5nIGVycm9ycyB0byBjb25zb2xlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgc2hhcmUoKSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG1vdXNldXAkID0gbWVyZ2UodGhpcy5wb2ludGVyRXZlbnRMaXN0ZW5lcnMucG9pbnRlclVwLCB0aGlzLm1vdXNldXApO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjdXJyZW50UmVzaXplO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciByZW1vdmVHaG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSAmJiBjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbG0ubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoX3RoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ2luaGVyaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgZ2V0UmVzaXplQ3Vyc29ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBERUZBVUxUX1JFU0laRV9DVVJTT1JTLCBfdGhpcy5yZXNpemVDdXJzb3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNpemVFZGdlcyRcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLnJlc2l6ZUVkZ2VzKSwgbWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMucmVzaXplRWRnZXMgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5yZXNpemVFZGdlcykuc29tZShmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gISFfdGhpcy5yZXNpemVFZGdlc1tlZGdlXTsgfSkpO1xuICAgICAgICB9KSwgc3dpdGNoTWFwKGZ1bmN0aW9uIChsZWdhY3lSZXNpemVFZGdlc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWdhY3lSZXNpemVFZGdlc0VuYWJsZWQgPyBtb3VzZW1vdmUkIDogRU1QVFk7XG4gICAgICAgIH0pLCBhdWRpdFRpbWUodGhpcy5tb3VzZU1vdmVUaHJvdHRsZU1TKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgcmVzaXplRWRnZXMgPSBnZXRSZXNpemVFZGdlcyh7XG4gICAgICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICBjbGllbnRZOiBjbGllbnRZLFxuICAgICAgICAgICAgICAgIGVsbTogX3RoaXMuZWxtLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRFZGdlczogX3RoaXMucmVzaXplRWRnZXMsXG4gICAgICAgICAgICAgICAgY3Vyc29yUHJlY2lzaW9uOiBfdGhpcy5yZXNpemVDdXJzb3JQcmVjaXNpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHJlc2l6ZUN1cnNvcnMgPSBnZXRSZXNpemVDdXJzb3JzKCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGdldFJlc2l6ZUN1cnNvcihyZXNpemVFZGdlcywgcmVzaXplQ3Vyc29ycyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoX3RoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsICdjdXJzb3InLCBjdXJzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0RWxlbWVudENsYXNzKF90aGlzLmVsbSwgUkVTSVpFX0xFRlRfSE9WRVJfQ0xBU1MsIHJlc2l6ZUVkZ2VzLmxlZnQgPT09IHRydWUpO1xuICAgICAgICAgICAgX3RoaXMuc2V0RWxlbWVudENsYXNzKF90aGlzLmVsbSwgUkVTSVpFX1JJR0hUX0hPVkVSX0NMQVNTLCByZXNpemVFZGdlcy5yaWdodCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRFbGVtZW50Q2xhc3MoX3RoaXMuZWxtLCBSRVNJWkVfVE9QX0hPVkVSX0NMQVNTLCByZXNpemVFZGdlcy50b3AgPT09IHRydWUpO1xuICAgICAgICAgICAgX3RoaXMuc2V0RWxlbWVudENsYXNzKF90aGlzLmVsbSwgUkVTSVpFX0JPVFRPTV9IT1ZFUl9DTEFTUywgcmVzaXplRWRnZXMuYm90dG9tID09PSB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG1vdXNlZHJhZyA9IG1vdXNlZG93biRcbiAgICAgICAgICAgIC5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChzdGFydENvb3Jkcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1vdmVDb29yZHNcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldERpZmYobW92ZUNvb3Jkcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IG1vdmVDb29yZHMuY2xpZW50WCAtIHN0YXJ0Q29vcmRzLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IG1vdmVDb29yZHMuY2xpZW50WSAtIHN0YXJ0Q29vcmRzLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGdldFNuYXBHcmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgc25hcEdyaWQgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzaXplU25hcEdyaWQubGVmdCAmJiBjdXJyZW50UmVzaXplLmVkZ2VzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLnggPSArX3RoaXMucmVzaXplU25hcEdyaWQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yZXNpemVTbmFwR3JpZC5yaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc2l6ZS5lZGdlcy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQueCA9ICtfdGhpcy5yZXNpemVTbmFwR3JpZC5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzaXplU25hcEdyaWQudG9wICYmIGN1cnJlbnRSZXNpemUuZWRnZXMudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZC55ID0gK190aGlzLnJlc2l6ZVNuYXBHcmlkLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yZXNpemVTbmFwR3JpZC5ib3R0b20gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNpemUuZWRnZXMuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZC55ID0gK190aGlzLnJlc2l6ZVNuYXBHcmlkLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcEdyaWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGNvb3Jkc1xuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzbmFwR3JpZFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0R3JpZChjb29yZHMsIHNuYXBHcmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5jZWlsKGNvb3Jkcy5jbGllbnRYIC8gc25hcEdyaWQueCksXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGguY2VpbChjb29yZHMuY2xpZW50WSAvIHNuYXBHcmlkLnkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKC8qKiBAdHlwZSB7P30gKi8gKG1lcmdlKG1vdXNlbW92ZSQucGlwZSh0YWtlKDEpKS5waXBlKG1hcChmdW5jdGlvbiAoY29vcmRzKSB7IHJldHVybiBbLCBjb29yZHNdOyB9KSksIG1vdXNlbW92ZSQucGlwZShwYWlyd2lzZSgpKSkpKSlcbiAgICAgICAgICAgICAgICAucGlwZShtYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBwcmV2aW91c0Nvb3JkcyA9IF9iWzBdLCBuZXdDb29yZHMgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Nvb3JkcyA/IGdldERpZmYocHJldmlvdXNDb29yZHMpIDogcHJldmlvdXNDb29yZHMsXG4gICAgICAgICAgICAgICAgICAgIGdldERpZmYobmV3Q29vcmRzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBwcmV2aW91c0Nvb3JkcyA9IF9iWzBdLCBuZXdDb29yZHMgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzQ29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBHcmlkID0gZ2V0U25hcEdyaWQoKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzR3JpZCA9IGdldEdyaWQocHJldmlvdXNDb29yZHMsIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIG5ld0dyaWQgPSBnZXRHcmlkKG5ld0Nvb3Jkcywgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocHJldmlvdXNHcmlkLnggIT09IG5ld0dyaWQueCB8fCBwcmV2aW91c0dyaWQueSAhPT0gbmV3R3JpZC55KTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5waXBlKG1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIG5ld0Nvb3JkcyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgc25hcEdyaWQgPSBnZXRTbmFwR3JpZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IE1hdGgucm91bmQobmV3Q29vcmRzLmNsaWVudFggLyBzbmFwR3JpZC54KSAqIHNuYXBHcmlkLngsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IE1hdGgucm91bmQobmV3Q29vcmRzLmNsaWVudFkgLyBzbmFwR3JpZC55KSAqIHNuYXBHcmlkLnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKG1lcmdlKG1vdXNldXAkLCBtb3VzZWRvd24kKSkpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAhIWN1cnJlbnRSZXNpemU7IH0pKTtcbiAgICAgICAgbW91c2VkcmFnXG4gICAgICAgICAgICAucGlwZShtYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICAgICAgcmV0dXJuIGdldE5ld0JvdW5kaW5nUmVjdGFuZ2xlKCgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplKSkuc3RhcnRpbmdSZWN0LCAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmVkZ2VzLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoZnVuY3Rpb24gKG5ld0JvdW5kaW5nUmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5hbGxvd05lZ2F0aXZlUmVzaXplcyB8fFxuICAgICAgICAgICAgICAgICEhKG5ld0JvdW5kaW5nUmVjdC5oZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRpbmdSZWN0LndpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kaW5nUmVjdC5oZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kaW5nUmVjdC53aWR0aCA+IDApKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoZnVuY3Rpb24gKG5ld0JvdW5kaW5nUmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnZhbGlkYXRlUmVzaXplXG4gICAgICAgICAgICAgICAgPyBfdGhpcy52YWxpZGF0ZVJlc2l6ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogbmV3Qm91bmRpbmdSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlczogZ2V0RWRnZXNEaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJlY3RhbmdsZTogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5zdGFydGluZ1JlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICB9KSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAobmV3Qm91bmRpbmdSZWN0KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSAmJiBjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICdoZWlnaHQnLCBuZXdCb3VuZGluZ1JlY3QuaGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICd3aWR0aCcsIG5ld0JvdW5kaW5nUmVjdC53aWR0aCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAndG9wJywgbmV3Qm91bmRpbmdSZWN0LnRvcCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAnbGVmdCcsIG5ld0JvdW5kaW5nUmVjdC5sZWZ0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNpemluZy5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXppbmcuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogZ2V0RWRnZXNEaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUpKS5lZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUmVjdGFuZ2xlOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLnN0YXJ0aW5nUmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGU6IG5ld0JvdW5kaW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplKSkuY3VycmVudFJlY3QgPSBuZXdCb3VuZGluZ1JlY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBtb3VzZWRvd24kXG4gICAgICAgICAgICAucGlwZShtYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZLCBlZGdlcyA9IF9hLmVkZ2VzO1xuICAgICAgICAgICAgcmV0dXJuIChlZGdlcyB8fFxuICAgICAgICAgICAgICAgIGdldFJlc2l6ZUVkZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgZWxtOiBfdGhpcy5lbG0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRFZGdlczogX3RoaXMucmVzaXplRWRnZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvclByZWNpc2lvbjogX3RoaXMucmVzaXplQ3Vyc29yUHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcihmdW5jdGlvbiAoZWRnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlZGdlcykubGVuZ3RoID4gMDtcbiAgICAgICAgfSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUdob3N0RWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHN0YXJ0aW5nUmVjdCA9IGdldEVsZW1lbnRSZWN0KF90aGlzLmVsbSwgX3RoaXMuZ2hvc3RFbGVtZW50UG9zaXRpb25pbmcpO1xuICAgICAgICAgICAgY3VycmVudFJlc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICBlZGdlczogZWRnZXMsXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdSZWN0OiBzdGFydGluZ1JlY3QsXG4gICAgICAgICAgICAgICAgY3VycmVudFJlY3Q6IHN0YXJ0aW5nUmVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciByZXNpemVDdXJzb3JzID0gZ2V0UmVzaXplQ3Vyc29ycygpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGdldFJlc2l6ZUN1cnNvcihjdXJyZW50UmVzaXplLmVkZ2VzLCByZXNpemVDdXJzb3JzKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCBjdXJzb3IpO1xuICAgICAgICAgICAgX3RoaXMuc2V0RWxlbWVudENsYXNzKF90aGlzLmVsbSwgUkVTSVpFX0FDVElWRV9DTEFTUywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZW5hYmxlR2hvc3RSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzaXplLmNsb25lZE5vZGUgPSBfdGhpcy5lbG0ubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZWxtLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjdXJyZW50UmVzaXplLmNsb25lZE5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnNldFN0eWxlKF90aGlzLmVsbS5uYXRpdmVFbGVtZW50LCAndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICdwb3NpdGlvbicsIF90aGlzLmdob3N0RWxlbWVudFBvc2l0aW9uaW5nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICdsZWZ0JywgY3VycmVudFJlc2l6ZS5zdGFydGluZ1JlY3QubGVmdCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCAndG9wJywgY3VycmVudFJlc2l6ZS5zdGFydGluZ1JlY3QudG9wICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjdXJyZW50UmVzaXplLmNsb25lZE5vZGUsICdoZWlnaHQnLCBjdXJyZW50UmVzaXplLnN0YXJ0aW5nUmVjdC5oZWlnaHQgKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ3dpZHRoJywgY3VycmVudFJlc2l6ZS5zdGFydGluZ1JlY3Qud2lkdGggKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnNldFN0eWxlKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSwgJ2N1cnNvcicsIGdldFJlc2l6ZUN1cnNvcihjdXJyZW50UmVzaXplLmVkZ2VzLCByZXNpemVDdXJzb3JzKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuYWRkQ2xhc3MoY3VycmVudFJlc2l6ZS5jbG9uZWROb2RlLCBSRVNJWkVfR0hPU1RfRUxFTUVOVF9DTEFTUyk7XG4gICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSkpLnNjcm9sbFRvcCA9ICgvKiogQHR5cGUgez99ICovIChjdXJyZW50UmVzaXplLnN0YXJ0aW5nUmVjdFxuICAgICAgICAgICAgICAgICAgICAuc2Nyb2xsVG9wKSk7XG4gICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGN1cnJlbnRSZXNpemUuY2xvbmVkTm9kZSkpLnNjcm9sbExlZnQgPSAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZS5zdGFydGluZ1JlY3RcbiAgICAgICAgICAgICAgICAgICAgLnNjcm9sbExlZnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNpemVTdGFydC5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXplU3RhcnQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogZ2V0RWRnZXNEaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogZWRnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJlY3RhbmdsZTogc3RhcnRpbmdSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY3RhbmdsZTogc3RhcnRpbmdSZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogZ2V0TmV3Qm91bmRpbmdSZWN0YW5nbGUoc3RhcnRpbmdSZWN0LCB7fSwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtb3VzZXVwJC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoX3RoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsIFJFU0laRV9BQ1RJVkVfQ0xBU1MpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoX3RoaXMuZWxtLm5hdGl2ZUVsZW1lbnQsICdjdXJzb3InLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlc2l6ZUVuZC5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemVFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGdldEVkZ2VzRGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUmVjdGFuZ2xlOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLnN0YXJ0aW5nUmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdGFuZ2xlOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmN1cnJlbnRSZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlOiAoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudFJlc2l6ZSkpLmN1cnJlbnRSZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZUdob3N0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNpemUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucmVzaXplRWRnZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplRWRnZXMkLm5leHQodGhpcy5yZXNpemVFZGdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBicm93c2VyIGNoZWNrIGZvciBhbmd1bGFyIHVuaXZlcnNhbCwgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgd2hhdCBkb2N1bWVudCBpc1xuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCAnY3Vyc29yJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2Vkb3duLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMubW91c2V1cC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLm1vdXNlbW92ZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZUVkZ2VzJC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBlbG1cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFkZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZWxtXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhZGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbG0sIG5hbWUsIGFkZCkge1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsbS5uYXRpdmVFbGVtZW50LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxtLm5hdGl2ZUVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW213bFJlc2l6YWJsZV0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ213bFJlc2l6YWJsZSdcbiAgICAgICAgICAgICAgICB9LF0gfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9LFxuICAgICAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICB2YWxpZGF0ZVJlc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJlc2l6ZUVkZ2VzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZW5hYmxlR2hvc3RSZXNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICByZXNpemVTbmFwR3JpZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJlc2l6ZUN1cnNvcnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICByZXNpemVDdXJzb3JQcmVjaXNpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBnaG9zdEVsZW1lbnRQb3NpdGlvbmluZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGFsbG93TmVnYXRpdmVSZXNpemVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgbW91c2VNb3ZlVGhyb3R0bGVNUzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJlc2l6ZVN0YXJ0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHJlc2l6aW5nOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHJlc2l6ZUVuZDogW3sgdHlwZTogT3V0cHV0IH1dXG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXphYmxlRGlyZWN0aXZlO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6YWJsZURpcmVjdGl2ZSB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBlYWNoIHJlc2l6ZSBldmVudC4gUmV0dXJuIGB0cnVlYCB0byBhbGxvdyB0aGUgcmVzaXplIGV2ZW50IHRvIHByb3BhZ2F0ZSBvciBgZmFsc2VgIHRvIGNhbmNlbCBpdFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUudmFsaWRhdGVSZXNpemU7XG4gICAgLyoqXG4gICAgICogVGhlIGVkZ2VzIHRoYXQgYW4gZWxlbWVudCBjYW4gYmUgcmVzaXplZCBmcm9tLiBQYXNzIGFuIG9iamVjdCBsaWtlIGB7dG9wOiB0cnVlLCBib3R0b206IGZhbHNlfWAuIEJ5IGRlZmF1bHQgbm8gZWRnZXMgY2FuIGJlIHJlc2l6ZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGEgcmVzaXplIGhhbmRsZSBpbnN0ZWFkIHRoYXQgcG9zaXRpb25zIGl0c2VsZiB0byB0aGUgc2lkZSBvZiB0aGUgZWxlbWVudCB5b3Ugd291bGQgbGlrZSB0byByZXNpemVcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6ZUVkZ2VzO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIGEgdGVtcG9yYXJ5IHJlc2l6aW5nIGVmZmVjdCBvZiB0aGUgZWxlbWVudCBpbiBiZXR3ZWVuIHRoZSBgcmVzaXplU3RhcnRgIGFuZCBgcmVzaXplRW5kYCBldmVudHMuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5lbmFibGVHaG9zdFJlc2l6ZTtcbiAgICAvKipcbiAgICAgKiBBIHNuYXAgZ3JpZCB0aGF0IHJlc2l6ZSBldmVudHMgd2lsbCBiZSBsb2NrZWQgdG8uXG4gICAgICpcbiAgICAgKiBlLmcuIHRvIG9ubHkgYWxsb3cgdGhlIGVsZW1lbnQgdG8gYmUgcmVzaXplZCBldmVyeSAxMHB4IHNldCBpdCB0byBge2xlZnQ6IDEwLCByaWdodDogMTB9YFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUucmVzaXplU25hcEdyaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG1vdXNlIGN1cnNvcnMgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgcmVzaXplIGVkZ2VzXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVDdXJzb3JzO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIG92ZXIgdGhpY2tuZXNzIHRvIGFjdGl2ZSBjdXJzb3IuXG4gICAgICogQGRlcHJlY2F0ZWQgaW52YWxpZCB3aGVuIHlvdSBtaWdyYXRlIHRvIHVzZSByZXNpemUgaGFuZGxlcyBpbnN0ZWFkIG9mIHNldHRpbmcgcmVzaXplRWRnZXMgb24gdGhlIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6ZUN1cnNvclByZWNpc2lvbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBnaG9zdCBlbGVtZW50IChjYW4gYmUgZml4ZWQgb3IgYWJzb2x1dGUpXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5naG9zdEVsZW1lbnRQb3NpdGlvbmluZztcbiAgICAvKipcbiAgICAgKiBBbGxvdyBlbGVtZW50cyB0byBiZSByZXNpemVkIHRvIG5lZ2F0aXZlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmFsbG93TmVnYXRpdmVSZXNpemVzO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3VzZSBtb3ZlIHRocm90dGxlIGluIG1pbGxpc2Vjb25kcywgZGVmYXVsdDogNTAgbXNcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLm1vdXNlTW92ZVRocm90dGxlTVM7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgYW5kIGEgcmVzaXplIGV2ZW50IGlzIGFib3V0IHRvIGJlZ2luLiBgJGV2ZW50YCBpcyBhIGBSZXNpemVFdmVudGAgb2JqZWN0LlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUucmVzaXplU3RhcnQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFzIHRoZSBtb3VzZSBpcyBkcmFnZ2VkIGFmdGVyIGEgcmVzaXplIGV2ZW50IGhhcyBiZWd1bi4gYCRldmVudGAgaXMgYSBgUmVzaXplRXZlbnRgIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlc2l6aW5nO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgbW91c2UgaXMgcmVsZWFzZWQgYWZ0ZXIgYSByZXNpemUgZXZlbnQuIGAkZXZlbnRgIGlzIGEgYFJlc2l6ZUV2ZW50YCBvYmplY3QuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVFbmQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubW91c2V1cDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5tb3VzZWRvd247XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubW91c2Vtb3ZlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5wb2ludGVyRXZlbnRMaXN0ZW5lcnM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRlc3Ryb3kkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVzaXphYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNpemVFZGdlcyQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnBsYXRmb3JtSWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlbmRlcmVyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBSZXNpemFibGVEaXJlY3RpdmUucHJvdG90eXBlLmVsbTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlc2l6YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuem9uZTtcbn1cbnZhciBQb2ludGVyRXZlbnRMaXN0ZW5lcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9pbnRlckV2ZW50TGlzdGVuZXJzKHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd24gPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB1bnN1YnNjcmliZU1vdXNlRG93bjtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB1bnN1YnNjcmliZVRvdWNoU3RhcnQ7XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlRG93biA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVRvdWNoU3RhcnQgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlTW91c2VEb3duKCk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodW5zdWJzY3JpYmVUb3VjaFN0YXJ0KSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5waXBlKHNoYXJlKCkpO1xuICAgICAgICB0aGlzLnBvaW50ZXJNb3ZlID0gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmVNb3VzZU1vdmU7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmVUb3VjaE1vdmU7XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlTW92ZSA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSkge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVRvdWNoTW92ZSA9IHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlTW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChJU19UT1VDSF9ERVZJQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHVuc3Vic2NyaWJlVG91Y2hNb3ZlKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5waXBlKHNoYXJlKCkpO1xuICAgICAgICB0aGlzLnBvaW50ZXJVcCA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlTW91c2VVcDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB1bnN1YnNjcmliZVRvdWNoRW5kO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlVG91Y2hDYW5jZWw7XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1vdXNlVXAgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ21vdXNldXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoSVNfVE9VQ0hfREVWSUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlVG91Y2hFbmQgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlVG91Y2hDYW5jZWwgPSByZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ3RvdWNoY2FuY2VsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlTW91c2VVcCgpO1xuICAgICAgICAgICAgICAgIGlmIChJU19UT1VDSF9ERVZJQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHVuc3Vic2NyaWJlVG91Y2hFbmQpKSgpO1xuICAgICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodW5zdWJzY3JpYmVUb3VjaENhbmNlbCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IHpvbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBvaW50ZXJFdmVudExpc3RlbmVycy5nZXRJbnN0YW5jZSA9IFxuICAgIC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSB6b25lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVuZGVyZXIsIHpvbmUpIHtcbiAgICAgICAgaWYgKCFQb2ludGVyRXZlbnRMaXN0ZW5lcnMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIFBvaW50ZXJFdmVudExpc3RlbmVycy5pbnN0YW5jZSA9IG5ldyBQb2ludGVyRXZlbnRMaXN0ZW5lcnMocmVuZGVyZXIsIHpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb2ludGVyRXZlbnRMaXN0ZW5lcnMuaW5zdGFuY2U7XG4gICAgfTtcbiAgICByZXR1cm4gUG9pbnRlckV2ZW50TGlzdGVuZXJzO1xufSgpKTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9pbnRlckV2ZW50TGlzdGVuZXJzLmluc3RhbmNlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJEb3duO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJNb3ZlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQb2ludGVyRXZlbnRMaXN0ZW5lcnMucHJvdG90eXBlLnBvaW50ZXJVcDtcbn1cbiJdfQ==