import { __decorate } from "tslib";
import { Component, Input, ElementRef, OnInit, PipeTransform, Pipe, ViewEncapsulation, OnDestroy } from '@angular/core';
import { VgAPI } from '../../core/services/vg-api';
// Workaround until we can use UTC with Angular Date Pipe
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function VgTimeDisplay_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, "LIVE");
    ɵngcc0.ɵɵelementEnd();
} }
function VgTimeDisplay_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "vgUtc");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r239 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(2, 1, ctx_r239.getTime(), ctx_r239.vgFormat));
} }
var _c0 = ["*"];
var VgUtcPipe = /** @class */ (function () {
    function VgUtcPipe() {
    }
    VgUtcPipe.prototype.transform = function (value, format) {
        var date = new Date(value);
        var result = format;
        var ss = date.getUTCSeconds();
        var mm = date.getUTCMinutes();
        var hh = date.getUTCHours();
        if (ss < 10) {
            ss = '0' + ss;
        }
        if (mm < 10) {
            mm = '0' + mm;
        }
        if (hh < 10) {
            hh = '0' + hh;
        }
        result = result.replace(/ss/g, ss);
        result = result.replace(/mm/g, mm);
        result = result.replace(/hh/g, hh);
        return result;
    };
VgUtcPipe.ɵfac = function VgUtcPipe_Factory(t) { return new (t || VgUtcPipe)(); };
VgUtcPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "vgUtc", type: VgUtcPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VgUtcPipe, [{
        type: Pipe,
        args: [{ name: 'vgUtc' }]
    }], function () { return []; }, null); })();
    return VgUtcPipe;
}());
export { VgUtcPipe };
// tslint:disable:component-class-suffix
var VgTimeDisplay = /** @class */ (function () {
    function VgTimeDisplay(ref, API) {
        this.API = API;
        this.vgProperty = 'current';
        this.vgFormat = 'mm:ss';
        this.subscriptions = [];
        this.elem = ref.nativeElement;
    }
    VgTimeDisplay.prototype.ngOnInit = function () {
        var _this = this;
        if (this.API.isPlayerReady) {
            this.onPlayerReady();
        }
        else {
            this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
        }
    };
    VgTimeDisplay.prototype.onPlayerReady = function () {
        this.target = this.API.getMediaById(this.vgFor);
    };
    VgTimeDisplay.prototype.getTime = function () {
        var t = 0;
        if (this.target) {
            t = Math.round(this.target.time[this.vgProperty]);
            t = isNaN(t) || this.target.isLive ? 0 : t;
        }
        return t;
    };
    VgTimeDisplay.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
    };
    VgTimeDisplay.ctorParameters = function () { return [
        { type: ElementRef },
        { type: VgAPI }
    ]; };
    __decorate([
        Input()
    ], VgTimeDisplay.prototype, "vgFor", void 0);
    __decorate([
        Input()
    ], VgTimeDisplay.prototype, "vgProperty", void 0);
    __decorate([
        Input()
    ], VgTimeDisplay.prototype, "vgFormat", void 0);
VgTimeDisplay.ɵfac = function VgTimeDisplay_Factory(t) { return new (t || VgTimeDisplay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(VgAPI)); };
VgTimeDisplay.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: VgTimeDisplay, selectors: [["vg-time-display"]], inputs: { vgProperty: "vgProperty", vgFormat: "vgFormat", vgFor: "vgFor" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [[4, "ngIf"]], template: function VgTimeDisplay_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, VgTimeDisplay_span_0_Template, 2, 0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, VgTimeDisplay_span_1_Template, 3, 4, "span", 0);
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.target == null ? null : ctx.target.isLive);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.target == null ? null : ctx.target.isLive));
    } }, directives: [ɵngcc1.NgIf], pipes: [VgUtcPipe], styles: ["\n        vg-time-display {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 60px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            pointer-events: none;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n    "], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VgTimeDisplay, [{
        type: Component,
        args: [{
                selector: 'vg-time-display',
                encapsulation: ViewEncapsulation.None,
                template: "\n        <span *ngIf=\"target?.isLive\">LIVE</span>\n        <span *ngIf=\"!target?.isLive\">{{ getTime() | vgUtc:vgFormat }}</span>\n        <ng-content></ng-content>\n    ",
                styles: ["\n        vg-time-display {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 60px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            pointer-events: none;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n    "]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: VgAPI }]; }, { vgProperty: [{
            type: Input
        }], vgFormat: [{
            type: Input
        }], vgFor: [{
            type: Input
        }] }); })();
    return VgTimeDisplay;
}());
export { VgTimeDisplay };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LXZpZGVvZ3VsYXIvZXNtNS9saWIvY29udHJvbHMvdmctdGltZS1kaXNwbGF5L3ZnLXRpbWUtZGlzcGxheS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXNCTTs7Ozs7O2dEQUdZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBZ0RrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUTlCIiwiZmlsZSI6InZnLXRpbWUtZGlzcGxheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEVsZW1lbnRSZWYsIE9uSW5pdCwgUGlwZVRyYW5zZm9ybSwgUGlwZSwgVmlld0VuY2Fwc3VsYXRpb24sIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmdBUEkgfSBmcm9tICcuLi8uLi9jb3JlL3NlcnZpY2VzL3ZnLWFwaSc7XG4vLyBXb3JrYXJvdW5kIHVudGlsIHdlIGNhbiB1c2UgVVRDIHdpdGggQW5ndWxhciBEYXRlIFBpcGVcbnZhciBWZ1V0Y1BpcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmdVdGNQaXBlKCkge1xuICAgIH1cbiAgICBWZ1V0Y1BpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm9ybWF0O1xuICAgICAgICB2YXIgc3MgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgdmFyIG1tID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgIHZhciBoaCA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgaWYgKHNzIDwgMTApIHtcbiAgICAgICAgICAgIHNzID0gJzAnICsgc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1tIDwgMTApIHtcbiAgICAgICAgICAgIG1tID0gJzAnICsgbW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhoIDwgMTApIHtcbiAgICAgICAgICAgIGhoID0gJzAnICsgaGg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL3NzL2csIHNzKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL21tL2csIG1tKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL2hoL2csIGhoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFZnVXRjUGlwZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBQaXBlKHsgbmFtZTogJ3ZnVXRjJyB9KVxuICAgIF0sIFZnVXRjUGlwZSk7XG4gICAgcmV0dXJuIFZnVXRjUGlwZTtcbn0oKSk7XG5leHBvcnQgeyBWZ1V0Y1BpcGUgfTtcbi8vIHRzbGludDpkaXNhYmxlOmNvbXBvbmVudC1jbGFzcy1zdWZmaXhcbnZhciBWZ1RpbWVEaXNwbGF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZnVGltZURpc3BsYXkocmVmLCBBUEkpIHtcbiAgICAgICAgdGhpcy5BUEkgPSBBUEk7XG4gICAgICAgIHRoaXMudmdQcm9wZXJ0eSA9ICdjdXJyZW50JztcbiAgICAgICAgdGhpcy52Z0Zvcm1hdCA9ICdtbTpzcyc7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmVsZW0gPSByZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgVmdUaW1lRGlzcGxheS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLkFQSS5pc1BsYXllclJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9uUGxheWVyUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuQVBJLnBsYXllclJlYWR5RXZlbnQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uUGxheWVyUmVhZHkoKTsgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5vblBsYXllclJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuQVBJLmdldE1lZGlhQnlJZCh0aGlzLnZnRm9yKTtcbiAgICB9O1xuICAgIFZnVGltZURpc3BsYXkucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5yb3VuZCh0aGlzLnRhcmdldC50aW1lW3RoaXMudmdQcm9wZXJ0eV0pO1xuICAgICAgICAgICAgdCA9IGlzTmFOKHQpIHx8IHRoaXMudGFyZ2V0LmlzTGl2ZSA/IDAgOiB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgVmdUaW1lRGlzcGxheS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgVmdUaW1lRGlzcGxheS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogVmdBUEkgfVxuICAgIF07IH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBWZ1RpbWVEaXNwbGF5LnByb3RvdHlwZSwgXCJ2Z0ZvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgVmdUaW1lRGlzcGxheS5wcm90b3R5cGUsIFwidmdQcm9wZXJ0eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgVmdUaW1lRGlzcGxheS5wcm90b3R5cGUsIFwidmdGb3JtYXRcIiwgdm9pZCAwKTtcbiAgICBWZ1RpbWVEaXNwbGF5ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3ZnLXRpbWUtZGlzcGxheScsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8c3BhbiAqbmdJZj1cXFwidGFyZ2V0Py5pc0xpdmVcXFwiPkxJVkU8L3NwYW4+XFxuICAgICAgICA8c3BhbiAqbmdJZj1cXFwiIXRhcmdldD8uaXNMaXZlXFxcIj57eyBnZXRUaW1lKCkgfCB2Z1V0Yzp2Z0Zvcm1hdCB9fTwvc3Bhbj5cXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIlxcbiAgICAgICAgdmctdGltZS1kaXNwbGF5IHtcXG4gICAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgICAgICAgIGhlaWdodDogNTBweDtcXG4gICAgICAgICAgICB3aWR0aDogNjBweDtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgICAgY29sb3I6IHdoaXRlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiA1MHB4O1xcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gICAgICAgIH1cXG4gICAgXCJdXG4gICAgICAgIH0pXG4gICAgXSwgVmdUaW1lRGlzcGxheSk7XG4gICAgcmV0dXJuIFZnVGltZURpc3BsYXk7XG59KCkpO1xuZXhwb3J0IHsgVmdUaW1lRGlzcGxheSB9O1xuIl19