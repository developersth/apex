import { __decorate } from "tslib";
import { Directive, ElementRef, EventEmitter, OnDestroy, OnInit, Output, DoCheck } from '@angular/core';
import { VgEvents } from '../events/vg-events';
import { fromEvent } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
let VgCuePoints = 
// tslint:disable-next-line:directive-class-suffix
class VgCuePoints {
    constructor(ref) {
        this.ref = ref;
        // tslint:disable:no-output-on-prefix
        this.onEnterCuePoint = new EventEmitter();
        this.onUpdateCuePoint = new EventEmitter();
        this.onExitCuePoint = new EventEmitter();
        this.onCompleteCuePoint = new EventEmitter();
        this.subscriptions = [];
        this.cuesSubscriptions = [];
        this.totalCues = 0;
    }
    ngOnInit() {
        this.onLoad$ = fromEvent(this.ref.nativeElement, VgEvents.VG_LOAD);
        this.subscriptions.push(this.onLoad$.subscribe(this.onLoad.bind(this)));
    }
    onLoad(event) {
        if (event.target && event.target.track) {
            const cues = event.target.track.cues;
            this.ref.nativeElement.cues = cues;
            this.updateCuePoints(cues);
        }
        else if (event.target && event.target.textTracks && event.target.textTracks.length) {
            const cues = event.target.textTracks[0].cues;
            this.ref.nativeElement.cues = cues;
            this.updateCuePoints(cues);
        }
    }
    updateCuePoints(cues) {
        this.cuesSubscriptions.forEach(s => s.unsubscribe());
        for (let i = 0, l = cues.length; i < l; i++) {
            this.onEnter$ = fromEvent(cues[i], VgEvents.VG_ENTER);
            this.cuesSubscriptions.push(this.onEnter$.subscribe(this.onEnter.bind(this)));
            this.onExit$ = fromEvent(cues[i], VgEvents.VG_EXIT);
            this.cuesSubscriptions.push(this.onExit$.subscribe(this.onExit.bind(this)));
        }
    }
    onEnter(event) {
        this.onEnterCuePoint.emit(event.target);
    }
    onExit(event) {
        this.onExitCuePoint.emit(event.target);
    }
    ngDoCheck() {
        if (this.ref.nativeElement.track && this.ref.nativeElement.track.cues) {
            const changes = this.totalCues !== this.ref.nativeElement.track.cues.length;
            if (changes) {
                this.totalCues = this.ref.nativeElement.track.cues.length;
                this.ref.nativeElement.cues = this.ref.nativeElement.track.cues;
                this.updateCuePoints(this.ref.nativeElement.track.cues);
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
    }
};
VgCuePoints.ɵfac = function VgCuePoints_Factory(t) { return new (t || VgCuePoints)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
VgCuePoints.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VgCuePoints, selectors: [["", "vgCuePoints", ""]], outputs: { onEnterCuePoint: "onEnterCuePoint", onUpdateCuePoint: "onUpdateCuePoint", onExitCuePoint: "onExitCuePoint", onCompleteCuePoint: "onCompleteCuePoint" } });
VgCuePoints.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output()
], VgCuePoints.prototype, "onEnterCuePoint", void 0);
__decorate([
    Output()
], VgCuePoints.prototype, "onUpdateCuePoint", void 0);
__decorate([
    Output()
], VgCuePoints.prototype, "onExitCuePoint", void 0);
__decorate([
    Output()
], VgCuePoints.prototype, "onCompleteCuePoint", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VgCuePoints, [{
        type: Directive,
        args: [{
                selector: '[vgCuePoints]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onEnterCuePoint: [{
            type: Output
        }], onUpdateCuePoint: [{
            type: Output
        }], onExitCuePoint: [{
            type: Output
        }], onCompleteCuePoint: [{
            type: Output
        }] }); })();
export { VgCuePoints };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LXZpZGVvZ3VsYXIvZXNtMjAxNS9saWIvY29yZS92Zy1jdWUtcG9pbnRzL3ZnLWN1ZS1wb2ludHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0UUEwREU7Ozs7Ozs7Ozs7Ozs7Ozt3REFlc0Q7Ozs7Ozs7Ozs7Ozs7O29CQU14QyIsImZpbGUiOiJ2Zy1jdWUtcG9pbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIERvQ2hlY2sgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZnRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzL3ZnLWV2ZW50cyc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbmxldCBWZ0N1ZVBvaW50cyA9IFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbmNsYXNzIFZnQ3VlUG9pbnRzIHtcbiAgICBjb25zdHJ1Y3RvcihyZWYpIHtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLW91dHB1dC1vbi1wcmVmaXhcbiAgICAgICAgdGhpcy5vbkVudGVyQ3VlUG9pbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25VcGRhdGVDdWVQb2ludCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkV4aXRDdWVQb2ludCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlQ3VlUG9pbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmN1ZXNTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMudG90YWxDdWVzID0gMDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMub25Mb2FkJCA9IGZyb21FdmVudCh0aGlzLnJlZi5uYXRpdmVFbGVtZW50LCBWZ0V2ZW50cy5WR19MT0FEKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5vbkxvYWQkLnN1YnNjcmliZSh0aGlzLm9uTG9hZC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG9uTG9hZChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC50cmFjaykge1xuICAgICAgICAgICAgY29uc3QgY3VlcyA9IGV2ZW50LnRhcmdldC50cmFjay5jdWVzO1xuICAgICAgICAgICAgdGhpcy5yZWYubmF0aXZlRWxlbWVudC5jdWVzID0gY3VlcztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VlUG9pbnRzKGN1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQudGV4dFRyYWNrcyAmJiBldmVudC50YXJnZXQudGV4dFRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1ZXMgPSBldmVudC50YXJnZXQudGV4dFRyYWNrc1swXS5jdWVzO1xuICAgICAgICAgICAgdGhpcy5yZWYubmF0aXZlRWxlbWVudC5jdWVzID0gY3VlcztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VlUG9pbnRzKGN1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUN1ZVBvaW50cyhjdWVzKSB7XG4gICAgICAgIHRoaXMuY3Vlc1N1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMub25FbnRlciQgPSBmcm9tRXZlbnQoY3Vlc1tpXSwgVmdFdmVudHMuVkdfRU5URVIpO1xuICAgICAgICAgICAgdGhpcy5jdWVzU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMub25FbnRlciQuc3Vic2NyaWJlKHRoaXMub25FbnRlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICB0aGlzLm9uRXhpdCQgPSBmcm9tRXZlbnQoY3Vlc1tpXSwgVmdFdmVudHMuVkdfRVhJVCk7XG4gICAgICAgICAgICB0aGlzLmN1ZXNTdWJzY3JpcHRpb25zLnB1c2godGhpcy5vbkV4aXQkLnN1YnNjcmliZSh0aGlzLm9uRXhpdC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FbnRlcihldmVudCkge1xuICAgICAgICB0aGlzLm9uRW50ZXJDdWVQb2ludC5lbWl0KGV2ZW50LnRhcmdldCk7XG4gICAgfVxuICAgIG9uRXhpdChldmVudCkge1xuICAgICAgICB0aGlzLm9uRXhpdEN1ZVBvaW50LmVtaXQoZXZlbnQudGFyZ2V0KTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5yZWYubmF0aXZlRWxlbWVudC50cmFjayAmJiB0aGlzLnJlZi5uYXRpdmVFbGVtZW50LnRyYWNrLmN1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLnRvdGFsQ3VlcyAhPT0gdGhpcy5yZWYubmF0aXZlRWxlbWVudC50cmFjay5jdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbEN1ZXMgPSB0aGlzLnJlZi5uYXRpdmVFbGVtZW50LnRyYWNrLmN1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuY3VlcyA9IHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQudHJhY2suY3VlcztcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1ZVBvaW50cyh0aGlzLnJlZi5uYXRpdmVFbGVtZW50LnRyYWNrLmN1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxufTtcblZnQ3VlUG9pbnRzLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFZnQ3VlUG9pbnRzLnByb3RvdHlwZSwgXCJvbkVudGVyQ3VlUG9pbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpXG5dLCBWZ0N1ZVBvaW50cy5wcm90b3R5cGUsIFwib25VcGRhdGVDdWVQb2ludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFZnQ3VlUG9pbnRzLnByb3RvdHlwZSwgXCJvbkV4aXRDdWVQb2ludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFZnQ3VlUG9pbnRzLnByb3RvdHlwZSwgXCJvbkNvbXBsZXRlQ3VlUG9pbnRcIiwgdm9pZCAwKTtcblZnQ3VlUG9pbnRzID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbdmdDdWVQb2ludHNdJ1xuICAgIH0pXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbl0sIFZnQ3VlUG9pbnRzKTtcbmV4cG9ydCB7IFZnQ3VlUG9pbnRzIH07XG4iXX0=