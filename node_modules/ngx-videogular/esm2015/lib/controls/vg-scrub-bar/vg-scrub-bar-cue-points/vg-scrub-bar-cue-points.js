import { __decorate } from "tslib";
import { Component, ElementRef, Input, OnChanges, OnDestroy, OnInit, DoCheck, SimpleChange, ViewEncapsulation } from '@angular/core';
import { VgAPI } from '../../../core/services/vg-api';
// tslint:disable:no-conflicting-lifecycle
// tslint:disable:component-class-suffix
// tslint:disable:no-string-literal
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function VgScrubBarCuePoints_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    const cp_r666 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("width", cp_r666.$$style == null ? null : cp_r666.$$style.width)("left", cp_r666.$$style == null ? null : cp_r666.$$style.left);
} }
let VgScrubBarCuePoints = class VgScrubBarCuePoints {
    constructor(ref, API) {
        this.API = API;
        this.onLoadedMetadataCalled = false;
        this.cuePoints = [];
        this.subscriptions = [];
        this.totalCues = 0;
        this.elem = ref.nativeElement;
    }
    ngOnInit() {
        if (this.API.isPlayerReady) {
            this.onPlayerReady();
        }
        else {
            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));
        }
    }
    onPlayerReady() {
        this.target = this.API.getMediaById(this.vgFor);
        const onTimeUpdate = this.target.subscriptions.loadedMetadata;
        this.subscriptions.push(onTimeUpdate.subscribe(this.onLoadedMetadata.bind(this)));
        if (this.onLoadedMetadataCalled) {
            this.onLoadedMetadata();
        }
    }
    onLoadedMetadata() {
        if (this.vgCuePoints) {
            // We need to transform the TextTrackCueList to Array or it doesn't work on IE11/Edge.
            // See: https://github.com/videogular/videogular2/issues/369
            this.cuePoints = [];
            for (let i = 0, l = this.vgCuePoints.length; i < l; i++) {
                const end = (this.vgCuePoints[i].endTime >= 0) ? this.vgCuePoints[i].endTime : this.vgCuePoints[i].startTime + 1;
                const cuePointDuration = (end - this.vgCuePoints[i].startTime) * 1000;
                let position = '0';
                let percentWidth = '0';
                if (typeof cuePointDuration === 'number' && this.target.time.total) {
                    percentWidth = ((cuePointDuration * 100) / this.target.time.total) + '%';
                    position = (this.vgCuePoints[i].startTime * 100 / (Math.round(this.target.time.total / 1000))) + '%';
                }
                this.vgCuePoints[i].$$style = {
                    width: percentWidth,
                    left: position
                };
                this.cuePoints.push(this.vgCuePoints[i]);
            }
        }
    }
    updateCuePoints() {
        if (!this.target) {
            this.onLoadedMetadataCalled = true;
            return;
        }
        this.onLoadedMetadata();
    }
    ngOnChanges(changes) {
        if (changes['vgCuePoints'].currentValue) {
            this.updateCuePoints();
        }
    }
    ngDoCheck() {
        if (this.vgCuePoints) {
            const changes = this.totalCues !== this.vgCuePoints.length;
            if (changes) {
                this.totalCues = this.vgCuePoints.length;
                this.updateCuePoints();
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
    }
};
VgScrubBarCuePoints.ɵfac = function VgScrubBarCuePoints_Factory(t) { return new (t || VgScrubBarCuePoints)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(VgAPI)); };
VgScrubBarCuePoints.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: VgScrubBarCuePoints, selectors: [["vg-scrub-bar-cue-points"]], inputs: { vgCuePoints: "vgCuePoints", vgFor: "vgFor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 2, vars: 1, consts: [[1, "cue-point-container"], ["class", "cue-point", 3, "width", "left", 4, "ngFor", "ngForOf"], [1, "cue-point"]], template: function VgScrubBarCuePoints_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, VgScrubBarCuePoints_span_1_Template, 1, 4, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cuePoints);
    } }, directives: [ɵngcc1.NgForOf], styles: ["\n        vg-scrub-bar-cue-points {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-cue-points .cue-point-container .cue-point {\n            position: absolute;\n            height: 5px;\n            background-color: rgba(255, 204, 0, 0.7);\n        }\n        vg-controls vg-scrub-bar-cue-points {\n            position: absolute;\n            top: calc(50% - 3px);\n        }\n    "], encapsulation: 2 });
VgScrubBarCuePoints.ctorParameters = () => [
    { type: ElementRef },
    { type: VgAPI }
];
__decorate([
    Input()
], VgScrubBarCuePoints.prototype, "vgCuePoints", void 0);
__decorate([
    Input()
], VgScrubBarCuePoints.prototype, "vgFor", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VgScrubBarCuePoints, [{
        type: Component,
        args: [{
                selector: 'vg-scrub-bar-cue-points',
                encapsulation: ViewEncapsulation.None,
                template: `
        <div class="cue-point-container">
            <span *ngFor="let cp of cuePoints" [style.width]="cp.$$style?.width" [style.left]="cp.$$style?.left"
                  class="cue-point"></span>
        </div>
    `,
                styles: [`
        vg-scrub-bar-cue-points {
            display: flex;
            width: 100%;
            height: 5px;
            pointer-events: none;
            position: absolute;
        }
        vg-scrub-bar-cue-points .cue-point-container .cue-point {
            position: absolute;
            height: 5px;
            background-color: rgba(255, 204, 0, 0.7);
        }
        vg-controls vg-scrub-bar-cue-points {
            position: absolute;
            top: calc(50% - 3px);
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: VgAPI }]; }, { vgCuePoints: [{
            type: Input
        }], vgFor: [{
            type: Input
        }] }); })();
export { VgScrubBarCuePoints };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LXZpZGVvZ3VsYXIvZXNtMjAxNS9saWIvY29udHJvbHMvdmctc2NydWItYmFyL3ZnLXNjcnViLWJhci1jdWUtcG9pbnRzL3ZnLXNjcnViLWJhci1jdWUtcG9pbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K2tCQXVFRTs7Ozs7Ozs7OzttREFVaUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQThCM0IiLCJmaWxlIjoidmctc2NydWItYmFyLWN1ZS1wb2ludHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBEb0NoZWNrLCBTaW1wbGVDaGFuZ2UsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWZ0FQSSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvc2VydmljZXMvdmctYXBpJztcbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbmZsaWN0aW5nLWxpZmVjeWNsZVxuLy8gdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxuLy8gdHNsaW50OmRpc2FibGU6bm8tc3RyaW5nLWxpdGVyYWxcbmxldCBWZ1NjcnViQmFyQ3VlUG9pbnRzID0gY2xhc3MgVmdTY3J1YkJhckN1ZVBvaW50cyB7XG4gICAgY29uc3RydWN0b3IocmVmLCBBUEkpIHtcbiAgICAgICAgdGhpcy5BUEkgPSBBUEk7XG4gICAgICAgIHRoaXMub25Mb2FkZWRNZXRhZGF0YUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1ZVBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b3RhbEN1ZXMgPSAwO1xuICAgICAgICB0aGlzLmVsZW0gPSByZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLkFQSS5pc1BsYXllclJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9uUGxheWVyUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuQVBJLnBsYXllclJlYWR5RXZlbnQuc3Vic2NyaWJlKCgpID0+IHRoaXMub25QbGF5ZXJSZWFkeSgpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25QbGF5ZXJSZWFkeSgpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLkFQSS5nZXRNZWRpYUJ5SWQodGhpcy52Z0Zvcik7XG4gICAgICAgIGNvbnN0IG9uVGltZVVwZGF0ZSA9IHRoaXMudGFyZ2V0LnN1YnNjcmlwdGlvbnMubG9hZGVkTWV0YWRhdGE7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG9uVGltZVVwZGF0ZS5zdWJzY3JpYmUodGhpcy5vbkxvYWRlZE1ldGFkYXRhLmJpbmQodGhpcykpKTtcbiAgICAgICAgaWYgKHRoaXMub25Mb2FkZWRNZXRhZGF0YUNhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5vbkxvYWRlZE1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Mb2FkZWRNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmdDdWVQb2ludHMpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSBUZXh0VHJhY2tDdWVMaXN0IHRvIEFycmF5IG9yIGl0IGRvZXNuJ3Qgd29yayBvbiBJRTExL0VkZ2UuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2d1bGFyL3ZpZGVvZ3VsYXIyL2lzc3Vlcy8zNjlcbiAgICAgICAgICAgIHRoaXMuY3VlUG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMudmdDdWVQb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKHRoaXMudmdDdWVQb2ludHNbaV0uZW5kVGltZSA+PSAwKSA/IHRoaXMudmdDdWVQb2ludHNbaV0uZW5kVGltZSA6IHRoaXMudmdDdWVQb2ludHNbaV0uc3RhcnRUaW1lICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdWVQb2ludER1cmF0aW9uID0gKGVuZCAtIHRoaXMudmdDdWVQb2ludHNbaV0uc3RhcnRUaW1lKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gJzAnO1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50V2lkdGggPSAnMCc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdWVQb2ludER1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0aGlzLnRhcmdldC50aW1lLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRXaWR0aCA9ICgoY3VlUG9pbnREdXJhdGlvbiAqIDEwMCkgLyB0aGlzLnRhcmdldC50aW1lLnRvdGFsKSArICclJztcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAodGhpcy52Z0N1ZVBvaW50c1tpXS5zdGFydFRpbWUgKiAxMDAgLyAoTWF0aC5yb3VuZCh0aGlzLnRhcmdldC50aW1lLnRvdGFsIC8gMTAwMCkpKSArICclJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52Z0N1ZVBvaW50c1tpXS4kJHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGVyY2VudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jdWVQb2ludHMucHVzaCh0aGlzLnZnQ3VlUG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDdWVQb2ludHMoKSB7XG4gICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMub25Mb2FkZWRNZXRhZGF0YUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkxvYWRlZE1ldGFkYXRhKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ3ZnQ3VlUG9pbnRzJ10uY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUN1ZVBvaW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMudmdDdWVQb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLnRvdGFsQ3VlcyAhPT0gdGhpcy52Z0N1ZVBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWxDdWVzID0gdGhpcy52Z0N1ZVBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdWVQb2ludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbn07XG5WZ1NjcnViQmFyQ3VlUG9pbnRzLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogVmdBUEkgfVxuXTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFZnU2NydWJCYXJDdWVQb2ludHMucHJvdG90eXBlLCBcInZnQ3VlUG9pbnRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBWZ1NjcnViQmFyQ3VlUG9pbnRzLnByb3RvdHlwZSwgXCJ2Z0ZvclwiLCB2b2lkIDApO1xuVmdTY3J1YkJhckN1ZVBvaW50cyA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAndmctc2NydWItYmFyLWN1ZS1wb2ludHMnLFxuICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiY3VlLXBvaW50LWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPHNwYW4gKm5nRm9yPVwibGV0IGNwIG9mIGN1ZVBvaW50c1wiIFtzdHlsZS53aWR0aF09XCJjcC4kJHN0eWxlPy53aWR0aFwiIFtzdHlsZS5sZWZ0XT1cImNwLiQkc3R5bGU/LmxlZnRcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjdWUtcG9pbnRcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gICAgICAgIHN0eWxlczogW2BcbiAgICAgICAgdmctc2NydWItYmFyLWN1ZS1wb2ludHMge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgaGVpZ2h0OiA1cHg7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgfVxuICAgICAgICB2Zy1zY3J1Yi1iYXItY3VlLXBvaW50cyAuY3VlLXBvaW50LWNvbnRhaW5lciAuY3VlLXBvaW50IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIGhlaWdodDogNXB4O1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDIwNCwgMCwgMC43KTtcbiAgICAgICAgfVxuICAgICAgICB2Zy1jb250cm9scyB2Zy1zY3J1Yi1iYXItY3VlLXBvaW50cyB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IGNhbGMoNTAlIC0gM3B4KTtcbiAgICAgICAgfVxuICAgIGBdXG4gICAgfSlcbl0sIFZnU2NydWJCYXJDdWVQb2ludHMpO1xuZXhwb3J0IHsgVmdTY3J1YkJhckN1ZVBvaW50cyB9O1xuIl19