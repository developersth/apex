/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter, ElementRef, } from '@angular/core';
import * as chartJs from 'chart.js';
import { getColors } from './get-colors';
import { ThemeService } from './theme.service';
import { cloneDeep } from 'lodash';
/**
 * @record
 */
import * as Éµngcc0 from '@angular/core';
function OldState() { }
if (false) {
    /** @type {?} */
    OldState.prototype.dataExists;
    /** @type {?} */
    OldState.prototype.dataLength;
    /** @type {?} */
    OldState.prototype.datasetsExists;
    /** @type {?} */
    OldState.prototype.datasetsLength;
    /** @type {?} */
    OldState.prototype.datasetsDataObjects;
    /** @type {?} */
    OldState.prototype.datasetsDataLengths;
    /** @type {?} */
    OldState.prototype.colorsExists;
    /** @type {?} */
    OldState.prototype.colors;
    /** @type {?} */
    OldState.prototype.labelsExist;
    /** @type {?} */
    OldState.prototype.labels;
    /** @type {?} */
    OldState.prototype.legendExists;
    /** @type {?} */
    OldState.prototype.legend;
}
/** @enum {number} */
const UpdateType = {
    Default: 0,
    Update: 1,
    Refresh: 2,
};
UpdateType[UpdateType.Default] = 'Default';
UpdateType[UpdateType.Update] = 'Update';
UpdateType[UpdateType.Refresh] = 'Refresh';
export class BaseChartDirective {
    /**
     * @param {?} element
     * @param {?} themeService
     */
    constructor(element, themeService) {
        this.element = element;
        this.themeService = themeService;
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.old = {
            dataExists: false,
            dataLength: 0,
            datasetsExists: false,
            datasetsLength: 0,
            datasetsDataObjects: [],
            datasetsDataLengths: [],
            colorsExists: false,
            colors: [],
            labelsExist: false,
            labels: [],
            legendExists: false,
            legend: {},
        };
        this.subs = [];
    }
    /**
     * Register a plugin.
     * @param {?} plugin
     * @return {?}
     */
    static registerPlugin(plugin) {
        chartJs.Chart.plugins.register(plugin);
    }
    /**
     * @param {?} plugin
     * @return {?}
     */
    static unregisterPlugin(plugin) {
        chartJs.Chart.plugins.unregister(plugin);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d');
        this.refresh();
        this.subs.push(this.themeService.colorschemesOptions.subscribe((/**
         * @param {?} r
         * @return {?}
         */
        r => this.themeChanged(r))));
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    themeChanged(options) {
        this.refresh();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this.chart) {
            return;
        }
        /** @type {?} */
        let updateRequired = UpdateType.Default;
        /** @type {?} */
        const wantUpdate = (/**
         * @param {?} x
         * @return {?}
         */
        (x) => {
            updateRequired = x > updateRequired ? x : updateRequired;
        });
        if (!!this.data !== this.old.dataExists) {
            this.propagateDataToDatasets(this.data);
            this.old.dataExists = !!this.data;
            wantUpdate(UpdateType.Update);
        }
        if (this.data && this.data.length !== this.old.dataLength) {
            this.old.dataLength = this.data && this.data.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (!!this.datasets !== this.old.datasetsExists) {
            this.old.datasetsExists = !!this.datasets;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.length !== this.old.datasetsLength) {
            this.old.datasetsLength = this.datasets && this.datasets.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        (x, i) => x.data !== this.old.datasetsDataObjects[i])).length) {
            this.old.datasetsDataObjects = this.datasets.map((/**
             * @param {?} x
             * @return {?}
             */
            x => x.data));
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        (x, i) => x.data.length !== this.old.datasetsDataLengths[i])).length) {
            this.old.datasetsDataLengths = this.datasets.map((/**
             * @param {?} x
             * @return {?}
             */
            x => x.data.length));
            wantUpdate(UpdateType.Update);
        }
        if (!!this.colors !== this.old.colorsExists) {
            this.old.colorsExists = !!this.colors;
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        // This smells of inefficiency, might need to revisit this
        if (this.colors && this.colors.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        (x, i) => !this.colorsEqual(x, this.old.colors[i]))).length) {
            this.old.colors = this.colors.map((/**
             * @param {?} x
             * @return {?}
             */
            x => this.copyColor(x)));
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        if (!!this.labels !== this.old.labelsExist) {
            this.old.labelsExist = !!this.labels;
            wantUpdate(UpdateType.Update);
        }
        if (this.labels && this.labels.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        (x, i) => !this.labelsEqual(x, this.old.labels[i]))).length) {
            this.old.labels = this.labels.map((/**
             * @param {?} x
             * @return {?}
             */
            x => this.copyLabel(x)));
            wantUpdate(UpdateType.Update);
        }
        if (!!this.options.legend !== this.old.legendExists) {
            this.old.legendExists = !!this.options.legend;
            wantUpdate(UpdateType.Refresh);
        }
        if (this.options.legend && this.options.legend.position !== this.old.legend.position) {
            this.old.legend.position = this.options.legend.position;
            wantUpdate(UpdateType.Refresh);
        }
        switch ((/** @type {?} */ (updateRequired))) {
            case UpdateType.Default:
                break;
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
                this.refresh();
                break;
        }
    }
    /**
     * @param {?} a
     * @return {?}
     */
    copyLabel(a) {
        if (Array.isArray(a)) {
            return [...a];
        }
        return a;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    labelsEqual(a, b) {
        return true
            && Array.isArray(a) === Array.isArray(b)
            && (Array.isArray(a) || a === b)
            && (!Array.isArray(a) || a.length === b.length)
            && (!Array.isArray(a) || a.filter((/**
             * @param {?} x
             * @param {?} i
             * @return {?}
             */
            (x, i) => x !== b[i])).length === 0);
    }
    /**
     * @param {?} a
     * @return {?}
     */
    copyColor(a) {
        /** @type {?} */
        const rc = {
            backgroundColor: a.backgroundColor,
            borderWidth: a.borderWidth,
            borderColor: a.borderColor,
            borderCapStyle: a.borderCapStyle,
            borderDash: a.borderDash,
            borderDashOffset: a.borderDashOffset,
            borderJoinStyle: a.borderJoinStyle,
            pointBorderColor: a.pointBorderColor,
            pointBackgroundColor: a.pointBackgroundColor,
            pointBorderWidth: a.pointBorderWidth,
            pointRadius: a.pointRadius,
            pointHoverRadius: a.pointHoverRadius,
            pointHitRadius: a.pointHitRadius,
            pointHoverBackgroundColor: a.pointHoverBackgroundColor,
            pointHoverBorderColor: a.pointHoverBorderColor,
            pointHoverBorderWidth: a.pointHoverBorderWidth,
            pointStyle: a.pointStyle,
            hoverBackgroundColor: a.hoverBackgroundColor,
            hoverBorderColor: a.hoverBorderColor,
            hoverBorderWidth: a.hoverBorderWidth,
        };
        return rc;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    colorsEqual(a, b) {
        if (!a !== !b) {
            return false;
        }
        return !a || true
            && (a.backgroundColor === b.backgroundColor)
            && (a.borderWidth === b.borderWidth)
            && (a.borderColor === b.borderColor)
            && (a.borderCapStyle === b.borderCapStyle)
            && (a.borderDash === b.borderDash)
            && (a.borderDashOffset === b.borderDashOffset)
            && (a.borderJoinStyle === b.borderJoinStyle)
            && (a.pointBorderColor === b.pointBorderColor)
            && (a.pointBackgroundColor === b.pointBackgroundColor)
            && (a.pointBorderWidth === b.pointBorderWidth)
            && (a.pointRadius === b.pointRadius)
            && (a.pointHoverRadius === b.pointHoverRadius)
            && (a.pointHitRadius === b.pointHitRadius)
            && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)
            && (a.pointHoverBorderColor === b.pointHoverBorderColor)
            && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)
            && (a.pointStyle === b.pointStyle)
            && (a.hoverBackgroundColor === b.hoverBackgroundColor)
            && (a.hoverBorderColor === b.hoverBorderColor)
            && (a.hoverBorderWidth === b.hoverBorderWidth);
    }
    /**
     * @return {?}
     */
    updateColors() {
        this.datasets.forEach((/**
         * @param {?} elm
         * @param {?} index
         * @return {?}
         */
        (elm, index) => {
            if (this.colors && this.colors[index]) {
                Object.assign(elm, this.colors[index]);
            }
            else {
                Object.assign(elm, getColors(this.chartType, index, elm.data.length), Object.assign({}, elm));
            }
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        let updateRequired = UpdateType.Default;
        /** @type {?} */
        const wantUpdate = (/**
         * @param {?} x
         * @return {?}
         */
        (x) => {
            updateRequired = x > updateRequired ? x : updateRequired;
        });
        // Check if the changes are in the data or datasets or labels or legend
        if (changes.hasOwnProperty('data') && changes.data.currentValue) {
            this.propagateDataToDatasets(changes.data.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {
            this.propagateDatasetsToData(changes.datasets.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('labels')) {
            if (this.chart) {
                this.chart.data.labels = changes.labels.currentValue;
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('legend')) {
            if (this.chart) {
                this.chart.config.options.legend.display = changes.legend.currentValue;
                this.chart.generateLegend();
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('options')) {
            wantUpdate(UpdateType.Refresh);
        }
        switch ((/** @type {?} */ (updateRequired))) {
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
            case UpdateType.Default:
                this.refresh();
                break;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.subs.forEach((/**
         * @param {?} x
         * @return {?}
         */
        x => x.unsubscribe()));
    }
    /**
     * @param {?=} duration
     * @param {?=} lazy
     * @return {?}
     */
    update(duration, lazy) {
        if (this.chart) {
            return this.chart.update(duration, lazy);
        }
    }
    /**
     * @param {?} index
     * @param {?} hidden
     * @return {?}
     */
    hideDataset(index, hidden) {
        this.chart.getDatasetMeta(index).hidden = hidden;
        this.chart.update();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    isDatasetHidden(index) {
        return this.chart.getDatasetMeta(index).hidden;
    }
    /**
     * @return {?}
     */
    toBase64Image() {
        return this.chart.toBase64Image();
    }
    /**
     * @return {?}
     */
    getChartConfiguration() {
        /** @type {?} */
        const datasets = this.getDatasets();
        /** @type {?} */
        const options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hook for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?=} event
             * @param {?=} active
             * @return {?}
             */
            (event, active) => {
                this.chartClick.emit({ event, active });
            });
        }
        /** @type {?} */
        const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
        /** @type {?} */
        const chartConfig = {
            type: this.chartType,
            data: {
                labels: this.labels || [],
                datasets
            },
            plugins: this.plugins,
            options: mergedOptions,
        };
        return chartConfig;
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getChartBuilder(ctx /*, data:any[], options:any*/) {
        /** @type {?} */
        const chartConfig = this.getChartConfiguration();
        return new chartJs.Chart(ctx, chartConfig);
    }
    /**
     * @param {?} options
     * @param {?} overrides
     * @param {?=} level
     * @return {?}
     */
    smartMerge(options, overrides, level = 0) {
        if (level === 0) {
            options = cloneDeep(options);
        }
        /** @type {?} */
        const keysToUpdate = Object.keys(overrides);
        keysToUpdate.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (Array.isArray(overrides[key])) {
                /** @type {?} */
                const arrayElements = options[key];
                if (arrayElements) {
                    arrayElements.forEach((/**
                     * @param {?} r
                     * @return {?}
                     */
                    r => {
                        this.smartMerge(r, overrides[key][0], level + 1);
                    }));
                }
            }
            else if (typeof (overrides[key]) === 'object') {
                if (!(key in options)) {
                    options[key] = {};
                }
                this.smartMerge(options[key], overrides[key], level + 1);
            }
            else {
                options[key] = overrides[key];
            }
        }));
        if (level === 0) {
            return options;
        }
    }
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    isMultiLineLabel(label) {
        return Array.isArray(label);
    }
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    joinLabel(label) {
        if (!label) {
            return null;
        }
        if (this.isMultiLineLabel(label)) {
            return label.join(' ');
        }
        else {
            return label;
        }
    }
    /**
     * @private
     * @param {?} datasets
     * @return {?}
     */
    propagateDatasetsToData(datasets) {
        this.data = this.datasets.map((/**
         * @param {?} r
         * @return {?}
         */
        r => r.data));
        if (this.chart) {
            this.chart.data.datasets = datasets;
        }
        this.updateColors();
    }
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    propagateDataToDatasets(newDataValues) {
        if (this.isMultiDataSet(newDataValues)) {
            if (this.datasets && newDataValues.length === this.datasets.length) {
                this.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                (dataset, i) => {
                    dataset.data = newDataValues[i];
                }));
            }
            else {
                this.datasets = newDataValues.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.joinLabel(this.labels[index]) || `Label ${index}` };
                }));
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
        }
        else {
            if (!this.datasets) {
                this.datasets = [{ data: newDataValues }];
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
            else {
                this.datasets[0].data = newDataValues;
                this.datasets.splice(1); // Remove all elements but the first
            }
        }
        this.updateColors();
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    isMultiDataSet(data) {
        return Array.isArray(data[0]);
    }
    /**
     * @private
     * @return {?}
     */
    getDatasets() {
        if (!this.datasets && !this.data) {
            throw new Error(`ng-charts configuration error, data or datasets field are required to render chart ${this.chartType}`);
        }
        // If `datasets` is defined, use it over the `data` property.
        if (this.datasets) {
            this.propagateDatasetsToData(this.datasets);
            return this.datasets;
        }
        if (this.data) {
            this.propagateDataToDatasets(this.data);
            return this.datasets;
        }
    }
    /**
     * @private
     * @return {?}
     */
    refresh() {
        // if (this.options && this.options.responsive) {
        //   setTimeout(() => this.refresh(), 50);
        // }
        // todo: remove this line, it is producing flickering
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        if (this.ctx) {
            this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
        }
    }
}
BaseChartDirective.Éµfac = function BaseChartDirective_Factory(t) { return new (t || BaseChartDirective)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(ThemeService)); };
BaseChartDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({ type: BaseChartDirective, selectors: [["canvas", "baseChart", ""]], inputs: { options: "options", data: "data", datasets: "datasets", labels: "labels", chartType: "chartType", colors: "colors", legend: "legend", plugins: "plugins" }, outputs: { chartClick: "chartClick", chartHover: "chartHover" }, exportAs: ["base-chart"], features: [Éµngcc0.ÉµÉµNgOnChangesFeature()] });
/** @nocollapse */
BaseChartDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThemeService }
];
BaseChartDirective.propDecorators = {
    data: [{ type: Input }],
    datasets: [{ type: Input }],
    labels: [{ type: Input }],
    options: [{ type: Input }],
    chartType: [{ type: Input }],
    colors: [{ type: Input }],
    legend: [{ type: Input }],
    plugins: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }]
};
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(BaseChartDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'canvas[baseChart]',
                exportAs: 'base-chart'
            }]
    }], function () { return [{ type: Éµngcc0.ElementRef }, { type: ThemeService }]; }, { options: [{
            type: Input
        }], chartClick: [{
            type: Output
        }], chartHover: [{
            type: Output
        }], data: [{
            type: Input
        }], datasets: [{
            type: Input
        }], labels: [{
            type: Input
        }], chartType: [{
            type: Input
        }], colors: [{
            type: Input
        }], legend: [{
            type: Input
        }], plugins: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    BaseChartDirective.prototype.data;
    /** @type {?} */
    BaseChartDirective.prototype.datasets;
    /** @type {?} */
    BaseChartDirective.prototype.labels;
    /** @type {?} */
    BaseChartDirective.prototype.options;
    /** @type {?} */
    BaseChartDirective.prototype.chartType;
    /** @type {?} */
    BaseChartDirective.prototype.colors;
    /** @type {?} */
    BaseChartDirective.prototype.legend;
    /** @type {?} */
    BaseChartDirective.prototype.plugins;
    /** @type {?} */
    BaseChartDirective.prototype.chartClick;
    /** @type {?} */
    BaseChartDirective.prototype.chartHover;
    /** @type {?} */
    BaseChartDirective.prototype.ctx;
    /** @type {?} */
    BaseChartDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.old;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.subs;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.themeService;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmcyLWNoYXJ0cy9lc20yMDE1L2xpYi9iYXNlLWNoYXJ0LmRpcmVjdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdW9CQyxzYUFPQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWlCQSIsImZpbGUiOiJiYXNlLWNoYXJ0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBjaGFydEpzIGZyb20gJ2NoYXJ0LmpzJztcclxuaW1wb3J0IHsgZ2V0Q29sb3JzIH0gZnJvbSAnLi9nZXQtY29sb3JzJztcclxuaW1wb3J0IHsgVGhlbWVTZXJ2aWNlIH0gZnJvbSAnLi90aGVtZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIE9sZFN0YXRlKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmRhdGFFeGlzdHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUuZGF0YUxlbmd0aDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5kYXRhc2V0c0V4aXN0cztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5kYXRhc2V0c0xlbmd0aDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5kYXRhc2V0c0RhdGFPYmplY3RzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmRhdGFzZXRzRGF0YUxlbmd0aHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUuY29sb3JzRXhpc3RzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmNvbG9ycztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5sYWJlbHNFeGlzdDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5sYWJlbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUubGVnZW5kRXhpc3RzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmxlZ2VuZDtcclxufVxyXG4vKiogQGVudW0ge251bWJlcn0gKi9cclxuY29uc3QgVXBkYXRlVHlwZSA9IHtcclxuICAgIERlZmF1bHQ6IDAsXHJcbiAgICBVcGRhdGU6IDEsXHJcbiAgICBSZWZyZXNoOiAyLFxyXG59O1xyXG5VcGRhdGVUeXBlW1VwZGF0ZVR5cGUuRGVmYXVsdF0gPSAnRGVmYXVsdCc7XHJcblVwZGF0ZVR5cGVbVXBkYXRlVHlwZS5VcGRhdGVdID0gJ1VwZGF0ZSc7XHJcblVwZGF0ZVR5cGVbVXBkYXRlVHlwZS5SZWZyZXNoXSA9ICdSZWZyZXNoJztcclxuZXhwb3J0IGNsYXNzIEJhc2VDaGFydERpcmVjdGl2ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSB0aGVtZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgdGhlbWVTZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLnRoZW1lU2VydmljZSA9IHRoZW1lU2VydmljZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLmNoYXJ0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jaGFydEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub2xkID0ge1xyXG4gICAgICAgICAgICBkYXRhRXhpc3RzOiBmYWxzZSxcclxuICAgICAgICAgICAgZGF0YUxlbmd0aDogMCxcclxuICAgICAgICAgICAgZGF0YXNldHNFeGlzdHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBkYXRhc2V0c0xlbmd0aDogMCxcclxuICAgICAgICAgICAgZGF0YXNldHNEYXRhT2JqZWN0czogW10sXHJcbiAgICAgICAgICAgIGRhdGFzZXRzRGF0YUxlbmd0aHM6IFtdLFxyXG4gICAgICAgICAgICBjb2xvcnNFeGlzdHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IFtdLFxyXG4gICAgICAgICAgICBsYWJlbHNFeGlzdDogZmFsc2UsXHJcbiAgICAgICAgICAgIGxhYmVsczogW10sXHJcbiAgICAgICAgICAgIGxlZ2VuZEV4aXN0czogZmFsc2UsXHJcbiAgICAgICAgICAgIGxlZ2VuZDoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXHJcbiAgICAgKiBAcGFyYW0gez99IHBsdWdpblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xyXG4gICAgICAgIGNoYXJ0SnMuQ2hhcnQucGx1Z2lucy5yZWdpc3RlcihwbHVnaW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBsdWdpblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XHJcbiAgICAgICAgY2hhcnRKcy5DaGFydC5wbHVnaW5zLnVucmVnaXN0ZXIocGx1Z2luKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKHRoaXMudGhlbWVTZXJ2aWNlLmNvbG9yc2NoZW1lc09wdGlvbnMuc3Vic2NyaWJlKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIgPT4gdGhpcy50aGVtZUNoYW5nZWQocikpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHRoZW1lQ2hhbmdlZChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIG5nRG9DaGVjaygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgbGV0IHVwZGF0ZVJlcXVpcmVkID0gVXBkYXRlVHlwZS5EZWZhdWx0O1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCB3YW50VXBkYXRlID0gKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgKHgpID0+IHtcclxuICAgICAgICAgICAgdXBkYXRlUmVxdWlyZWQgPSB4ID4gdXBkYXRlUmVxdWlyZWQgPyB4IDogdXBkYXRlUmVxdWlyZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCEhdGhpcy5kYXRhICE9PSB0aGlzLm9sZC5kYXRhRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRGF0YVRvRGF0YXNldHModGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5vbGQuZGF0YUV4aXN0cyA9ICEhdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoICE9PSB0aGlzLm9sZC5kYXRhTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFMZW5ndGggPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCB8fCAwO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhdGhpcy5kYXRhc2V0cyAhPT0gdGhpcy5vbGQuZGF0YXNldHNFeGlzdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQuZGF0YXNldHNFeGlzdHMgPSAhIXRoaXMuZGF0YXNldHM7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCAhPT0gdGhpcy5vbGQuZGF0YXNldHNMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQuZGF0YXNldHNMZW5ndGggPSB0aGlzLmRhdGFzZXRzICYmIHRoaXMuZGF0YXNldHMubGVuZ3RoIHx8IDA7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoeCwgaSkgPT4geC5kYXRhICE9PSB0aGlzLm9sZC5kYXRhc2V0c0RhdGFPYmplY3RzW2ldKSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFzZXRzRGF0YU9iamVjdHMgPSB0aGlzLmRhdGFzZXRzLm1hcCgoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgeCA9PiB4LmRhdGEpKTtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXRzICYmIHRoaXMuZGF0YXNldHMuZmlsdGVyKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcGFyYW0gez99IGlcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICh4LCBpKSA9PiB4LmRhdGEubGVuZ3RoICE9PSB0aGlzLm9sZC5kYXRhc2V0c0RhdGFMZW5ndGhzW2ldKSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFzZXRzRGF0YUxlbmd0aHMgPSB0aGlzLmRhdGFzZXRzLm1hcCgoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgeCA9PiB4LmRhdGEubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISF0aGlzLmNvbG9ycyAhPT0gdGhpcy5vbGQuY29sb3JzRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmNvbG9yc0V4aXN0cyA9ICEhdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JzKCk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHNtZWxscyBvZiBpbmVmZmljaWVuY3ksIG1pZ2h0IG5lZWQgdG8gcmV2aXNpdCB0aGlzXHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzICYmIHRoaXMuY29sb3JzLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoeCwgaSkgPT4gIXRoaXMuY29sb3JzRXF1YWwoeCwgdGhpcy5vbGQuY29sb3JzW2ldKSkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5jb2xvcnMgPSB0aGlzLmNvbG9ycy5tYXAoKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHggPT4gdGhpcy5jb3B5Q29sb3IoeCkpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoKTtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXRoaXMubGFiZWxzICE9PSB0aGlzLm9sZC5sYWJlbHNFeGlzdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5sYWJlbHNFeGlzdCA9ICEhdGhpcy5sYWJlbHM7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5sYWJlbHMgJiYgdGhpcy5sYWJlbHMuZmlsdGVyKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcGFyYW0gez99IGlcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICh4LCBpKSA9PiAhdGhpcy5sYWJlbHNFcXVhbCh4LCB0aGlzLm9sZC5sYWJlbHNbaV0pKSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmxhYmVscyA9IHRoaXMubGFiZWxzLm1hcCgoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgeCA9PiB0aGlzLmNvcHlMYWJlbCh4KSkpO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhdGhpcy5vcHRpb25zLmxlZ2VuZCAhPT0gdGhpcy5vbGQubGVnZW5kRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmxlZ2VuZEV4aXN0cyA9ICEhdGhpcy5vcHRpb25zLmxlZ2VuZDtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxlZ2VuZCAmJiB0aGlzLm9wdGlvbnMubGVnZW5kLnBvc2l0aW9uICE9PSB0aGlzLm9sZC5sZWdlbmQucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQubGVnZW5kLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLmxlZ2VuZC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKCgvKiogQHR5cGUgez99ICovICh1cGRhdGVSZXF1aXJlZCkpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5EZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5VcGRhdGU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5SZWZyZXNoOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgY29weUxhYmVsKGEpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLmFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhXHJcbiAgICAgKiBAcGFyYW0gez99IGJcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGxhYmVsc0VxdWFsKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGEpID09PSBBcnJheS5pc0FycmF5KGIpXHJcbiAgICAgICAgICAgICYmIChBcnJheS5pc0FycmF5KGEpIHx8IGEgPT09IGIpXHJcbiAgICAgICAgICAgICYmICghQXJyYXkuaXNBcnJheShhKSB8fCBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgICYmICghQXJyYXkuaXNBcnJheShhKSB8fCBhLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGlcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICh4LCBpKSA9PiB4ICE9PSBiW2ldKSkubGVuZ3RoID09PSAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBjb3B5Q29sb3IoYSkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCByYyA9IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGEuYm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBhLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICBib3JkZXJDYXBTdHlsZTogYS5ib3JkZXJDYXBTdHlsZSxcclxuICAgICAgICAgICAgYm9yZGVyRGFzaDogYS5ib3JkZXJEYXNoLFxyXG4gICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBhLmJvcmRlckRhc2hPZmZzZXQsXHJcbiAgICAgICAgICAgIGJvcmRlckpvaW5TdHlsZTogYS5ib3JkZXJKb2luU3R5bGUsXHJcbiAgICAgICAgICAgIHBvaW50Qm9yZGVyQ29sb3I6IGEucG9pbnRCb3JkZXJDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRCYWNrZ3JvdW5kQ29sb3I6IGEucG9pbnRCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIHBvaW50Qm9yZGVyV2lkdGg6IGEucG9pbnRCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgcG9pbnRSYWRpdXM6IGEucG9pbnRSYWRpdXMsXHJcbiAgICAgICAgICAgIHBvaW50SG92ZXJSYWRpdXM6IGEucG9pbnRIb3ZlclJhZGl1cyxcclxuICAgICAgICAgICAgcG9pbnRIaXRSYWRpdXM6IGEucG9pbnRIaXRSYWRpdXMsXHJcbiAgICAgICAgICAgIHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I6IGEucG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRIb3ZlckJvcmRlckNvbG9yOiBhLnBvaW50SG92ZXJCb3JkZXJDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRIb3ZlckJvcmRlcldpZHRoOiBhLnBvaW50SG92ZXJCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgcG9pbnRTdHlsZTogYS5wb2ludFN0eWxlLFxyXG4gICAgICAgICAgICBob3ZlckJhY2tncm91bmRDb2xvcjogYS5ob3ZlckJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgaG92ZXJCb3JkZXJDb2xvcjogYS5ob3ZlckJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICBob3ZlckJvcmRlcldpZHRoOiBhLmhvdmVyQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYVxyXG4gICAgICogQHBhcmFtIHs/fSBiXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBjb2xvcnNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICE9PSAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhYSB8fCB0cnVlXHJcbiAgICAgICAgICAgICYmIChhLmJhY2tncm91bmRDb2xvciA9PT0gYi5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLmJvcmRlcldpZHRoID09PSBiLmJvcmRlcldpZHRoKVxyXG4gICAgICAgICAgICAmJiAoYS5ib3JkZXJDb2xvciA9PT0gYi5ib3JkZXJDb2xvcilcclxuICAgICAgICAgICAgJiYgKGEuYm9yZGVyQ2FwU3R5bGUgPT09IGIuYm9yZGVyQ2FwU3R5bGUpXHJcbiAgICAgICAgICAgICYmIChhLmJvcmRlckRhc2ggPT09IGIuYm9yZGVyRGFzaClcclxuICAgICAgICAgICAgJiYgKGEuYm9yZGVyRGFzaE9mZnNldCA9PT0gYi5ib3JkZXJEYXNoT2Zmc2V0KVxyXG4gICAgICAgICAgICAmJiAoYS5ib3JkZXJKb2luU3R5bGUgPT09IGIuYm9yZGVySm9pblN0eWxlKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEJvcmRlckNvbG9yID09PSBiLnBvaW50Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50QmFja2dyb3VuZENvbG9yID09PSBiLnBvaW50QmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEJvcmRlcldpZHRoID09PSBiLnBvaW50Qm9yZGVyV2lkdGgpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50UmFkaXVzID09PSBiLnBvaW50UmFkaXVzKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEhvdmVyUmFkaXVzID09PSBiLnBvaW50SG92ZXJSYWRpdXMpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SGl0UmFkaXVzID09PSBiLnBvaW50SGl0UmFkaXVzKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEhvdmVyQmFja2dyb3VuZENvbG9yID09PSBiLnBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SG92ZXJCb3JkZXJDb2xvciA9PT0gYi5wb2ludEhvdmVyQm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SG92ZXJCb3JkZXJXaWR0aCA9PT0gYi5wb2ludEhvdmVyQm9yZGVyV2lkdGgpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50U3R5bGUgPT09IGIucG9pbnRTdHlsZSlcclxuICAgICAgICAgICAgJiYgKGEuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPT09IGIuaG92ZXJCYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLmhvdmVyQm9yZGVyQ29sb3IgPT09IGIuaG92ZXJCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgJiYgKGEuaG92ZXJCb3JkZXJXaWR0aCA9PT0gYi5ob3ZlckJvcmRlcldpZHRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29sb3JzKCkge1xyXG4gICAgICAgIHRoaXMuZGF0YXNldHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbG1cclxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZWxtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcnMgJiYgdGhpcy5jb2xvcnNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsbSwgdGhpcy5jb2xvcnNbaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxtLCBnZXRDb2xvcnModGhpcy5jaGFydFR5cGUsIGluZGV4LCBlbG0uZGF0YS5sZW5ndGgpLCBPYmplY3QuYXNzaWduKHt9LCBlbG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGxldCB1cGRhdGVSZXF1aXJlZCA9IFVwZGF0ZVR5cGUuRGVmYXVsdDtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3Qgd2FudFVwZGF0ZSA9ICgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICh4KSA9PiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVJlcXVpcmVkID0geCA+IHVwZGF0ZVJlcXVpcmVkID8geCA6IHVwZGF0ZVJlcXVpcmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFuZ2VzIGFyZSBpbiB0aGUgZGF0YSBvciBkYXRhc2V0cyBvciBsYWJlbHMgb3IgbGVnZW5kXHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSAmJiBjaGFuZ2VzLmRhdGEuY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRGF0YVRvRGF0YXNldHMoY2hhbmdlcy5kYXRhLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZGF0YXNldHMnKSAmJiBjaGFuZ2VzLmRhdGFzZXRzLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZURhdGFzZXRzVG9EYXRhKGNoYW5nZXMuZGF0YXNldHMuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdsYWJlbHMnKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFydCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmxhYmVscyA9IGNoYW5nZXMubGFiZWxzLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2xlZ2VuZCcpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLmxlZ2VuZC5kaXNwbGF5ID0gY2hhbmdlcy5sZWdlbmQuY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5SZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICgoLyoqIEB0eXBlIHs/fSAqLyAodXBkYXRlUmVxdWlyZWQpKSkge1xyXG4gICAgICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuVXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuUmVmcmVzaDpcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQgPSB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHggPT4geC51bnN1YnNjcmliZSgpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Pz19IGR1cmF0aW9uXHJcbiAgICAgKiBAcGFyYW0gez89fSBsYXp5XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZHVyYXRpb24sIGxhenkpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFydC51cGRhdGUoZHVyYXRpb24sIGxhenkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICogQHBhcmFtIHs/fSBoaWRkZW5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGhpZGVEYXRhc2V0KGluZGV4LCBoaWRkZW4pIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KS5oaWRkZW4gPSBoaWRkZW47XHJcbiAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgaXNEYXRhc2V0SGlkZGVuKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpLmhpZGRlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgdG9CYXNlNjRJbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC50b0Jhc2U2NEltYWdlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldENoYXJ0Q29uZmlndXJhdGlvbigpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmdldERhdGFzZXRzKCk7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQgPSB7IGRpc3BsYXk6IGZhbHNlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhvb2sgZm9yIG9uSG92ZXIgYW5kIG9uQ2xpY2sgZXZlbnRzXHJcbiAgICAgICAgb3B0aW9ucy5ob3ZlciA9IG9wdGlvbnMuaG92ZXIgfHwge307XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmhvdmVyLm9uSG92ZXIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5ob3Zlci5vbkhvdmVyID0gKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYWN0aXZlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoZXZlbnQsIGFjdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAmJiAhYWN0aXZlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnRIb3Zlci5lbWl0KHsgZXZlbnQsIGFjdGl2ZSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3B0aW9ucy5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMub25DbGljayA9ICgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/PX0gZXZlbnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/PX0gYWN0aXZlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoZXZlbnQsIGFjdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydENsaWNrLmVtaXQoeyBldmVudCwgYWN0aXZlIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB0aGlzLnNtYXJ0TWVyZ2Uob3B0aW9ucywgdGhpcy50aGVtZVNlcnZpY2UuZ2V0Q29sb3JzY2hlbWVzT3B0aW9ucygpKTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgY2hhcnRDb25maWcgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuY2hhcnRUeXBlLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMubGFiZWxzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgZGF0YXNldHNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5wbHVnaW5zLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBtZXJnZWRPcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0Q29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhcnRCdWlsZGVyKGN0eCAvKiwgZGF0YTphbnlbXSwgb3B0aW9uczphbnkqLykge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBjaGFydENvbmZpZyA9IHRoaXMuZ2V0Q2hhcnRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFydEpzLkNoYXJ0KGN0eCwgY2hhcnRDb25maWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7P30gb3ZlcnJpZGVzXHJcbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgc21hcnRNZXJnZShvcHRpb25zLCBvdmVycmlkZXMsIGxldmVsID0gMCkge1xyXG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gY2xvbmVEZWVwKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3Qga2V5c1RvVXBkYXRlID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcclxuICAgICAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG92ZXJyaWRlc1trZXldKSkge1xyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlFbGVtZW50cyA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJheUVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFbGVtZW50cy5mb3JFYWNoKCgvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNtYXJ0TWVyZ2Uociwgb3ZlcnJpZGVzW2tleV1bMF0sIGxldmVsICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob3ZlcnJpZGVzW2tleV0pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNtYXJ0TWVyZ2Uob3B0aW9uc1trZXldLCBvdmVycmlkZXNba2V5XSwgbGV2ZWwgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IG92ZXJyaWRlc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGxhYmVsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBpc011bHRpTGluZUxhYmVsKGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGFiZWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBsYWJlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgam9pbkxhYmVsKGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKCFsYWJlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aUxpbmVMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGFzZXRzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBwcm9wYWdhdGVEYXRhc2V0c1RvRGF0YShkYXRhc2V0cykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YXNldHMubWFwKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIgPT4gci5kYXRhKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzID0gZGF0YXNldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3JzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5ld0RhdGFWYWx1ZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHByb3BhZ2F0ZURhdGFUb0RhdGFzZXRzKG5ld0RhdGFWYWx1ZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5pc011bHRpRGF0YVNldChuZXdEYXRhVmFsdWVzKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiBuZXdEYXRhVmFsdWVzLmxlbmd0aCA9PT0gdGhpcy5kYXRhc2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGRhdGFzZXRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKGRhdGFzZXQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0LmRhdGEgPSBuZXdEYXRhVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0cyA9IG5ld0RhdGFWYWx1ZXMubWFwKCgvKipcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGF0YVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKGRhdGEsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgbGFiZWw6IHRoaXMuam9pbkxhYmVsKHRoaXMubGFiZWxzW2luZGV4XSkgfHwgYExhYmVsICR7aW5kZXh9YCB9O1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMgPSB0aGlzLmRhdGFzZXRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGF0YXNldHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHMgPSBbeyBkYXRhOiBuZXdEYXRhVmFsdWVzIH1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMgPSB0aGlzLmRhdGFzZXRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0c1swXS5kYXRhID0gbmV3RGF0YVZhbHVlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHMuc3BsaWNlKDEpOyAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGJ1dCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9ycygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBpc011bHRpRGF0YVNldChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YVswXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhc2V0cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YXNldHMgJiYgIXRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5nLWNoYXJ0cyBjb25maWd1cmF0aW9uIGVycm9yLCBkYXRhIG9yIGRhdGFzZXRzIGZpZWxkIGFyZSByZXF1aXJlZCB0byByZW5kZXIgY2hhcnQgJHt0aGlzLmNoYXJ0VHlwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYGRhdGFzZXRzYCBpcyBkZWZpbmVkLCB1c2UgaXQgb3ZlciB0aGUgYGRhdGFgIHByb3BlcnR5LlxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRGF0YXNldHNUb0RhdGEodGhpcy5kYXRhc2V0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRGF0YVRvRGF0YXNldHModGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaCgpIHtcclxuICAgICAgICAvLyBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XHJcbiAgICAgICAgLy8gICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVmcmVzaCgpLCA1MCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHRvZG86IHJlbW92ZSB0aGlzIGxpbmUsIGl0IGlzIHByb2R1Y2luZyBmbGlja2VyaW5nXHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQgPSB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN0eCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0ID0gdGhpcy5nZXRDaGFydEJ1aWxkZXIodGhpcy5jdHggLyosIGRhdGEsIHRoaXMub3B0aW9ucyovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQmFzZUNoYXJ0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2FudmFzW2Jhc2VDaGFydF0nLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdiYXNlLWNoYXJ0J1xyXG4gICAgICAgICAgICB9LF0gfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuQmFzZUNoYXJ0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xyXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXHJcbiAgICB7IHR5cGU6IFRoZW1lU2VydmljZSB9XHJcbl07XHJcbkJhc2VDaGFydERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgZGF0YXNldHM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgbGFiZWxzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgIG9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgY2hhcnRUeXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgIGNvbG9yczogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBsZWdlbmQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgcGx1Z2luczogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBjaGFydENsaWNrOiBbeyB0eXBlOiBPdXRwdXQgfV0sXHJcbiAgICBjaGFydEhvdmVyOiBbeyB0eXBlOiBPdXRwdXQgfV1cclxufTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmRhdGE7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmRhdGFzZXRzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5sYWJlbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLm9wdGlvbnM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0VHlwZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuY29sb3JzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5sZWdlbmQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnBsdWdpbnM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0Q2xpY2s7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0SG92ZXI7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmN0eDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuY2hhcnQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5vbGQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5zdWJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuZWxlbWVudDtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnRoZW1lU2VydmljZTtcclxufVxyIl19