/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, Input, Output, EventEmitter, ElementRef, } from '@angular/core';
import * as chartJs from 'chart.js';
import { getColors } from './get-colors';
import { ThemeService } from './theme.service';
import { cloneDeep } from 'lodash';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
function OldState() { }
if (false) {
    /** @type {?} */
    OldState.prototype.dataExists;
    /** @type {?} */
    OldState.prototype.dataLength;
    /** @type {?} */
    OldState.prototype.datasetsExists;
    /** @type {?} */
    OldState.prototype.datasetsLength;
    /** @type {?} */
    OldState.prototype.datasetsDataObjects;
    /** @type {?} */
    OldState.prototype.datasetsDataLengths;
    /** @type {?} */
    OldState.prototype.colorsExists;
    /** @type {?} */
    OldState.prototype.colors;
    /** @type {?} */
    OldState.prototype.labelsExist;
    /** @type {?} */
    OldState.prototype.labels;
    /** @type {?} */
    OldState.prototype.legendExists;
    /** @type {?} */
    OldState.prototype.legend;
}
/** @enum {number} */
var UpdateType = {
    Default: 0,
    Update: 1,
    Refresh: 2,
};
UpdateType[UpdateType.Default] = 'Default';
UpdateType[UpdateType.Update] = 'Update';
UpdateType[UpdateType.Refresh] = 'Refresh';
var BaseChartDirective = /** @class */ (function () {
    function BaseChartDirective(element, themeService) {
        this.element = element;
        this.themeService = themeService;
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.old = {
            dataExists: false,
            dataLength: 0,
            datasetsExists: false,
            datasetsLength: 0,
            datasetsDataObjects: [],
            datasetsDataLengths: [],
            colorsExists: false,
            colors: [],
            labelsExist: false,
            labels: [],
            legendExists: false,
            legend: {},
        };
        this.subs = [];
    }
    /**
     * Register a plugin.
     */
    /**
     * Register a plugin.
     * @param {?} plugin
     * @return {?}
     */
    BaseChartDirective.registerPlugin = /**
     * Register a plugin.
     * @param {?} plugin
     * @return {?}
     */
    function (plugin) {
        chartJs.Chart.plugins.register(plugin);
    };
    /**
     * @param {?} plugin
     * @return {?}
     */
    BaseChartDirective.unregisterPlugin = /**
     * @param {?} plugin
     * @return {?}
     */
    function (plugin) {
        chartJs.Chart.plugins.unregister(plugin);
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ctx = this.element.nativeElement.getContext('2d');
        this.refresh();
        this.subs.push(this.themeService.colorschemesOptions.subscribe((/**
         * @param {?} r
         * @return {?}
         */
        function (r) { return _this.themeChanged(r); })));
    };
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    BaseChartDirective.prototype.themeChanged = /**
     * @private
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.refresh();
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.chart) {
            return;
        }
        /** @type {?} */
        var updateRequired = UpdateType.Default;
        /** @type {?} */
        var wantUpdate = (/**
         * @param {?} x
         * @return {?}
         */
        function (x) {
            updateRequired = x > updateRequired ? x : updateRequired;
        });
        if (!!this.data !== this.old.dataExists) {
            this.propagateDataToDatasets(this.data);
            this.old.dataExists = !!this.data;
            wantUpdate(UpdateType.Update);
        }
        if (this.data && this.data.length !== this.old.dataLength) {
            this.old.dataLength = this.data && this.data.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (!!this.datasets !== this.old.datasetsExists) {
            this.old.datasetsExists = !!this.datasets;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.length !== this.old.datasetsLength) {
            this.old.datasetsLength = this.datasets && this.datasets.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        function (x, i) { return x.data !== _this.old.datasetsDataObjects[i]; })).length) {
            this.old.datasetsDataObjects = this.datasets.map((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return x.data; }));
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        function (x, i) { return x.data.length !== _this.old.datasetsDataLengths[i]; })).length) {
            this.old.datasetsDataLengths = this.datasets.map((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return x.data.length; }));
            wantUpdate(UpdateType.Update);
        }
        if (!!this.colors !== this.old.colorsExists) {
            this.old.colorsExists = !!this.colors;
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        // This smells of inefficiency, might need to revisit this
        if (this.colors && this.colors.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        function (x, i) { return !_this.colorsEqual(x, _this.old.colors[i]); })).length) {
            this.old.colors = this.colors.map((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return _this.copyColor(x); }));
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        if (!!this.labels !== this.old.labelsExist) {
            this.old.labelsExist = !!this.labels;
            wantUpdate(UpdateType.Update);
        }
        if (this.labels && this.labels.filter((/**
         * @param {?} x
         * @param {?} i
         * @return {?}
         */
        function (x, i) { return !_this.labelsEqual(x, _this.old.labels[i]); })).length) {
            this.old.labels = this.labels.map((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return _this.copyLabel(x); }));
            wantUpdate(UpdateType.Update);
        }
        if (!!this.options.legend !== this.old.legendExists) {
            this.old.legendExists = !!this.options.legend;
            wantUpdate(UpdateType.Refresh);
        }
        if (this.options.legend && this.options.legend.position !== this.old.legend.position) {
            this.old.legend.position = this.options.legend.position;
            wantUpdate(UpdateType.Refresh);
        }
        switch ((/** @type {?} */ (updateRequired))) {
            case UpdateType.Default:
                break;
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
                this.refresh();
                break;
        }
    };
    /**
     * @param {?} a
     * @return {?}
     */
    BaseChartDirective.prototype.copyLabel = /**
     * @param {?} a
     * @return {?}
     */
    function (a) {
        if (Array.isArray(a)) {
            return tslib_1.__spread(a);
        }
        return a;
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    BaseChartDirective.prototype.labelsEqual = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        return true
            && Array.isArray(a) === Array.isArray(b)
            && (Array.isArray(a) || a === b)
            && (!Array.isArray(a) || a.length === b.length)
            && (!Array.isArray(a) || a.filter((/**
             * @param {?} x
             * @param {?} i
             * @return {?}
             */
            function (x, i) { return x !== b[i]; })).length === 0);
    };
    /**
     * @param {?} a
     * @return {?}
     */
    BaseChartDirective.prototype.copyColor = /**
     * @param {?} a
     * @return {?}
     */
    function (a) {
        /** @type {?} */
        var rc = {
            backgroundColor: a.backgroundColor,
            borderWidth: a.borderWidth,
            borderColor: a.borderColor,
            borderCapStyle: a.borderCapStyle,
            borderDash: a.borderDash,
            borderDashOffset: a.borderDashOffset,
            borderJoinStyle: a.borderJoinStyle,
            pointBorderColor: a.pointBorderColor,
            pointBackgroundColor: a.pointBackgroundColor,
            pointBorderWidth: a.pointBorderWidth,
            pointRadius: a.pointRadius,
            pointHoverRadius: a.pointHoverRadius,
            pointHitRadius: a.pointHitRadius,
            pointHoverBackgroundColor: a.pointHoverBackgroundColor,
            pointHoverBorderColor: a.pointHoverBorderColor,
            pointHoverBorderWidth: a.pointHoverBorderWidth,
            pointStyle: a.pointStyle,
            hoverBackgroundColor: a.hoverBackgroundColor,
            hoverBorderColor: a.hoverBorderColor,
            hoverBorderWidth: a.hoverBorderWidth,
        };
        return rc;
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    BaseChartDirective.prototype.colorsEqual = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if (!a !== !b) {
            return false;
        }
        return !a || true
            && (a.backgroundColor === b.backgroundColor)
            && (a.borderWidth === b.borderWidth)
            && (a.borderColor === b.borderColor)
            && (a.borderCapStyle === b.borderCapStyle)
            && (a.borderDash === b.borderDash)
            && (a.borderDashOffset === b.borderDashOffset)
            && (a.borderJoinStyle === b.borderJoinStyle)
            && (a.pointBorderColor === b.pointBorderColor)
            && (a.pointBackgroundColor === b.pointBackgroundColor)
            && (a.pointBorderWidth === b.pointBorderWidth)
            && (a.pointRadius === b.pointRadius)
            && (a.pointHoverRadius === b.pointHoverRadius)
            && (a.pointHitRadius === b.pointHitRadius)
            && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)
            && (a.pointHoverBorderColor === b.pointHoverBorderColor)
            && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)
            && (a.pointStyle === b.pointStyle)
            && (a.hoverBackgroundColor === b.hoverBackgroundColor)
            && (a.hoverBorderColor === b.hoverBorderColor)
            && (a.hoverBorderWidth === b.hoverBorderWidth);
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.updateColors = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.datasets.forEach((/**
         * @param {?} elm
         * @param {?} index
         * @return {?}
         */
        function (elm, index) {
            if (_this.colors && _this.colors[index]) {
                Object.assign(elm, _this.colors[index]);
            }
            else {
                Object.assign(elm, getColors(_this.chartType, index, elm.data.length), tslib_1.__assign({}, elm));
            }
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    BaseChartDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var updateRequired = UpdateType.Default;
        /** @type {?} */
        var wantUpdate = (/**
         * @param {?} x
         * @return {?}
         */
        function (x) {
            updateRequired = x > updateRequired ? x : updateRequired;
        });
        // Check if the changes are in the data or datasets or labels or legend
        if (changes.hasOwnProperty('data') && changes.data.currentValue) {
            this.propagateDataToDatasets(changes.data.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {
            this.propagateDatasetsToData(changes.datasets.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('labels')) {
            if (this.chart) {
                this.chart.data.labels = changes.labels.currentValue;
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('legend')) {
            if (this.chart) {
                this.chart.config.options.legend.display = changes.legend.currentValue;
                this.chart.generateLegend();
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('options')) {
            wantUpdate(UpdateType.Refresh);
        }
        switch ((/** @type {?} */ (updateRequired))) {
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
            case UpdateType.Default:
                this.refresh();
                break;
        }
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.subs.forEach((/**
         * @param {?} x
         * @return {?}
         */
        function (x) { return x.unsubscribe(); }));
    };
    /**
     * @param {?=} duration
     * @param {?=} lazy
     * @return {?}
     */
    BaseChartDirective.prototype.update = /**
     * @param {?=} duration
     * @param {?=} lazy
     * @return {?}
     */
    function (duration, lazy) {
        if (this.chart) {
            return this.chart.update(duration, lazy);
        }
    };
    /**
     * @param {?} index
     * @param {?} hidden
     * @return {?}
     */
    BaseChartDirective.prototype.hideDataset = /**
     * @param {?} index
     * @param {?} hidden
     * @return {?}
     */
    function (index, hidden) {
        this.chart.getDatasetMeta(index).hidden = hidden;
        this.chart.update();
    };
    /**
     * @param {?} index
     * @return {?}
     */
    BaseChartDirective.prototype.isDatasetHidden = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.chart.getDatasetMeta(index).hidden;
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.toBase64Image = /**
     * @return {?}
     */
    function () {
        return this.chart.toBase64Image();
    };
    /**
     * @return {?}
     */
    BaseChartDirective.prototype.getChartConfiguration = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var datasets = this.getDatasets();
        /** @type {?} */
        var options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hook for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            function (event, active) {
                if (active && !active.length) {
                    return;
                }
                _this.chartHover.emit({ event: event, active: active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?=} event
             * @param {?=} active
             * @return {?}
             */
            function (event, active) {
                _this.chartClick.emit({ event: event, active: active });
            });
        }
        /** @type {?} */
        var mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
        /** @type {?} */
        var chartConfig = {
            type: this.chartType,
            data: {
                labels: this.labels || [],
                datasets: datasets
            },
            plugins: this.plugins,
            options: mergedOptions,
        };
        return chartConfig;
    };
    /**
     * @param {?} ctx
     * @return {?}
     */
    BaseChartDirective.prototype.getChartBuilder = /**
     * @param {?} ctx
     * @return {?}
     */
    function (ctx /*, data:any[], options:any*/) {
        /** @type {?} */
        var chartConfig = this.getChartConfiguration();
        return new chartJs.Chart(ctx, chartConfig);
    };
    /**
     * @param {?} options
     * @param {?} overrides
     * @param {?=} level
     * @return {?}
     */
    BaseChartDirective.prototype.smartMerge = /**
     * @param {?} options
     * @param {?} overrides
     * @param {?=} level
     * @return {?}
     */
    function (options, overrides, level) {
        var _this = this;
        if (level === void 0) { level = 0; }
        if (level === 0) {
            options = cloneDeep(options);
        }
        /** @type {?} */
        var keysToUpdate = Object.keys(overrides);
        keysToUpdate.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            if (Array.isArray(overrides[key])) {
                /** @type {?} */
                var arrayElements = options[key];
                if (arrayElements) {
                    arrayElements.forEach((/**
                     * @param {?} r
                     * @return {?}
                     */
                    function (r) {
                        _this.smartMerge(r, overrides[key][0], level + 1);
                    }));
                }
            }
            else if (typeof (overrides[key]) === 'object') {
                if (!(key in options)) {
                    options[key] = {};
                }
                _this.smartMerge(options[key], overrides[key], level + 1);
            }
            else {
                options[key] = overrides[key];
            }
        }));
        if (level === 0) {
            return options;
        }
    };
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    BaseChartDirective.prototype.isMultiLineLabel = /**
     * @private
     * @param {?} label
     * @return {?}
     */
    function (label) {
        return Array.isArray(label);
    };
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    BaseChartDirective.prototype.joinLabel = /**
     * @private
     * @param {?} label
     * @return {?}
     */
    function (label) {
        if (!label) {
            return null;
        }
        if (this.isMultiLineLabel(label)) {
            return label.join(' ');
        }
        else {
            return label;
        }
    };
    /**
     * @private
     * @param {?} datasets
     * @return {?}
     */
    BaseChartDirective.prototype.propagateDatasetsToData = /**
     * @private
     * @param {?} datasets
     * @return {?}
     */
    function (datasets) {
        this.data = this.datasets.map((/**
         * @param {?} r
         * @return {?}
         */
        function (r) { return r.data; }));
        if (this.chart) {
            this.chart.data.datasets = datasets;
        }
        this.updateColors();
    };
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    BaseChartDirective.prototype.propagateDataToDatasets = /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    function (newDataValues) {
        var _this = this;
        if (this.isMultiDataSet(newDataValues)) {
            if (this.datasets && newDataValues.length === this.datasets.length) {
                this.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                function (dataset, i) {
                    dataset.data = newDataValues[i];
                }));
            }
            else {
                this.datasets = newDataValues.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                function (data, index) {
                    return { data: data, label: _this.joinLabel(_this.labels[index]) || "Label " + index };
                }));
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
        }
        else {
            if (!this.datasets) {
                this.datasets = [{ data: newDataValues }];
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
            else {
                this.datasets[0].data = newDataValues;
                this.datasets.splice(1); // Remove all elements but the first
            }
        }
        this.updateColors();
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    BaseChartDirective.prototype.isMultiDataSet = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return Array.isArray(data[0]);
    };
    /**
     * @private
     * @return {?}
     */
    BaseChartDirective.prototype.getDatasets = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.datasets && !this.data) {
            throw new Error("ng-charts configuration error, data or datasets field are required to render chart " + this.chartType);
        }
        // If `datasets` is defined, use it over the `data` property.
        if (this.datasets) {
            this.propagateDatasetsToData(this.datasets);
            return this.datasets;
        }
        if (this.data) {
            this.propagateDataToDatasets(this.data);
            return this.datasets;
        }
    };
    /**
     * @private
     * @return {?}
     */
    BaseChartDirective.prototype.refresh = /**
     * @private
     * @return {?}
     */
    function () {
        // if (this.options && this.options.responsive) {
        //   setTimeout(() => this.refresh(), 50);
        // }
        // todo: remove this line, it is producing flickering
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        if (this.ctx) {
            this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
        }
    };
    /** @nocollapse */
    BaseChartDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ThemeService }
    ]; };
    BaseChartDirective.propDecorators = {
        data: [{ type: Input }],
        datasets: [{ type: Input }],
        labels: [{ type: Input }],
        options: [{ type: Input }],
        chartType: [{ type: Input }],
        colors: [{ type: Input }],
        legend: [{ type: Input }],
        plugins: [{ type: Input }],
        chartClick: [{ type: Output }],
        chartHover: [{ type: Output }]
    };
BaseChartDirective.ɵfac = function BaseChartDirective_Factory(t) { return new (t || BaseChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThemeService)); };
BaseChartDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseChartDirective, selectors: [["canvas", "baseChart", ""]], inputs: { options: "options", data: "data", datasets: "datasets", labels: "labels", chartType: "chartType", colors: "colors", legend: "legend", plugins: "plugins" }, outputs: { chartClick: "chartClick", chartHover: "chartHover" }, exportAs: ["base-chart"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseChartDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'canvas[baseChart]',
                exportAs: 'base-chart'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ThemeService }]; }, { options: [{
            type: Input
        }], chartClick: [{
            type: Output
        }], chartHover: [{
            type: Output
        }], data: [{
            type: Input
        }], datasets: [{
            type: Input
        }], labels: [{
            type: Input
        }], chartType: [{
            type: Input
        }], colors: [{
            type: Input
        }], legend: [{
            type: Input
        }], plugins: [{
            type: Input
        }] }); })();
    return BaseChartDirective;
}());
export { BaseChartDirective };
if (false) {
    /** @type {?} */
    BaseChartDirective.prototype.data;
    /** @type {?} */
    BaseChartDirective.prototype.datasets;
    /** @type {?} */
    BaseChartDirective.prototype.labels;
    /** @type {?} */
    BaseChartDirective.prototype.options;
    /** @type {?} */
    BaseChartDirective.prototype.chartType;
    /** @type {?} */
    BaseChartDirective.prototype.colors;
    /** @type {?} */
    BaseChartDirective.prototype.legend;
    /** @type {?} */
    BaseChartDirective.prototype.plugins;
    /** @type {?} */
    BaseChartDirective.prototype.chartClick;
    /** @type {?} */
    BaseChartDirective.prototype.chartHover;
    /** @type {?} */
    BaseChartDirective.prototype.ctx;
    /** @type {?} */
    BaseChartDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.old;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.subs;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.themeService;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmcyLWNoYXJ0cy9lc201L2xpYi9iYXNlLWNoYXJ0LmRpcmVjdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTJ2Qk0sQUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUJBIiwiZmlsZSI6ImJhc2UtY2hhcnQuZGlyZWN0aXZlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGNoYXJ0SnMgZnJvbSAnY2hhcnQuanMnO1xyXG5pbXBvcnQgeyBnZXRDb2xvcnMgfSBmcm9tICcuL2dldC1jb2xvcnMnO1xyXG5pbXBvcnQgeyBUaGVtZVNlcnZpY2UgfSBmcm9tICcuL3RoZW1lLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gT2xkU3RhdGUoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUuZGF0YUV4aXN0cztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5kYXRhTGVuZ3RoO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmRhdGFzZXRzRXhpc3RzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmRhdGFzZXRzTGVuZ3RoO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmRhdGFzZXRzRGF0YU9iamVjdHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUuZGF0YXNldHNEYXRhTGVuZ3RocztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5jb2xvcnNFeGlzdHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUuY29sb3JzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmxhYmVsc0V4aXN0O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgT2xkU3RhdGUucHJvdG90eXBlLmxhYmVscztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE9sZFN0YXRlLnByb3RvdHlwZS5sZWdlbmRFeGlzdHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBPbGRTdGF0ZS5wcm90b3R5cGUubGVnZW5kO1xyXG59XHJcbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xyXG52YXIgVXBkYXRlVHlwZSA9IHtcclxuICAgIERlZmF1bHQ6IDAsXHJcbiAgICBVcGRhdGU6IDEsXHJcbiAgICBSZWZyZXNoOiAyLFxyXG59O1xyXG5VcGRhdGVUeXBlW1VwZGF0ZVR5cGUuRGVmYXVsdF0gPSAnRGVmYXVsdCc7XHJcblVwZGF0ZVR5cGVbVXBkYXRlVHlwZS5VcGRhdGVdID0gJ1VwZGF0ZSc7XHJcblVwZGF0ZVR5cGVbVXBkYXRlVHlwZS5SZWZyZXNoXSA9ICdSZWZyZXNoJztcclxudmFyIEJhc2VDaGFydERpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VDaGFydERpcmVjdGl2ZShlbGVtZW50LCB0aGVtZVNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlID0gdGhlbWVTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2hhcnRDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmNoYXJ0SG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vbGQgPSB7XHJcbiAgICAgICAgICAgIGRhdGFFeGlzdHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICBkYXRhc2V0c0V4aXN0czogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGFzZXRzTGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICBkYXRhc2V0c0RhdGFPYmplY3RzOiBbXSxcclxuICAgICAgICAgICAgZGF0YXNldHNEYXRhTGVuZ3RoczogW10sXHJcbiAgICAgICAgICAgIGNvbG9yc0V4aXN0czogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbG9yczogW10sXHJcbiAgICAgICAgICAgIGxhYmVsc0V4aXN0OiBmYWxzZSxcclxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcclxuICAgICAgICAgICAgbGVnZW5kRXhpc3RzOiBmYWxzZSxcclxuICAgICAgICAgICAgbGVnZW5kOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc3VicyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cclxuICAgICAqIEBwYXJhbSB7P30gcGx1Z2luXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucmVnaXN0ZXJQbHVnaW4gPSAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxyXG4gICAgICogQHBhcmFtIHs/fSBwbHVnaW5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgICAgICBjaGFydEpzLkNoYXJ0LnBsdWdpbnMucmVnaXN0ZXIocGx1Z2luKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGx1Z2luXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUudW5yZWdpc3RlclBsdWdpbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwbHVnaW5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgICAgICBjaGFydEpzLkNoYXJ0LnBsdWdpbnMudW5yZWdpc3RlcihwbHVnaW4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKHRoaXMudGhlbWVTZXJ2aWNlLmNvbG9yc2NoZW1lc09wdGlvbnMuc3Vic2NyaWJlKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy50aGVtZUNoYW5nZWQocik7IH0pKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnRoZW1lQ2hhbmdlZCA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUubmdEb0NoZWNrID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIHVwZGF0ZVJlcXVpcmVkID0gVXBkYXRlVHlwZS5EZWZhdWx0O1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgd2FudFVwZGF0ZSA9ICgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVJlcXVpcmVkID0geCA+IHVwZGF0ZVJlcXVpcmVkID8geCA6IHVwZGF0ZVJlcXVpcmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghIXRoaXMuZGF0YSAhPT0gdGhpcy5vbGQuZGF0YUV4aXN0cykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZURhdGFUb0RhdGFzZXRzKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFFeGlzdHMgPSAhIXRoaXMuZGF0YTtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCAhPT0gdGhpcy5vbGQuZGF0YUxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5kYXRhTGVuZ3RoID0gdGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggfHwgMDtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXRoaXMuZGF0YXNldHMgIT09IHRoaXMub2xkLmRhdGFzZXRzRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFzZXRzRXhpc3RzID0gISF0aGlzLmRhdGFzZXRzO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMgJiYgdGhpcy5kYXRhc2V0cy5sZW5ndGggIT09IHRoaXMub2xkLmRhdGFzZXRzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2xkLmRhdGFzZXRzTGVuZ3RoID0gdGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCB8fCAwO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMgJiYgdGhpcy5kYXRhc2V0cy5maWx0ZXIoKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gaVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIHguZGF0YSAhPT0gX3RoaXMub2xkLmRhdGFzZXRzRGF0YU9iamVjdHNbaV07IH0pKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQuZGF0YXNldHNEYXRhT2JqZWN0cyA9IHRoaXMuZGF0YXNldHMubWFwKCgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kYXRhOyB9KSk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4geC5kYXRhLmxlbmd0aCAhPT0gX3RoaXMub2xkLmRhdGFzZXRzRGF0YUxlbmd0aHNbaV07IH0pKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQuZGF0YXNldHNEYXRhTGVuZ3RocyA9IHRoaXMuZGF0YXNldHMubWFwKCgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kYXRhLmxlbmd0aDsgfSkpO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhdGhpcy5jb2xvcnMgIT09IHRoaXMub2xkLmNvbG9yc0V4aXN0cykge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5jb2xvcnNFeGlzdHMgPSAhIXRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbG9ycygpO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyBzbWVsbHMgb2YgaW5lZmZpY2llbmN5LCBtaWdodCBuZWVkIHRvIHJldmlzaXQgdGhpc1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9ycyAmJiB0aGlzLmNvbG9ycy5maWx0ZXIoKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30geFxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gaVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuICFfdGhpcy5jb2xvcnNFcXVhbCh4LCBfdGhpcy5vbGQuY29sb3JzW2ldKTsgfSkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5jb2xvcnMgPSB0aGlzLmNvbG9ycy5tYXAoKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5jb3B5Q29sb3IoeCk7IH0pKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoKTtcclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXRoaXMubGFiZWxzICE9PSB0aGlzLm9sZC5sYWJlbHNFeGlzdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5sYWJlbHNFeGlzdCA9ICEhdGhpcy5sYWJlbHM7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5sYWJlbHMgJiYgdGhpcy5sYWJlbHMuZmlsdGVyKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcGFyYW0gez99IGlcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiAhX3RoaXMubGFiZWxzRXF1YWwoeCwgX3RoaXMub2xkLmxhYmVsc1tpXSk7IH0pKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQubGFiZWxzID0gdGhpcy5sYWJlbHMubWFwKCgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuY29weUxhYmVsKHgpOyB9KSk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISF0aGlzLm9wdGlvbnMubGVnZW5kICE9PSB0aGlzLm9sZC5sZWdlbmRFeGlzdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGQubGVnZW5kRXhpc3RzID0gISF0aGlzLm9wdGlvbnMubGVnZW5kO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuUmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVnZW5kICYmIHRoaXMub3B0aW9ucy5sZWdlbmQucG9zaXRpb24gIT09IHRoaXMub2xkLmxlZ2VuZC5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm9sZC5sZWdlbmQucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuUmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoKC8qKiBAdHlwZSB7P30gKi8gKHVwZGF0ZVJlcXVpcmVkKSkpIHtcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLlVwZGF0ZTpcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLlJlZnJlc2g6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5jb3B5TGFiZWwgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZChhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFcclxuICAgICAqIEBwYXJhbSB7P30gYlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5sYWJlbHNFcXVhbCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhXHJcbiAgICAgKiBAcGFyYW0gez99IGJcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShhKSA9PT0gQXJyYXkuaXNBcnJheShiKVxyXG4gICAgICAgICAgICAmJiAoQXJyYXkuaXNBcnJheShhKSB8fCBhID09PSBiKVxyXG4gICAgICAgICAgICAmJiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgYS5sZW5ndGggPT09IGIubGVuZ3RoKVxyXG4gICAgICAgICAgICAmJiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgYS5maWx0ZXIoKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4geCAhPT0gYltpXTsgfSkpLmxlbmd0aCA9PT0gMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuY29weUNvbG9yID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciByYyA9IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGEuYm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBhLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICBib3JkZXJDYXBTdHlsZTogYS5ib3JkZXJDYXBTdHlsZSxcclxuICAgICAgICAgICAgYm9yZGVyRGFzaDogYS5ib3JkZXJEYXNoLFxyXG4gICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBhLmJvcmRlckRhc2hPZmZzZXQsXHJcbiAgICAgICAgICAgIGJvcmRlckpvaW5TdHlsZTogYS5ib3JkZXJKb2luU3R5bGUsXHJcbiAgICAgICAgICAgIHBvaW50Qm9yZGVyQ29sb3I6IGEucG9pbnRCb3JkZXJDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRCYWNrZ3JvdW5kQ29sb3I6IGEucG9pbnRCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIHBvaW50Qm9yZGVyV2lkdGg6IGEucG9pbnRCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgcG9pbnRSYWRpdXM6IGEucG9pbnRSYWRpdXMsXHJcbiAgICAgICAgICAgIHBvaW50SG92ZXJSYWRpdXM6IGEucG9pbnRIb3ZlclJhZGl1cyxcclxuICAgICAgICAgICAgcG9pbnRIaXRSYWRpdXM6IGEucG9pbnRIaXRSYWRpdXMsXHJcbiAgICAgICAgICAgIHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I6IGEucG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRIb3ZlckJvcmRlckNvbG9yOiBhLnBvaW50SG92ZXJCb3JkZXJDb2xvcixcclxuICAgICAgICAgICAgcG9pbnRIb3ZlckJvcmRlcldpZHRoOiBhLnBvaW50SG92ZXJCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgcG9pbnRTdHlsZTogYS5wb2ludFN0eWxlLFxyXG4gICAgICAgICAgICBob3ZlckJhY2tncm91bmRDb2xvcjogYS5ob3ZlckJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgaG92ZXJCb3JkZXJDb2xvcjogYS5ob3ZlckJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICBob3ZlckJvcmRlcldpZHRoOiBhLmhvdmVyQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFcclxuICAgICAqIEBwYXJhbSB7P30gYlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5jb2xvcnNFcXVhbCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhXHJcbiAgICAgKiBAcGFyYW0gez99IGJcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICE9PSAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhYSB8fCB0cnVlXHJcbiAgICAgICAgICAgICYmIChhLmJhY2tncm91bmRDb2xvciA9PT0gYi5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLmJvcmRlcldpZHRoID09PSBiLmJvcmRlcldpZHRoKVxyXG4gICAgICAgICAgICAmJiAoYS5ib3JkZXJDb2xvciA9PT0gYi5ib3JkZXJDb2xvcilcclxuICAgICAgICAgICAgJiYgKGEuYm9yZGVyQ2FwU3R5bGUgPT09IGIuYm9yZGVyQ2FwU3R5bGUpXHJcbiAgICAgICAgICAgICYmIChhLmJvcmRlckRhc2ggPT09IGIuYm9yZGVyRGFzaClcclxuICAgICAgICAgICAgJiYgKGEuYm9yZGVyRGFzaE9mZnNldCA9PT0gYi5ib3JkZXJEYXNoT2Zmc2V0KVxyXG4gICAgICAgICAgICAmJiAoYS5ib3JkZXJKb2luU3R5bGUgPT09IGIuYm9yZGVySm9pblN0eWxlKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEJvcmRlckNvbG9yID09PSBiLnBvaW50Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50QmFja2dyb3VuZENvbG9yID09PSBiLnBvaW50QmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEJvcmRlcldpZHRoID09PSBiLnBvaW50Qm9yZGVyV2lkdGgpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50UmFkaXVzID09PSBiLnBvaW50UmFkaXVzKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEhvdmVyUmFkaXVzID09PSBiLnBvaW50SG92ZXJSYWRpdXMpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SGl0UmFkaXVzID09PSBiLnBvaW50SGl0UmFkaXVzKVxyXG4gICAgICAgICAgICAmJiAoYS5wb2ludEhvdmVyQmFja2dyb3VuZENvbG9yID09PSBiLnBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SG92ZXJCb3JkZXJDb2xvciA9PT0gYi5wb2ludEhvdmVyQm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50SG92ZXJCb3JkZXJXaWR0aCA9PT0gYi5wb2ludEhvdmVyQm9yZGVyV2lkdGgpXHJcbiAgICAgICAgICAgICYmIChhLnBvaW50U3R5bGUgPT09IGIucG9pbnRTdHlsZSlcclxuICAgICAgICAgICAgJiYgKGEuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPT09IGIuaG92ZXJCYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICYmIChhLmhvdmVyQm9yZGVyQ29sb3IgPT09IGIuaG92ZXJCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgJiYgKGEuaG92ZXJCb3JkZXJXaWR0aCA9PT0gYi5ob3ZlckJvcmRlcldpZHRoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUudXBkYXRlQ29sb3JzID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRhdGFzZXRzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxtXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKGVsbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbG9ycyAmJiBfdGhpcy5jb2xvcnNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsbSwgX3RoaXMuY29sb3JzW2luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsbSwgZ2V0Q29sb3JzKF90aGlzLmNoYXJ0VHlwZSwgaW5kZXgsIGVsbS5kYXRhLmxlbmd0aCksIHRzbGliXzEuX19hc3NpZ24oe30sIGVsbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciB1cGRhdGVSZXF1aXJlZCA9IFVwZGF0ZVR5cGUuRGVmYXVsdDtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIHdhbnRVcGRhdGUgPSAoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB4XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB1cGRhdGVSZXF1aXJlZCA9IHggPiB1cGRhdGVSZXF1aXJlZCA/IHggOiB1cGRhdGVSZXF1aXJlZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hhbmdlcyBhcmUgaW4gdGhlIGRhdGEgb3IgZGF0YXNldHMgb3IgbGFiZWxzIG9yIGxlZ2VuZFxyXG4gICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdkYXRhJykgJiYgY2hhbmdlcy5kYXRhLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZURhdGFUb0RhdGFzZXRzKGNoYW5nZXMuZGF0YS5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2RhdGFzZXRzJykgJiYgY2hhbmdlcy5kYXRhc2V0cy5jdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVEYXRhc2V0c1RvRGF0YShjaGFuZ2VzLmRhdGFzZXRzLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHdhbnRVcGRhdGUoVXBkYXRlVHlwZS5VcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbGFiZWxzJykpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgPSBjaGFuZ2VzLmxhYmVscy5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2FudFVwZGF0ZShVcGRhdGVUeXBlLlVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdsZWdlbmQnKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFydCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5sZWdlbmQuZGlzcGxheSA9IGNoYW5nZXMubGVnZW5kLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZ2VuZXJhdGVMZWdlbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG4gICAgICAgICAgICB3YW50VXBkYXRlKFVwZGF0ZVR5cGUuUmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoKC8qKiBAdHlwZSB7P30gKi8gKHVwZGF0ZVJlcXVpcmVkKSkpIHtcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLlVwZGF0ZTpcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLlJlZnJlc2g6XHJcbiAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5EZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQgPSB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHhcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnVuc3Vic2NyaWJlKCk7IH0pKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Pz19IGR1cmF0aW9uXHJcbiAgICAgKiBAcGFyYW0gez89fSBsYXp5XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gZHVyYXRpb25cclxuICAgICAqIEBwYXJhbSB7Pz19IGxhenlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkdXJhdGlvbiwgbGF6eSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnVwZGF0ZShkdXJhdGlvbiwgbGF6eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICogQHBhcmFtIHs/fSBoaWRkZW5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuaGlkZURhdGFzZXQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcclxuICAgICAqIEBwYXJhbSB7P30gaGlkZGVuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaW5kZXgsIGhpZGRlbikge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpLmhpZGRlbiA9IGhpZGRlbjtcclxuICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5pc0RhdGFzZXRIaWRkZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KS5oaWRkZW47XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnRvQmFzZTY0SW1hZ2UgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC50b0Jhc2U2NEltYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmdldENoYXJ0Q29uZmlndXJhdGlvbiA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciBkYXRhc2V0cyA9IHRoaXMuZ2V0RGF0YXNldHMoKTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQgPSB7IGRpc3BsYXk6IGZhbHNlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhvb2sgZm9yIG9uSG92ZXIgYW5kIG9uQ2xpY2sgZXZlbnRzXHJcbiAgICAgICAgb3B0aW9ucy5ob3ZlciA9IG9wdGlvbnMuaG92ZXIgfHwge307XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmhvdmVyLm9uSG92ZXIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5ob3Zlci5vbkhvdmVyID0gKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYWN0aXZlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXZlbnQsIGFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAmJiAhYWN0aXZlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmNoYXJ0SG92ZXIuZW1pdCh7IGV2ZW50OiBldmVudCwgYWN0aXZlOiBhY3RpdmUgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdGlvbnMub25DbGljaykge1xyXG4gICAgICAgICAgICBvcHRpb25zLm9uQ2xpY2sgPSAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Pz19IGV2ZW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Pz19IGFjdGl2ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGV2ZW50LCBhY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNoYXJ0Q2xpY2suZW1pdCh7IGV2ZW50OiBldmVudCwgYWN0aXZlOiBhY3RpdmUgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSB0aGlzLnNtYXJ0TWVyZ2Uob3B0aW9ucywgdGhpcy50aGVtZVNlcnZpY2UuZ2V0Q29sb3JzY2hlbWVzT3B0aW9ucygpKTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIGNoYXJ0Q29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmNoYXJ0VHlwZSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmxhYmVscyB8fCBbXSxcclxuICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBkYXRhc2V0c1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLnBsdWdpbnMsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlZE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2hhcnRDb25maWc7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5nZXRDaGFydEJ1aWxkZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY3R4XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoY3R4IC8qLCBkYXRhOmFueVtdLCBvcHRpb25zOmFueSovKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciBjaGFydENvbmZpZyA9IHRoaXMuZ2V0Q2hhcnRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFydEpzLkNoYXJ0KGN0eCwgY2hhcnRDb25maWcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez99IG92ZXJyaWRlc1xyXG4gICAgICogQHBhcmFtIHs/PX0gbGV2ZWxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuc21hcnRNZXJnZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez99IG92ZXJyaWRlc1xyXG4gICAgICogQHBhcmFtIHs/PX0gbGV2ZWxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChvcHRpb25zLCBvdmVycmlkZXMsIGxldmVsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IDA7IH1cclxuICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGNsb25lRGVlcChvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciBrZXlzVG9VcGRhdGUgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpO1xyXG4gICAgICAgIGtleXNUb1VwZGF0ZS5mb3JFYWNoKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdmVycmlkZXNba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgIHZhciBhcnJheUVsZW1lbnRzID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5RWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheUVsZW1lbnRzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc21hcnRNZXJnZShyLCBvdmVycmlkZXNba2V5XVswXSwgbGV2ZWwgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvdmVycmlkZXNba2V5XSkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnNtYXJ0TWVyZ2Uob3B0aW9uc1trZXldLCBvdmVycmlkZXNba2V5XSwgbGV2ZWwgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IG92ZXJyaWRlc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBsYWJlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5pc011bHRpTGluZUxhYmVsID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBsYWJlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGFiZWwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gbGFiZWxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuam9pbkxhYmVsID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBsYWJlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKCFsYWJlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aUxpbmVMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRhc2V0c1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5wcm9wYWdhdGVEYXRhc2V0c1RvRGF0YSA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gZGF0YXNldHNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkYXRhc2V0cykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YXNldHMubWFwKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmRhdGE7IH0pKTtcclxuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMgPSBkYXRhc2V0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5ld0RhdGFWYWx1ZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUucHJvcGFnYXRlRGF0YVRvRGF0YXNldHMgPSAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5ld0RhdGFWYWx1ZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuZXdEYXRhVmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5pc011bHRpRGF0YVNldChuZXdEYXRhVmFsdWVzKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiBuZXdEYXRhVmFsdWVzLmxlbmd0aCA9PT0gdGhpcy5kYXRhc2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGRhdGFzZXRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGFzZXQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0LmRhdGEgPSBuZXdEYXRhVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0cyA9IG5ld0RhdGFWYWx1ZXMubWFwKCgvKipcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGF0YVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGEsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgbGFiZWw6IF90aGlzLmpvaW5MYWJlbChfdGhpcy5sYWJlbHNbaW5kZXhdKSB8fCBcIkxhYmVsIFwiICsgaW5kZXggfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzID0gdGhpcy5kYXRhc2V0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGFzZXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXRzID0gW3sgZGF0YTogbmV3RGF0YVZhbHVlcyB9XTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzID0gdGhpcy5kYXRhc2V0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHNbMF0uZGF0YSA9IG5ld0RhdGFWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXRzLnNwbGljZSgxKTsgLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBidXQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGFcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuaXNNdWx0aURhdGFTZXQgPSAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGFcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YVswXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5nZXREYXRhc2V0cyA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YXNldHMgJiYgIXRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZy1jaGFydHMgY29uZmlndXJhdGlvbiBlcnJvciwgZGF0YSBvciBkYXRhc2V0cyBmaWVsZCBhcmUgcmVxdWlyZWQgdG8gcmVuZGVyIGNoYXJ0IFwiICsgdGhpcy5jaGFydFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBgZGF0YXNldHNgIGlzIGRlZmluZWQsIHVzZSBpdCBvdmVyIHRoZSBgZGF0YWAgcHJvcGVydHkuXHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVEYXRhc2V0c1RvRGF0YSh0aGlzLmRhdGFzZXRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVEYXRhVG9EYXRhc2V0cyh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5yZWZyZXNoID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcclxuICAgICAgICAvLyAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoKCksIDUwKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoaXMgbGluZSwgaXQgaXMgcHJvZHVjaW5nIGZsaWNrZXJpbmdcclxuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFydCA9IHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQgPSB0aGlzLmdldENoYXJ0QnVpbGRlcih0aGlzLmN0eCAvKiwgZGF0YSwgdGhpcy5vcHRpb25zKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLXNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjYW52YXNbYmFzZUNoYXJ0XScsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdiYXNlLWNoYXJ0J1xyXG4gICAgICAgICAgICAgICAgfSxdIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcclxuICAgICAgICB7IHR5cGU6IFRoZW1lU2VydmljZSB9XHJcbiAgICBdOyB9O1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBsYWJlbHM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIG9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGNoYXJ0VHlwZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgY29sb3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBsZWdlbmQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHBsdWdpbnM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGNoYXJ0Q2xpY2s6IFt7IHR5cGU6IE91dHB1dCB9XSxcclxuICAgICAgICBjaGFydEhvdmVyOiBbeyB0eXBlOiBPdXRwdXQgfV1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzZUNoYXJ0RGlyZWN0aXZlO1xyXG59KCkpO1xyXG5leHBvcnQgeyBCYXNlQ2hhcnREaXJlY3RpdmUgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmRhdGE7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmRhdGFzZXRzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5sYWJlbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLm9wdGlvbnM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0VHlwZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuY29sb3JzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5sZWdlbmQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnBsdWdpbnM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0Q2xpY2s7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmNoYXJ0SG92ZXI7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLmN0eDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuY2hhcnQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5vbGQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZUNoYXJ0RGlyZWN0aXZlLnByb3RvdHlwZS5zdWJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydERpcmVjdGl2ZS5wcm90b3R5cGUuZWxlbWVudDtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnREaXJlY3RpdmUucHJvdG90eXBlLnRoZW1lU2VydmljZTtcclxufVxyIl19