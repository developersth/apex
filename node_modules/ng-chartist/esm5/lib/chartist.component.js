/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, Input } from '@angular/core';
import * as Chartist from 'chartist';
/**
 * Represent a chart event.
 * For possible values, check the Chartist docs.
 * @record
 */
import * as ɵngcc0 from '@angular/core';

var _c0 = ["*"];
export function ChartEvent() { }
var ChartistComponent = /** @class */ (function () {
    function ChartistComponent(element) {
        this.element = element.nativeElement;
    }
    /**
     * @return {?}
     */
    ChartistComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.type || !this.data) {
            Promise.reject('Expected at least type and data.');
        }
        return this.renderChart().then(function (chart) {
            if (_this.events !== undefined) {
                _this.bindEvents(chart);
            }
            return chart;
        });
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ChartistComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.update(changes);
    };
    /**
     * @return {?}
     */
    ChartistComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.chart) {
            this.chart.detach();
        }
    };
    /**
     * @return {?}
     */
    ChartistComponent.prototype.renderChart = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var promises = [
            this.type,
            this.element,
            this.data,
            this.options,
            this.responsiveOptions
        ];
        return Promise.all(promises).then(function (values) {
            var _a = tslib_1.__read(values), type = _a[0], args = _a.slice(1);
            if (!(type in Chartist)) {
                throw new Error(type + " is not a valid chart type");
            }
            _this.chart = ((/** @type {?} */ (Chartist)))[type].apply(((/** @type {?} */ (Chartist))), tslib_1.__spread(args));
            return _this.chart;
        });
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ChartistComponent.prototype.update = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.chart || 'type' in changes) {
            this.renderChart();
        }
        else {
            if (changes.data) {
                this.data = changes.data.currentValue;
            }
            if (changes.options) {
                this.options = changes.options.currentValue;
            }
            ((/** @type {?} */ (this.chart))).update(this.data, this.options);
        }
    };
    /**
     * @param {?} chart
     * @return {?}
     */
    ChartistComponent.prototype.bindEvents = /**
     * @param {?} chart
     * @return {?}
     */
    function (chart) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(Object.keys(this.events)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_1 = _c.value;
                chart.on(event_1, this.events[event_1]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /** @nocollapse */
    ChartistComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    ChartistComponent.propDecorators = {
        data: [{ type: Input }],
        type: [{ type: Input }],
        options: [{ type: Input }],
        responsiveOptions: [{ type: Input }],
        events: [{ type: Input }]
    };
ChartistComponent.ɵfac = function ChartistComponent_Factory(t) { return new (t || ChartistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartistComponent, selectors: [["x-chartist"]], inputs: { data: "data", options: "options", type: "type", responsiveOptions: "responsiveOptions", events: "events" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ChartistComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartistComponent, [{
        type: Component,
        args: [{
                selector: 'x-chartist',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { data: [{
            type: Input
        }], options: [{
            type: Input
        }], type: [{
            type: Input
        }], responsiveOptions: [{
            type: Input
        }], events: [{
            type: Input
        }] }); })();
    return ChartistComponent;
}());
export { ChartistComponent };
if (false) {
    /** @type {?} */
    ChartistComponent.prototype.data;
    /** @type {?} */
    ChartistComponent.prototype.type;
    /** @type {?} */
    ChartistComponent.prototype.options;
    /** @type {?} */
    ChartistComponent.prototype.responsiveOptions;
    /** @type {?} */
    ChartistComponent.prototype.events;
    /** @type {?} */
    ChartistComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.element;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmctY2hhcnRpc3QvZXNtNS9saWIvY2hhcnRpc3QuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQW1ITSxBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBV0EiLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIENoYXJ0aXN0IGZyb20gJ2NoYXJ0aXN0Jztcbi8qKlxuICogUmVwcmVzZW50IGEgY2hhcnQgZXZlbnQuXG4gKiBGb3IgcG9zc2libGUgdmFsdWVzLCBjaGVjayB0aGUgQ2hhcnRpc3QgZG9jcy5cbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoYXJ0RXZlbnQoKSB7IH1cbnZhciBDaGFydGlzdENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFydGlzdENvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUgfHwgIXRoaXMuZGF0YSkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoJ0V4cGVjdGVkIGF0IGxlYXN0IHR5cGUgYW5kIGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ2hhcnQoKS50aGVuKGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmluZEV2ZW50cyhjaGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKGNoYW5nZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2hhcnRpc3RDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckNoYXJ0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHByb21pc2VzID0gW1xuICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdGhpcy5yZXNwb25zaXZlT3B0aW9uc1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQodmFsdWVzKSwgdHlwZSA9IF9hWzBdLCBhcmdzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAoISh0eXBlIGluIENoYXJ0aXN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IGEgdmFsaWQgY2hhcnQgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNoYXJ0ID0gKCgvKiogQHR5cGUgez99ICovIChDaGFydGlzdCkpKVt0eXBlXS5hcHBseSgoKC8qKiBAdHlwZSB7P30gKi8gKENoYXJ0aXN0KSkpLCB0c2xpYl8xLl9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFydDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENoYXJ0aXN0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFydCB8fCAndHlwZScgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGNoYW5nZXMuZGF0YS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2hhbmdlcy5vcHRpb25zLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jaGFydCkpKS51cGRhdGUodGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gdHNsaWJfMS5fX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBjaGFydC5vbihldmVudF8xLCB0aGlzLmV2ZW50c1tldmVudF8xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcnRpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAneC1jaGFydGlzdCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PidcbiAgICAgICAgICAgICAgICB9XSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbiAgICBdOyB9O1xuICAgIENoYXJ0aXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgdHlwZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIG9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICByZXNwb25zaXZlT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGV2ZW50czogW3sgdHlwZTogSW5wdXQgfV1cbiAgICB9O1xuICAgIHJldHVybiBDaGFydGlzdENvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBDaGFydGlzdENvbXBvbmVudCB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENoYXJ0aXN0Q29tcG9uZW50LnByb3RvdHlwZS5kYXRhO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDaGFydGlzdENvbXBvbmVudC5wcm90b3R5cGUudHlwZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2hhcnRpc3RDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENoYXJ0aXN0Q29tcG9uZW50LnByb3RvdHlwZS5yZXNwb25zaXZlT3B0aW9ucztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2hhcnRpc3RDb21wb25lbnQucHJvdG90eXBlLmV2ZW50cztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2hhcnRpc3RDb21wb25lbnQucHJvdG90eXBlLmNoYXJ0O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2hhcnRpc3RDb21wb25lbnQucHJvdG90eXBlLmVsZW1lbnQ7XG59XG4iXX0=