import * as tslib_1 from "tslib";
import { Inject, Injectable, InjectionToken, LOCALE_ID, Optional } from '@angular/core';
import { DocumentRef, WindowRef } from '../../utils/browser-globals';
import { MapsAPILoader } from './maps-api-loader';
import * as ɵngcc0 from '@angular/core';
export var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
/**
 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
 * LazyMapsAPILoaderConfig}.
 */
export const LAZY_MAPS_API_CONFIG = new InjectionToken('angular-google-maps LAZY_MAPS_API_CONFIG');
let LazyMapsAPILoader = class LazyMapsAPILoader extends MapsAPILoader {
    constructor(config = null, w, d, localeId) {
        super();
        this.localeId = localeId;
        this._SCRIPT_ID = 'agmGoogleMapsApiScript';
        this.callbackName = `agmLazyMapsAPILoader`;
        this._config = config || {};
        this._windowRef = w;
        this._documentRef = d;
    }
    load() {
        const window = this._windowRef.getNativeWindow();
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this._scriptLoadingPromise) {
            return this._scriptLoadingPromise;
        }
        // this can happen in HMR situations or Stackblitz.io editors.
        const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);
        if (scriptOnPage) {
            this._assignScriptLoadingPromise(scriptOnPage);
            return this._scriptLoadingPromise;
        }
        const script = this._documentRef.getNativeDocument().createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this._SCRIPT_ID;
        script.src = this._getScriptSrc(this.callbackName);
        this._assignScriptLoadingPromise(script);
        this._documentRef.getNativeDocument().body.appendChild(script);
        return this._scriptLoadingPromise;
    }
    _assignScriptLoadingPromise(scriptElem) {
        this._scriptLoadingPromise = new Promise((resolve, reject) => {
            this._windowRef.getNativeWindow()[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    _getScriptSrc(callbackName) {
        let protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol;
        switch (protocolType) {
            case GoogleMapsScriptProtocol.AUTO:
                protocol = '';
                break;
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
        const queryParams = {
            v: this._config.apiVersion || 'quarterly',
            callback: callbackName,
            key: this._config.apiKey,
            client: this._config.clientId,
            channel: this._config.channel,
            libraries: this._config.libraries,
            region: this._config.region,
            language: this._config.language || this.localeId !== 'en-US' ? this.localeId : null,
        };
        const params = Object.keys(queryParams)
            .filter((k) => queryParams[k] != null)
            .filter((k) => {
            // remove empty arrays
            return !Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
        })
            .map((k) => {
            // join arrays as comma seperated strings
            let i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        })
            .map((entry) => {
            return `${entry.key}=${entry.value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
};
LazyMapsAPILoader.ɵfac = function LazyMapsAPILoader_Factory(t) { return new (t || LazyMapsAPILoader)(ɵngcc0.ɵɵinject(LAZY_MAPS_API_CONFIG, 8), ɵngcc0.ɵɵinject(WindowRef), ɵngcc0.ɵɵinject(DocumentRef), ɵngcc0.ɵɵinject(LOCALE_ID)); };
LazyMapsAPILoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LazyMapsAPILoader, factory: LazyMapsAPILoader.ɵfac });
LazyMapsAPILoader.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_MAPS_API_CONFIG,] }] },
    { type: WindowRef },
    { type: DocumentRef },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
LazyMapsAPILoader = tslib_1.__decorate([ tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(LAZY_MAPS_API_CONFIG)),
    tslib_1.__param(3, Inject(LOCALE_ID)),
    tslib_1.__metadata("design:paramtypes", [Object, WindowRef, DocumentRef, String])
], LazyMapsAPILoader);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LazyMapsAPILoader, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LAZY_MAPS_API_CONFIG]
            }] }, { type: WindowRef }, { type: DocumentRef }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
export { LazyMapsAPILoader };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttSEFzR0U7Ozs7Ozs7d0NBT3NDLEFBRXJDOzs7Ozs7Ozs7Ozs7OztrQ0FHbUIiLCJmaWxlIjoibGF6eS1tYXBzLWFwaS1sb2FkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgTE9DQUxFX0lELCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9jdW1lbnRSZWYsIFdpbmRvd1JlZiB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXItZ2xvYmFscyc7XG5pbXBvcnQgeyBNYXBzQVBJTG9hZGVyIH0gZnJvbSAnLi9tYXBzLWFwaS1sb2FkZXInO1xuZXhwb3J0IHZhciBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2w7XG4oZnVuY3Rpb24gKEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCkge1xuICAgIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbXCJIVFRQXCJdID0gMV0gPSBcIkhUVFBcIjtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiSFRUUFNcIl0gPSAyXSA9IFwiSFRUUFNcIjtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiQVVUT1wiXSA9IDNdID0gXCJBVVRPXCI7XG59KShHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgfHwgKEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCA9IHt9KSk7XG4vKipcbiAqIFRva2VuIGZvciB0aGUgY29uZmlnIG9mIHRoZSBMYXp5TWFwc0FQSUxvYWRlci4gUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IG9mIHR5cGUge0BsaW5rXG4gKiBMYXp5TWFwc0FQSUxvYWRlckNvbmZpZ30uXG4gKi9cbmV4cG9ydCBjb25zdCBMQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignYW5ndWxhci1nb29nbGUtbWFwcyBMQVpZX01BUFNfQVBJX0NPTkZJRycpO1xubGV0IExhenlNYXBzQVBJTG9hZGVyID0gY2xhc3MgTGF6eU1hcHNBUElMb2FkZXIgZXh0ZW5kcyBNYXBzQVBJTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSBudWxsLCB3LCBkLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsZUlkID0gbG9jYWxlSWQ7XG4gICAgICAgIHRoaXMuX1NDUklQVF9JRCA9ICdhZ21Hb29nbGVNYXBzQXBpU2NyaXB0JztcbiAgICAgICAgdGhpcy5jYWxsYmFja05hbWUgPSBgYWdtTGF6eU1hcHNBUElMb2FkZXJgO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMuX3dpbmRvd1JlZiA9IHc7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmID0gZDtcbiAgICB9XG4gICAgbG9hZCgpIHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpO1xuICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgICAgIC8vIEdvb2dsZSBtYXBzIGFscmVhZHkgbG9hZGVkIG9uIHRoZSBwYWdlLlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBpbiBITVIgc2l0dWF0aW9ucyBvciBTdGFja2JsaXR6LmlvIGVkaXRvcnMuXG4gICAgICAgIGNvbnN0IHNjcmlwdE9uUGFnZSA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuZ2V0RWxlbWVudEJ5SWQodGhpcy5fU0NSSVBUX0lEKTtcbiAgICAgICAgaWYgKHNjcmlwdE9uUGFnZSkge1xuICAgICAgICAgICAgdGhpcy5fYXNzaWduU2NyaXB0TG9hZGluZ1Byb21pc2Uoc2NyaXB0T25QYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JpcHQgPSB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuaWQgPSB0aGlzLl9TQ1JJUFRfSUQ7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLl9nZXRTY3JpcHRTcmModGhpcy5jYWxsYmFja05hbWUpO1xuICAgICAgICB0aGlzLl9hc3NpZ25TY3JpcHRMb2FkaW5nUHJvbWlzZShzY3JpcHQpO1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgIH1cbiAgICBfYXNzaWduU2NyaXB0TG9hZGluZ1Byb21pc2Uoc2NyaXB0RWxlbSkge1xuICAgICAgICB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dpbmRvd1JlZi5nZXROYXRpdmVXaW5kb3coKVt0aGlzLmNhbGxiYWNrTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdEVsZW0ub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFNjcmlwdFNyYyhjYWxsYmFja05hbWUpIHtcbiAgICAgICAgbGV0IHByb3RvY29sVHlwZSA9ICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLnByb3RvY29sKSB8fCBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wuSFRUUFM7XG4gICAgICAgIGxldCBwcm90b2NvbDtcbiAgICAgICAgc3dpdGNoIChwcm90b2NvbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkFVVE86XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFA6XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wuSFRUUFM6XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aCA9IHRoaXMuX2NvbmZpZy5ob3N0QW5kUGF0aCB8fCAnbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24gfHwgJ3F1YXJ0ZXJseScsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tOYW1lLFxuICAgICAgICAgICAga2V5OiB0aGlzLl9jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLl9jb25maWcuY2xpZW50SWQsXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLl9jb25maWcuY2hhbm5lbCxcbiAgICAgICAgICAgIGxpYnJhcmllczogdGhpcy5fY29uZmlnLmxpYnJhcmllcyxcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5fY29uZmlnLnJlZ2lvbixcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLl9jb25maWcubGFuZ3VhZ2UgfHwgdGhpcy5sb2NhbGVJZCAhPT0gJ2VuLVVTJyA/IHRoaXMubG9jYWxlSWQgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IHF1ZXJ5UGFyYW1zW2tdICE9IG51bGwpXG4gICAgICAgICAgICAuZmlsdGVyKChrKSA9PiB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pICYmIHF1ZXJ5UGFyYW1zW2tdLmxlbmd0aCA+IDApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcbiAgICAgICAgICAgIGxldCBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IGkuam9pbignLCcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtlbnRyeS5rZXl9PSR7ZW50cnkudmFsdWV9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdEFuZFBhdGh9PyR7cGFyYW1zfWA7XG4gICAgfVxufTtcbkxhenlNYXBzQVBJTG9hZGVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0xBWllfTUFQU19BUElfQ09ORklHLF0gfV0gfSxcbiAgICB7IHR5cGU6IFdpbmRvd1JlZiB9LFxuICAgIHsgdHlwZTogRG9jdW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTE9DQUxFX0lELF0gfV0gfVxuXTtcbkxhenlNYXBzQVBJTG9hZGVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgdHNsaWJfMS5fX3BhcmFtKDAsIE9wdGlvbmFsKCkpLCB0c2xpYl8xLl9fcGFyYW0oMCwgSW5qZWN0KExBWllfTUFQU19BUElfQ09ORklHKSksXG4gICAgdHNsaWJfMS5fX3BhcmFtKDMsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBXaW5kb3dSZWYsIERvY3VtZW50UmVmLCBTdHJpbmddKVxuXSwgTGF6eU1hcHNBUElMb2FkZXIpO1xuZXhwb3J0IHsgTGF6eU1hcHNBUElMb2FkZXIgfTtcbiJdfQ==