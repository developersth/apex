import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';
var PolylineManager_1;
import { Injectable, NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { createMVCEventObservable } from '../../utils/mvcarray-utils';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
let PolylineManager = PolylineManager_1 = class PolylineManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polylines = new Map();
    }
    static _convertPoints(line) {
        const path = line._getPoints().map((point) => {
            return { lat: point.latitude, lng: point.longitude };
        });
        return path;
    }
    static _convertPath(path) {
        const symbolPath = google.maps.SymbolPath[path];
        if (typeof symbolPath === 'number') {
            return symbolPath;
        }
        else {
            return path;
        }
    }
    static _convertIcons(line) {
        const icons = line._getIcons().map(agmIcon => ({
            fixedRotation: agmIcon.fixedRotation,
            offset: agmIcon.offset,
            repeat: agmIcon.repeat,
            icon: {
                anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),
                fillColor: agmIcon.fillColor,
                fillOpacity: agmIcon.fillOpacity,
                path: PolylineManager_1._convertPath(agmIcon.path),
                rotation: agmIcon.rotation,
                scale: agmIcon.scale,
                strokeColor: agmIcon.strokeColor,
                strokeOpacity: agmIcon.strokeOpacity,
                strokeWeight: agmIcon.strokeWeight,
            },
        }));
        // prune undefineds;
        icons.forEach(icon => {
            Object.entries(icon).forEach(([key, val]) => {
                if (typeof val === 'undefined') {
                    delete icon[key];
                }
            });
            if (typeof icon.icon.anchor.x === 'undefined' ||
                typeof icon.icon.anchor.y === 'undefined') {
                delete icon.icon.anchor;
            }
        });
        return icons;
    }
    addPolyline(line) {
        const polylinePromise = this._mapsWrapper.getNativeMap()
            .then(() => [PolylineManager_1._convertPoints(line),
            PolylineManager_1._convertIcons(line)])
            .then(([path, icons]) => this._mapsWrapper.createPolyline({
            clickable: line.clickable,
            draggable: line.draggable,
            editable: line.editable,
            geodesic: line.geodesic,
            strokeColor: line.strokeColor,
            strokeOpacity: line.strokeOpacity,
            strokeWeight: line.strokeWeight,
            visible: line.visible,
            zIndex: line.zIndex,
            path: path,
            icons: icons,
        }));
        this._polylines.set(line, polylinePromise);
    }
    updatePolylinePoints(line) {
        const path = PolylineManager_1._convertPoints(line);
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => { return this._zone.run(() => { l.setPath(path); }); });
    }
    updateIconSequences(line) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this._mapsWrapper.getNativeMap();
            const icons = PolylineManager_1._convertIcons(line);
            const m = this._polylines.get(line);
            if (m == null) {
                return;
            }
            return m.then(l => this._zone.run(() => l.setOptions({ icons: icons })));
        });
    }
    setPolylineOptions(line, options) {
        return this._polylines.get(line).then((l) => { l.setOptions(options); });
    }
    deletePolyline(line) {
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => {
            return this._zone.run(() => {
                l.setMap(null);
                this._polylines.delete(line);
            });
        });
    }
    getMVCPath(agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const polyline = yield this._polylines.get(agmPolyline);
            return polyline.getPath();
        });
    }
    getPath(agmPolyline) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.getMVCPath(agmPolyline)).getArray();
        });
    }
    createEventObservable(eventName, line) {
        return new Observable((observer) => {
            this._polylines.get(line).then((l) => {
                l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    createPathEventObservable(line) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mvcPath = yield this.getMVCPath(line);
            return createMVCEventObservable(mvcPath);
        });
    }
};
PolylineManager.ɵfac = function PolylineManager_Factory(t) { return new (t || PolylineManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
PolylineManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PolylineManager, factory: PolylineManager.ɵfac });
PolylineManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: NgZone }
];
PolylineManager = PolylineManager_1 = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
], PolylineManager);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolylineManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: ɵngcc0.NgZone }]; }, null); })();
export { PolylineManager };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQGFnbS9jb3JlL2VzbTIwMTUvc2VydmljZXMvbWFuYWdlcnMvcG9seWxpbmUtbWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2R0FzSUU7Ozs7OzBEQUt3RCxBQUV2RDs7Ozt1R0FDaUIiLCJmaWxlIjoicG9seWxpbmUtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG52YXIgUG9seWxpbmVNYW5hZ2VyXzE7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNyZWF0ZU1WQ0V2ZW50T2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL212Y2FycmF5LXV0aWxzJztcbmltcG9ydCB7IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0gZnJvbSAnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInO1xubGV0IFBvbHlsaW5lTWFuYWdlciA9IFBvbHlsaW5lTWFuYWdlcl8xID0gY2xhc3MgUG9seWxpbmVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhdGljIF9jb252ZXJ0UG9pbnRzKGxpbmUpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGxpbmUuX2dldFBvaW50cygpLm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGxhdDogcG9pbnQubGF0aXR1ZGUsIGxuZzogcG9pbnQubG9uZ2l0dWRlIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgc3RhdGljIF9jb252ZXJ0UGF0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbFBhdGggPSBnb29nbGUubWFwcy5TeW1ib2xQYXRoW3BhdGhdO1xuICAgICAgICBpZiAodHlwZW9mIHN5bWJvbFBhdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBfY29udmVydEljb25zKGxpbmUpIHtcbiAgICAgICAgY29uc3QgaWNvbnMgPSBsaW5lLl9nZXRJY29ucygpLm1hcChhZ21JY29uID0+ICh7XG4gICAgICAgICAgICBmaXhlZFJvdGF0aW9uOiBhZ21JY29uLmZpeGVkUm90YXRpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IGFnbUljb24ub2Zmc2V0LFxuICAgICAgICAgICAgcmVwZWF0OiBhZ21JY29uLnJlcGVhdCxcbiAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IG5ldyBnb29nbGUubWFwcy5Qb2ludChhZ21JY29uLmFuY2hvclgsIGFnbUljb24uYW5jaG9yWSksXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBhZ21JY29uLmZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogYWdtSWNvbi5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgICBwYXRoOiBQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydFBhdGgoYWdtSWNvbi5wYXRoKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogYWdtSWNvbi5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogYWdtSWNvbi5zY2FsZSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogYWdtSWNvbi5zdHJva2VDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBhZ21JY29uLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBhZ21JY29uLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gcHJ1bmUgdW5kZWZpbmVkcztcbiAgICAgICAgaWNvbnMuZm9yRWFjaChpY29uID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGljb24pLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGljb25ba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvbi5pY29uLmFuY2hvci54ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBpY29uLmljb24uYW5jaG9yLnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGljb24uaWNvbi5hbmNob3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWNvbnM7XG4gICAgfVxuICAgIGFkZFBvbHlsaW5lKGxpbmUpIHtcbiAgICAgICAgY29uc3QgcG9seWxpbmVQcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuZ2V0TmF0aXZlTWFwKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IFtQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydFBvaW50cyhsaW5lKSxcbiAgICAgICAgICAgIFBvbHlsaW5lTWFuYWdlcl8xLl9jb252ZXJ0SWNvbnMobGluZSldKVxuICAgICAgICAgICAgLnRoZW4oKFtwYXRoLCBpY29uc10pID0+IHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZVBvbHlsaW5lKHtcbiAgICAgICAgICAgIGNsaWNrYWJsZTogbGluZS5jbGlja2FibGUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGxpbmUuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IGxpbmUuZWRpdGFibGUsXG4gICAgICAgICAgICBnZW9kZXNpYzogbGluZS5nZW9kZXNpYyxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBsaW5lLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogbGluZS5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBsaW5lLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IGxpbmUudmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogbGluZS56SW5kZXgsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgaWNvbnM6IGljb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcy5zZXQobGluZSwgcG9seWxpbmVQcm9taXNlKTtcbiAgICB9XG4gICAgdXBkYXRlUG9seWxpbmVQb2ludHMobGluZSkge1xuICAgICAgICBjb25zdCBwYXRoID0gUG9seWxpbmVNYW5hZ2VyXzEuX2NvbnZlcnRQb2ludHMobGluZSk7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobCkgPT4geyByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4geyBsLnNldFBhdGgocGF0aCk7IH0pOyB9KTtcbiAgICB9XG4gICAgdXBkYXRlSWNvblNlcXVlbmNlcyhsaW5lKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpO1xuICAgICAgICAgICAgY29uc3QgaWNvbnMgPSBQb2x5bGluZU1hbmFnZXJfMS5fY29udmVydEljb25zKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XG4gICAgICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG0udGhlbihsID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IGwuc2V0T3B0aW9ucyh7IGljb25zOiBpY29ucyB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0UG9seWxpbmVPcHRpb25zKGxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbigobCkgPT4geyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH1cbiAgICBkZWxldGVQb2x5bGluZShsaW5lKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMuZGVsZXRlKGxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRNVkNQYXRoKGFnbVBvbHlsaW5lKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbHlsaW5lID0geWllbGQgdGhpcy5fcG9seWxpbmVzLmdldChhZ21Qb2x5bGluZSk7XG4gICAgICAgICAgICByZXR1cm4gcG9seWxpbmUuZ2V0UGF0aCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGF0aChhZ21Qb2x5bGluZSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIHRoaXMuZ2V0TVZDUGF0aChhZ21Qb2x5bGluZSkpLmdldEFycmF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVFdmVudE9ic2VydmFibGUoZXZlbnROYW1lLCBsaW5lKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbigobCkgPT4ge1xuICAgICAgICAgICAgICAgIGwuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQYXRoRXZlbnRPYnNlcnZhYmxlKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbXZjUGF0aCA9IHlpZWxkIHRoaXMuZ2V0TVZDUGF0aChsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVNVkNFdmVudE9ic2VydmFibGUobXZjUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5Qb2x5bGluZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBHb29nbGVNYXBzQVBJV3JhcHBlciB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5Qb2x5bGluZU1hbmFnZXIgPSBQb2x5bGluZU1hbmFnZXJfMSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHb29nbGVNYXBzQVBJV3JhcHBlciwgTmdab25lXSlcbl0sIFBvbHlsaW5lTWFuYWdlcik7XG5leHBvcnQgeyBQb2x5bGluZU1hbmFnZXIgfTtcbiJdfQ==