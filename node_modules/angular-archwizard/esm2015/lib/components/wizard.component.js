/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, HostBinding, Input, QueryList, } from '@angular/core';
import { WizardStep } from '../util/wizard-step.interface';
import { MovingDirection } from '../util/moving-direction.enum';
import { ConfigurableNavigationMode } from '../navigation/configurable-navigation-mode';
/**
 * The `aw-wizard` component defines the root component of a wizard.
 * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size
 * of its navigation bar.
 *
 * ### Syntax
 * ```html
 * <aw-wizard [navBarLocation]="location of navigation bar" [navBarLayout]="layout of navigation bar">
 *     ...
 * </aw-wizard>
 * ```
 *
 * ### Example
 *
 * Without completion step:
 *
 * ```html
 * <aw-wizard navBarLocation="top" navBarLayout="small">
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-step>...</aw-wizard-step>
 * </aw-wizard>
 * ```
 *
 * With completion step:
 *
 * ```html
 * <aw-wizard navBarLocation="top" navBarLayout="small">
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-completion-step>...</aw-wizard-completion-step>
 * </aw-wizard>
 * ```
 *
 * @author Marc Arndt
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = function (a0, a1, a2, a3, a4, a5, a6) { return { vertical: a0, horizontal: a1, small: a2, "large-filled": a3, "large-filled-symbols": a4, "large-empty": a5, "large-empty-symbols": a6 }; };
function WizardComponent_aw_wizard_navigation_bar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "aw-wizard-navigation-bar", 2);
} if (rf & 2) {
    const ctx_r62 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r62.navBarDirection)("ngClass", ɵngcc0.ɵɵpureFunction7(2, _c0, ctx_r62.navBarLocation == "left", ctx_r62.navBarLocation == "top", ctx_r62.navBarLayout == "small", ctx_r62.navBarLayout == "large-filled", ctx_r62.navBarLayout == "large-filled-symbols", ctx_r62.navBarLayout == "large-empty", ctx_r62.navBarLayout == "large-empty-symbols"));
} }
function WizardComponent_aw_wizard_navigation_bar_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "aw-wizard-navigation-bar", 2);
} if (rf & 2) {
    const ctx_r63 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r63.navBarDirection)("ngClass", ɵngcc0.ɵɵpureFunction7(2, _c0, ctx_r63.navBarLocation == "right", ctx_r63.navBarLocation == "bottom", ctx_r63.navBarLayout == "small", ctx_r63.navBarLayout == "large-filled", ctx_r63.navBarLayout == "large-filled-symbols", ctx_r63.navBarLayout == "large-empty", ctx_r63.navBarLayout == "large-empty-symbols"));
} }
const _c1 = function (a1, a2) { return { "wizard-steps": true, vertical: a1, horizontal: a2 }; };
const _c2 = ["*"];
export class WizardComponent {
    /**
     * Constructor
     */
    constructor() {
        /**
         * The location of the navigation bar inside the wizard.
         * This location can be either top, bottom, left or right
         */
        this.navBarLocation = 'top';
        /**
         * The layout of the navigation bar inside the wizard.
         * The layout can be either small, large-filled, large-empty or large-symbols
         */
        this.navBarLayout = 'small';
        /**
         * The direction in which the steps inside the navigation bar should be shown.
         * The direction can be either `left-to-right` or `right-to-left`
         */
        this.navBarDirection = 'left-to-right';
        this._defaultStepIndex = 0;
        /**
         * True, if the navigation bar shouldn't be used for navigating
         */
        this.disableNavigationBar = false;
        /**
         * The navigation mode used to navigate inside the wizard
         *
         * For outside access, use the [[navigation]] getter.
         */
        this._navigation = new ConfigurableNavigationMode();
        /**
         * An array representation of all wizard steps belonging to this model
         *
         * For outside access, use the [[wizardSteps]] getter.
         */
        this._wizardSteps = [];
        /**
         * The index of the currently visible and selected step inside the wizardSteps QueryList.
         * If this wizard contains no steps, currentStepIndex is -1
         *
         * Note: Do not modify this field directly.  Instead, use navigation methods:
         * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].
         */
        this.currentStepIndex = -1;
    }
    /**
     * The initially selected step, represented by its index
     * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive
     * @return {?}
     */
    get defaultStepIndex() {
        // This value can be either:
        // - the index of a wizard step with a `selected` directive, or
        // - the default step index, set in the [[WizardComponent]]
        // This value can be either:
        // - the index of a wizard step with a `selected` directive, or
        // - the default step index, set in the [[WizardComponent]]
        /** @type {?} */
        const foundDefaultStep = this.wizardSteps.find((/**
         * @param {?} step
         * @return {?}
         */
        step => step.defaultSelected));
        if (foundDefaultStep) {
            return this.getIndexOfStep(foundDefaultStep);
        }
        else {
            return this._defaultStepIndex;
        }
    }
    /**
     * @param {?} defaultStepIndex
     * @return {?}
     */
    set defaultStepIndex(defaultStepIndex) {
        this._defaultStepIndex = defaultStepIndex;
    }
    /**
     * Returns true if this wizard uses a horizontal orientation.
     * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard
     *
     * @return {?} True if this wizard uses a horizontal orientation
     */
    get horizontalOrientation() {
        return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';
    }
    /**
     * Returns true if this wizard uses a vertical orientation.
     * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard
     *
     * @return {?} True if this wizard uses a vertical orientation
     */
    get verticalOrientation() {
        return this.navBarLocation === 'left' || this.navBarLocation === 'right';
    }
    /**
     * Initialization work
     * @return {?}
     */
    ngAfterContentInit() {
        // add a subscriber to the wizard steps QueryList to listen to changes in the DOM
        this.wizardStepsQueryList.changes.subscribe((/**
         * @param {?} changedWizardSteps
         * @return {?}
         */
        changedWizardSteps => {
            this.updateWizardSteps(changedWizardSteps.toArray());
        }));
        // initialize the model
        this.updateWizardSteps(this.wizardStepsQueryList.toArray());
        // finally reset the whole wizard componennt
        this.reset();
    }
    /**
     * The WizardStep object belonging to the currently visible and selected step.
     * The currentStep is always the currently selected wizard step.
     * The currentStep can be either completed, if it was visited earlier,
     * or not completed, if it is visited for the first time or its state is currently out of date.
     *
     * If this wizard contains no steps, currentStep is null
     * @return {?}
     */
    get currentStep() {
        if (this.hasStep(this.currentStepIndex)) {
            return this.wizardSteps[this.currentStepIndex];
        }
        else {
            return null;
        }
    }
    /**
     * The completeness of the wizard.
     * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false
     * @return {?}
     */
    get completed() {
        return this.wizardSteps.every((/**
         * @param {?} step
         * @return {?}
         */
        step => step.completed || step.optional));
    }
    /**
     * An array representation of all wizard steps belonging to this model
     * @return {?}
     */
    get wizardSteps() {
        return this._wizardSteps;
    }
    /**
     * Updates the wizard steps to the new array
     *
     * @private
     * @param {?} wizardSteps The updated wizard steps
     * @return {?}
     */
    updateWizardSteps(wizardSteps) {
        // the wizard is currently not in the initialization phase
        if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {
            this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);
        }
        this._wizardSteps = wizardSteps;
    }
    /**
     * The navigation mode used to navigate inside the wizard
     * @return {?}
     */
    get navigation() {
        return this._navigation;
    }
    /**
     * Updates the navigation mode for this wizard component
     *
     * @param {?} navigation The updated navigation mode
     * @return {?}
     */
    set navigation(navigation) {
        this._navigation = navigation;
    }
    /**
     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard
     *
     * @param {?} stepIndex The to be checked index of a step inside this wizard
     * @return {?} True if the given `stepIndex` is contained inside this wizard, false otherwise
     */
    hasStep(stepIndex) {
        return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;
    }
    /**
     * Checks if this wizard has a previous step, compared to the current step
     *
     * @return {?} True if this wizard has a previous step before the current step
     */
    hasPreviousStep() {
        return this.hasStep(this.currentStepIndex - 1);
    }
    /**
     * Checks if this wizard has a next step, compared to the current step
     *
     * @return {?} True if this wizard has a next step after the current step
     */
    hasNextStep() {
        return this.hasStep(this.currentStepIndex + 1);
    }
    /**
     * Checks if this wizard is currently inside its last step
     *
     * @return {?} True if the wizard is currently inside its last step
     */
    isLastStep() {
        return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;
    }
    /**
     * Finds the [[WizardStep]] at the given index `stepIndex`.
     * If no [[WizardStep]] exists at the given index an Error is thrown
     *
     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist
     * @param {?} stepIndex The given index
     * @return {?} The found [[WizardStep]] at the given index `stepIndex`
     */
    getStepAtIndex(stepIndex) {
        if (!this.hasStep(stepIndex)) {
            throw new Error(`Expected a known step, but got stepIndex: ${stepIndex}.`);
        }
        return this.wizardSteps[stepIndex];
    }
    /**
     * Finds the index of the step with the given `stepId`.
     * If no step with the given `stepId` exists, `-1` is returned
     *
     * @param {?} stepId The given step id
     * @return {?} The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard
     */
    getIndexOfStepWithId(stepId) {
        return this.wizardSteps.findIndex((/**
         * @param {?} step
         * @return {?}
         */
        step => step.stepId === stepId));
    }
    /**
     * Finds the index of the given [[WizardStep]] `step`.
     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned
     *
     * @param {?} step The given [[WizardStep]]
     * @return {?} The found index of `step` or `-1` if the step is not included in the wizard
     */
    getIndexOfStep(step) {
        return this.wizardSteps.indexOf(step);
    }
    /**
     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.
     *
     * @param {?} destinationStep The given destination step
     * @return {?} The calculated [[MovingDirection]]
     */
    getMovingDirection(destinationStep) {
        /** @type {?} */
        let movingDirection;
        if (destinationStep > this.currentStepIndex) {
            movingDirection = MovingDirection.Forwards;
        }
        else if (destinationStep < this.currentStepIndex) {
            movingDirection = MovingDirection.Backwards;
        }
        else {
            movingDirection = MovingDirection.Stay;
        }
        return movingDirection;
    }
    /**
     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.
     *
     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.
     * Navigation by navigation bar is governed by [[isNavigable]].
     *
     * @param {?} destinationIndex The index of the destination step
     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise
     */
    canGoToStep(destinationIndex) {
        return this.navigation.canGoToStep(this, destinationIndex);
    }
    /**
     * Tries to transition to the wizard step, as denoted by the given destination index.
     *
     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].
     * The [[canGoToStep]] method will be called automatically.
     *
     * @param {?} destinationIndex The index of the destination wizard step, which should be entered
     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned
     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned
     * @return {?}
     */
    goToStep(destinationIndex, preFinalize, postFinalize) {
        return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);
    }
    /**
     * Tries to transition the wizard to the previous step
     *
     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned
     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned
     * @return {?}
     */
    goToPreviousStep(preFinalize, postFinalize) {
        return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);
    }
    /**
     * Tries to transition the wizard to the next step
     *
     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned
     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned
     * @return {?}
     */
    goToNextStep(preFinalize, postFinalize) {
        return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);
    }
    /**
     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.
     *
     * @param {?} destinationIndex The index of the destination step
     * @return {?} True if the step can be navigated to, false otherwise
     */
    isNavigable(destinationIndex) {
        return this.navigation.isNavigable(this, destinationIndex);
    }
    /**
     * Resets the state of this wizard.
     * @return {?}
     */
    reset() {
        this.navigation.reset(this);
    }
}
WizardComponent.ɵfac = function WizardComponent_Factory(t) { return new (t || WizardComponent)(); };
WizardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WizardComponent, selectors: [["aw-wizard"]], contentQueries: function WizardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStep, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wizardStepsQueryList = _t);
    } }, hostVars: 4, hostBindings: function WizardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("horizontal", ctx.horizontalOrientation)("vertical", ctx.verticalOrientation);
    } }, inputs: { navBarLocation: "navBarLocation", navBarLayout: "navBarLayout", navBarDirection: "navBarDirection", disableNavigationBar: "disableNavigationBar", defaultStepIndex: "defaultStepIndex" }, ngContentSelectors: _c2, decls: 4, vars: 6, consts: [[3, "direction", "ngClass", 4, "ngIf"], [3, "ngClass"], [3, "direction", "ngClass"]], template: function WizardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, WizardComponent_aw_wizard_navigation_bar_0_Template, 1, 10, "aw-wizard-navigation-bar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, WizardComponent_aw_wizard_navigation_bar_3_Template, 1, 10, "aw-wizard-navigation-bar", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.navBarLocation == "top" || ctx.navBarLocation == "left");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(3, _c1, ctx.navBarLocation == "left" || ctx.navBarLocation == "right", ctx.navBarLocation == "top" || ctx.navBarLocation == "bottom"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navBarLocation == "bottom" || ctx.navBarLocation == "right");
    } }, encapsulation: 2 });
/** @nocollapse */
WizardComponent.ctorParameters = () => [];
WizardComponent.propDecorators = {
    wizardStepsQueryList: [{ type: ContentChildren, args: [WizardStep,] }],
    navBarLocation: [{ type: Input }],
    navBarLayout: [{ type: Input }],
    navBarDirection: [{ type: Input }],
    defaultStepIndex: [{ type: Input }],
    disableNavigationBar: [{ type: Input }],
    horizontalOrientation: [{ type: HostBinding, args: ['class.horizontal',] }],
    verticalOrientation: [{ type: HostBinding, args: ['class.vertical',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WizardComponent, [{
        type: Component,
        args: [{
                selector: 'aw-wizard',
                template: "<aw-wizard-navigation-bar\n  [direction]=\"navBarDirection\"\n  *ngIf=\"navBarLocation == 'top' || navBarLocation == 'left'\"\n  [ngClass]=\"{\n    vertical: navBarLocation == 'left',\n    horizontal: navBarLocation == 'top',\n    small: navBarLayout == 'small',\n    'large-filled': navBarLayout == 'large-filled',\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\n    'large-empty': navBarLayout == 'large-empty',\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\n  }\">\n</aw-wizard-navigation-bar>\n\n<div [ngClass]=\"{\n  'wizard-steps': true,\n  vertical: navBarLocation == 'left' || navBarLocation == 'right',\n  horizontal: navBarLocation == 'top' || navBarLocation == 'bottom'\n}\">\n  <ng-content></ng-content>\n</div>\n\n<aw-wizard-navigation-bar\n  [direction]=\"navBarDirection\"\n  *ngIf=\"navBarLocation == 'bottom' || navBarLocation == 'right'\"\n  [ngClass]=\"{\n    vertical: navBarLocation == 'right',\n    horizontal: navBarLocation == 'bottom',\n    small: navBarLayout == 'small',\n    'large-filled': navBarLayout == 'large-filled',\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\n    'large-empty': navBarLayout == 'large-empty',\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\n  }\">\n</aw-wizard-navigation-bar>\n"
            }]
    }], function () { return []; }, { navBarLocation: [{
            type: Input
        }], navBarLayout: [{
            type: Input
        }], navBarDirection: [{
            type: Input
        }], disableNavigationBar: [{
            type: Input
        }], defaultStepIndex: [{
            type: Input
        }], horizontalOrientation: [{
            type: HostBinding,
            args: ['class.horizontal']
        }], verticalOrientation: [{
            type: HostBinding,
            args: ['class.vertical']
        }], wizardStepsQueryList: [{
            type: ContentChildren,
            args: [WizardStep]
        }] }); })();
if (false) {
    /**
     * A QueryList containing all [[WizardStep]]s inside this wizard
     * @type {?}
     */
    WizardComponent.prototype.wizardStepsQueryList;
    /**
     * The location of the navigation bar inside the wizard.
     * This location can be either top, bottom, left or right
     * @type {?}
     */
    WizardComponent.prototype.navBarLocation;
    /**
     * The layout of the navigation bar inside the wizard.
     * The layout can be either small, large-filled, large-empty or large-symbols
     * @type {?}
     */
    WizardComponent.prototype.navBarLayout;
    /**
     * The direction in which the steps inside the navigation bar should be shown.
     * The direction can be either `left-to-right` or `right-to-left`
     * @type {?}
     */
    WizardComponent.prototype.navBarDirection;
    /**
     * @type {?}
     * @private
     */
    WizardComponent.prototype._defaultStepIndex;
    /**
     * True, if the navigation bar shouldn't be used for navigating
     * @type {?}
     */
    WizardComponent.prototype.disableNavigationBar;
    /**
     * The navigation mode used to navigate inside the wizard
     *
     * For outside access, use the [[navigation]] getter.
     * @type {?}
     * @private
     */
    WizardComponent.prototype._navigation;
    /**
     * An array representation of all wizard steps belonging to this model
     *
     * For outside access, use the [[wizardSteps]] getter.
     * @type {?}
     * @private
     */
    WizardComponent.prototype._wizardSteps;
    /**
     * The index of the currently visible and selected step inside the wizardSteps QueryList.
     * If this wizard contains no steps, currentStepIndex is -1
     *
     * Note: Do not modify this field directly.  Instead, use navigation methods:
     * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].
     * @type {?}
     */
    WizardComponent.prototype.currentStepIndex;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvYW5ndWxhci1hcmNod2l6YXJkL2VzbTIwMTUvbGliL2NvbXBvbmVudHMvd2l6YXJkLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNlVDLDRCQU1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFZQSIsImZpbGUiOiJ3aXphcmQuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEhvc3RCaW5kaW5nLCBJbnB1dCwgUXVlcnlMaXN0LCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcCB9IGZyb20gJy4uL3V0aWwvd2l6YXJkLXN0ZXAuaW50ZXJmYWNlJztcbmltcG9ydCB7IE1vdmluZ0RpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWwvbW92aW5nLWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IENvbmZpZ3VyYWJsZU5hdmlnYXRpb25Nb2RlIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi9jb25maWd1cmFibGUtbmF2aWdhdGlvbi1tb2RlJztcbi8qKlxuICogVGhlIGBhdy13aXphcmRgIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IGNvbXBvbmVudCBvZiBhIHdpemFyZC5cbiAqIFRocm91Z2ggdGhlIHNldHRpbmcgb2YgaW5wdXQgcGFyYW1ldGVycyBmb3IgdGhlIGBhdy13aXphcmRgIGNvbXBvbmVudCBpdCdzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24gYW5kIHNpemVcbiAqIG9mIGl0cyBuYXZpZ2F0aW9uIGJhci5cbiAqXG4gKiAjIyMgU3ludGF4XG4gKiBgYGBodG1sXG4gKiA8YXctd2l6YXJkIFtuYXZCYXJMb2NhdGlvbl09XCJsb2NhdGlvbiBvZiBuYXZpZ2F0aW9uIGJhclwiIFtuYXZCYXJMYXlvdXRdPVwibGF5b3V0IG9mIG5hdmlnYXRpb24gYmFyXCI+XG4gKiAgICAgLi4uXG4gKiA8L2F3LXdpemFyZD5cbiAqIGBgYFxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogV2l0aG91dCBjb21wbGV0aW9uIHN0ZXA6XG4gKlxuICogYGBgaHRtbFxuICogPGF3LXdpemFyZCBuYXZCYXJMb2NhdGlvbj1cInRvcFwiIG5hdkJhckxheW91dD1cInNtYWxsXCI+XG4gKiAgICAgPGF3LXdpemFyZC1zdGVwPi4uLjwvYXctd2l6YXJkLXN0ZXA+XG4gKiAgICAgPGF3LXdpemFyZC1zdGVwPi4uLjwvYXctd2l6YXJkLXN0ZXA+XG4gKiA8L2F3LXdpemFyZD5cbiAqIGBgYFxuICpcbiAqIFdpdGggY29tcGxldGlvbiBzdGVwOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhdy13aXphcmQgbmF2QmFyTG9jYXRpb249XCJ0b3BcIiBuYXZCYXJMYXlvdXQ9XCJzbWFsbFwiPlxuICogICAgIDxhdy13aXphcmQtc3RlcD4uLi48L2F3LXdpemFyZC1zdGVwPlxuICogICAgIDxhdy13aXphcmQtc3RlcD4uLi48L2F3LXdpemFyZC1zdGVwPlxuICogICAgIDxhdy13aXphcmQtY29tcGxldGlvbi1zdGVwPi4uLjwvYXctd2l6YXJkLWNvbXBsZXRpb24tc3RlcD5cbiAqIDwvYXctd2l6YXJkPlxuICogYGBgXG4gKlxuICogQGF1dGhvciBNYXJjIEFybmR0XG4gKi9cbmV4cG9ydCBjbGFzcyBXaXphcmRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIG5hdmlnYXRpb24gYmFyIGluc2lkZSB0aGUgd2l6YXJkLlxuICAgICAgICAgKiBUaGlzIGxvY2F0aW9uIGNhbiBiZSBlaXRoZXIgdG9wLCBib3R0b20sIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2QmFyTG9jYXRpb24gPSAndG9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXlvdXQgb2YgdGhlIG5hdmlnYXRpb24gYmFyIGluc2lkZSB0aGUgd2l6YXJkLlxuICAgICAgICAgKiBUaGUgbGF5b3V0IGNhbiBiZSBlaXRoZXIgc21hbGwsIGxhcmdlLWZpbGxlZCwgbGFyZ2UtZW1wdHkgb3IgbGFyZ2Utc3ltYm9sc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZCYXJMYXlvdXQgPSAnc21hbGwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgc3RlcHMgaW5zaWRlIHRoZSBuYXZpZ2F0aW9uIGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAqIFRoZSBkaXJlY3Rpb24gY2FuIGJlIGVpdGhlciBgbGVmdC10by1yaWdodGAgb3IgYHJpZ2h0LXRvLWxlZnRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdkJhckRpcmVjdGlvbiA9ICdsZWZ0LXRvLXJpZ2h0JztcbiAgICAgICAgdGhpcy5fZGVmYXVsdFN0ZXBJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlLCBpZiB0aGUgbmF2aWdhdGlvbiBiYXIgc2hvdWxkbid0IGJlIHVzZWQgZm9yIG5hdmlnYXRpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZU5hdmlnYXRpb25CYXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYXZpZ2F0aW9uIG1vZGUgdXNlZCB0byBuYXZpZ2F0ZSBpbnNpZGUgdGhlIHdpemFyZFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3Igb3V0c2lkZSBhY2Nlc3MsIHVzZSB0aGUgW1tuYXZpZ2F0aW9uXV0gZ2V0dGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbiA9IG5ldyBDb25maWd1cmFibGVOYXZpZ2F0aW9uTW9kZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYWxsIHdpemFyZCBzdGVwcyBiZWxvbmdpbmcgdG8gdGhpcyBtb2RlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3Igb3V0c2lkZSBhY2Nlc3MsIHVzZSB0aGUgW1t3aXphcmRTdGVwc11dIGdldHRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpemFyZFN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGFuZCBzZWxlY3RlZCBzdGVwIGluc2lkZSB0aGUgd2l6YXJkU3RlcHMgUXVlcnlMaXN0LlxuICAgICAgICAgKiBJZiB0aGlzIHdpemFyZCBjb250YWlucyBubyBzdGVwcywgY3VycmVudFN0ZXBJbmRleCBpcyAtMVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBEbyBub3QgbW9kaWZ5IHRoaXMgZmllbGQgZGlyZWN0bHkuICBJbnN0ZWFkLCB1c2UgbmF2aWdhdGlvbiBtZXRob2RzOlxuICAgICAgICAgKiBbW2dvVG9TdGVwXV0sIFtbZ29Ub1ByZXZpb3VzU3RlcF1dLCBbW2dvVG9OZXh0U3RlcF1dLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcEluZGV4ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgc3RlcCwgcmVwcmVzZW50ZWQgYnkgaXRzIGluZGV4XG4gICAgICogQmV3YXJlOiBUaGlzIGluaXRpYWwgZGVmYXVsdCBpcyBvbmx5IHVzZWQgaWYgbm8gd2l6YXJkIHN0ZXAgaGFzIGJlZW4gZW5oYW5jZWQgd2l0aCB0aGUgYHNlbGVjdGVkYCBkaXJlY3RpdmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0U3RlcEluZGV4KCkge1xuICAgICAgICAvLyBUaGlzIHZhbHVlIGNhbiBiZSBlaXRoZXI6XG4gICAgICAgIC8vIC0gdGhlIGluZGV4IG9mIGEgd2l6YXJkIHN0ZXAgd2l0aCBhIGBzZWxlY3RlZGAgZGlyZWN0aXZlLCBvclxuICAgICAgICAvLyAtIHRoZSBkZWZhdWx0IHN0ZXAgaW5kZXgsIHNldCBpbiB0aGUgW1tXaXphcmRDb21wb25lbnRdXVxuICAgICAgICAvLyBUaGlzIHZhbHVlIGNhbiBiZSBlaXRoZXI6XG4gICAgICAgIC8vIC0gdGhlIGluZGV4IG9mIGEgd2l6YXJkIHN0ZXAgd2l0aCBhIGBzZWxlY3RlZGAgZGlyZWN0aXZlLCBvclxuICAgICAgICAvLyAtIHRoZSBkZWZhdWx0IHN0ZXAgaW5kZXgsIHNldCBpbiB0aGUgW1tXaXphcmRDb21wb25lbnRdXVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGZvdW5kRGVmYXVsdFN0ZXAgPSB0aGlzLndpemFyZFN0ZXBzLmZpbmQoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHN0ZXBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHN0ZXAgPT4gc3RlcC5kZWZhdWx0U2VsZWN0ZWQpKTtcbiAgICAgICAgaWYgKGZvdW5kRGVmYXVsdFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4T2ZTdGVwKGZvdW5kRGVmYXVsdFN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTdGVwSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWZhdWx0U3RlcEluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgZGVmYXVsdFN0ZXBJbmRleChkZWZhdWx0U3RlcEluZGV4KSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRTdGVwSW5kZXggPSBkZWZhdWx0U3RlcEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB3aXphcmQgdXNlcyBhIGhvcml6b250YWwgb3JpZW50YXRpb24uXG4gICAgICogVGhlIHdpemFyZCB1c2VzIGEgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiwgaWZmIHRoZSBuYXZpZ2F0aW9uIGJhciBpcyBzaG93biBhdCB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGlzIHdpemFyZFxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVHJ1ZSBpZiB0aGlzIHdpemFyZCB1c2VzIGEgaG9yaXpvbnRhbCBvcmllbnRhdGlvblxuICAgICAqL1xuICAgIGdldCBob3Jpem9udGFsT3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdkJhckxvY2F0aW9uID09PSAndG9wJyB8fCB0aGlzLm5hdkJhckxvY2F0aW9uID09PSAnYm90dG9tJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgd2l6YXJkIHVzZXMgYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbi5cbiAgICAgKiBUaGUgd2l6YXJkIHVzZXMgYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbiwgaWZmIHRoZSBuYXZpZ2F0aW9uIGJhciBpcyBzaG93biBhdCB0aGUgbGVmdCBvciByaWdodCBvZiB0aGlzIHdpemFyZFxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVHJ1ZSBpZiB0aGlzIHdpemFyZCB1c2VzIGEgdmVydGljYWwgb3JpZW50YXRpb25cbiAgICAgKi9cbiAgICBnZXQgdmVydGljYWxPcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2QmFyTG9jYXRpb24gPT09ICdsZWZ0JyB8fCB0aGlzLm5hdkJhckxvY2F0aW9uID09PSAncmlnaHQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbiB3b3JrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIGFkZCBhIHN1YnNjcmliZXIgdG8gdGhlIHdpemFyZCBzdGVwcyBRdWVyeUxpc3QgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIERPTVxuICAgICAgICB0aGlzLndpemFyZFN0ZXBzUXVlcnlMaXN0LmNoYW5nZXMuc3Vic2NyaWJlKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VkV2l6YXJkU3RlcHNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGNoYW5nZWRXaXphcmRTdGVwcyA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdpemFyZFN0ZXBzKGNoYW5nZWRXaXphcmRTdGVwcy50b0FycmF5KCkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIG1vZGVsXG4gICAgICAgIHRoaXMudXBkYXRlV2l6YXJkU3RlcHModGhpcy53aXphcmRTdGVwc1F1ZXJ5TGlzdC50b0FycmF5KCkpO1xuICAgICAgICAvLyBmaW5hbGx5IHJlc2V0IHRoZSB3aG9sZSB3aXphcmQgY29tcG9uZW5udFxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBXaXphcmRTdGVwIG9iamVjdCBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnRseSB2aXNpYmxlIGFuZCBzZWxlY3RlZCBzdGVwLlxuICAgICAqIFRoZSBjdXJyZW50U3RlcCBpcyBhbHdheXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB3aXphcmQgc3RlcC5cbiAgICAgKiBUaGUgY3VycmVudFN0ZXAgY2FuIGJlIGVpdGhlciBjb21wbGV0ZWQsIGlmIGl0IHdhcyB2aXNpdGVkIGVhcmxpZXIsXG4gICAgICogb3Igbm90IGNvbXBsZXRlZCwgaWYgaXQgaXMgdmlzaXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgb3IgaXRzIHN0YXRlIGlzIGN1cnJlbnRseSBvdXQgb2YgZGF0ZS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgd2l6YXJkIGNvbnRhaW5zIG5vIHN0ZXBzLCBjdXJyZW50U3RlcCBpcyBudWxsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1N0ZXAodGhpcy5jdXJyZW50U3RlcEluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l6YXJkU3RlcHNbdGhpcy5jdXJyZW50U3RlcEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZW5lc3Mgb2YgdGhlIHdpemFyZC5cbiAgICAgKiBJZiB0aGUgd2l6YXJkIGhhcyBiZWVuIGNvbXBsZXRlZCwgaS5lLiBhbGwgc3RlcHMgYXJlIGVpdGhlciBjb21wbGV0ZWQgb3Igb3B0aW9uYWwsIHRoaXMgdmFsdWUgaXMgdHJ1ZSwgb3RoZXJ3aXNlIGl0IGlzIGZhbHNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgY29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXphcmRTdGVwcy5ldmVyeSgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RlcFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc3RlcCA9PiBzdGVwLmNvbXBsZXRlZCB8fCBzdGVwLm9wdGlvbmFsKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFsbCB3aXphcmQgc3RlcHMgYmVsb25naW5nIHRvIHRoaXMgbW9kZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCB3aXphcmRTdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpemFyZFN0ZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB3aXphcmQgc3RlcHMgdG8gdGhlIG5ldyBhcnJheVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHdpemFyZFN0ZXBzIFRoZSB1cGRhdGVkIHdpemFyZCBzdGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgdXBkYXRlV2l6YXJkU3RlcHMod2l6YXJkU3RlcHMpIHtcbiAgICAgICAgLy8gdGhlIHdpemFyZCBpcyBjdXJyZW50bHkgbm90IGluIHRoZSBpbml0aWFsaXphdGlvbiBwaGFzZVxuICAgICAgICBpZiAodGhpcy53aXphcmRTdGVwcy5sZW5ndGggPiAwICYmIHRoaXMuY3VycmVudFN0ZXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwSW5kZXggPSB3aXphcmRTdGVwcy5pbmRleE9mKHRoaXMud2l6YXJkU3RlcHNbdGhpcy5jdXJyZW50U3RlcEluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2l6YXJkU3RlcHMgPSB3aXphcmRTdGVwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hdmlnYXRpb24gbW9kZSB1c2VkIHRvIG5hdmlnYXRlIGluc2lkZSB0aGUgd2l6YXJkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgbmF2aWdhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5hdmlnYXRpb24gbW9kZSBmb3IgdGhpcyB3aXphcmQgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IG5hdmlnYXRpb24gVGhlIHVwZGF0ZWQgbmF2aWdhdGlvbiBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgbmF2aWdhdGlvbihuYXZpZ2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiBpbmRleCBgc3RlcEluZGV4YCBpcyBpbnNpZGUgdGhlIHJhbmdlIG9mIHBvc3NpYmxlIHdpemFyZCBzdGVwcyBpbnNpZGUgdGhpcyB3aXphcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gc3RlcEluZGV4IFRoZSB0byBiZSBjaGVja2VkIGluZGV4IG9mIGEgc3RlcCBpbnNpZGUgdGhpcyB3aXphcmRcbiAgICAgKiBAcmV0dXJuIHs/fSBUcnVlIGlmIHRoZSBnaXZlbiBgc3RlcEluZGV4YCBpcyBjb250YWluZWQgaW5zaWRlIHRoaXMgd2l6YXJkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBoYXNTdGVwKHN0ZXBJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXphcmRTdGVwcy5sZW5ndGggPiAwICYmIDAgPD0gc3RlcEluZGV4ICYmIHN0ZXBJbmRleCA8IHRoaXMud2l6YXJkU3RlcHMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyB3aXphcmQgaGFzIGEgcHJldmlvdXMgc3RlcCwgY29tcGFyZWQgdG8gdGhlIGN1cnJlbnQgc3RlcFxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVHJ1ZSBpZiB0aGlzIHdpemFyZCBoYXMgYSBwcmV2aW91cyBzdGVwIGJlZm9yZSB0aGUgY3VycmVudCBzdGVwXG4gICAgICovXG4gICAgaGFzUHJldmlvdXNTdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNTdGVwKHRoaXMuY3VycmVudFN0ZXBJbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyB3aXphcmQgaGFzIGEgbmV4dCBzdGVwLCBjb21wYXJlZCB0byB0aGUgY3VycmVudCBzdGVwXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUcnVlIGlmIHRoaXMgd2l6YXJkIGhhcyBhIG5leHQgc3RlcCBhZnRlciB0aGUgY3VycmVudCBzdGVwXG4gICAgICovXG4gICAgaGFzTmV4dFN0ZXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1N0ZXAodGhpcy5jdXJyZW50U3RlcEluZGV4ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHdpemFyZCBpcyBjdXJyZW50bHkgaW5zaWRlIGl0cyBsYXN0IHN0ZXBcbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRydWUgaWYgdGhlIHdpemFyZCBpcyBjdXJyZW50bHkgaW5zaWRlIGl0cyBsYXN0IHN0ZXBcbiAgICAgKi9cbiAgICBpc0xhc3RTdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXphcmRTdGVwcy5sZW5ndGggPiAwICYmIHRoaXMuY3VycmVudFN0ZXBJbmRleCA9PT0gdGhpcy53aXphcmRTdGVwcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgW1tXaXphcmRTdGVwXV0gYXQgdGhlIGdpdmVuIGluZGV4IGBzdGVwSW5kZXhgLlxuICAgICAqIElmIG5vIFtbV2l6YXJkU3RlcF1dIGV4aXN0cyBhdCB0aGUgZ2l2ZW4gaW5kZXggYW4gRXJyb3IgaXMgdGhyb3duXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEFuIGBFcnJvcmAgaXMgdGhyb3duLCBpZiB0aGUgZ2l2ZW4gaW5kZXggYHN0ZXBJbmRleGAgZG9lc24ndCBleGlzdFxuICAgICAqIEBwYXJhbSB7P30gc3RlcEluZGV4IFRoZSBnaXZlbiBpbmRleFxuICAgICAqIEByZXR1cm4gez99IFRoZSBmb3VuZCBbW1dpemFyZFN0ZXBdXSBhdCB0aGUgZ2l2ZW4gaW5kZXggYHN0ZXBJbmRleGBcbiAgICAgKi9cbiAgICBnZXRTdGVwQXRJbmRleChzdGVwSW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0ZXAoc3RlcEluZGV4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGtub3duIHN0ZXAsIGJ1dCBnb3Qgc3RlcEluZGV4OiAke3N0ZXBJbmRleH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l6YXJkU3RlcHNbc3RlcEluZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBzdGVwIHdpdGggdGhlIGdpdmVuIGBzdGVwSWRgLlxuICAgICAqIElmIG5vIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gYHN0ZXBJZGAgZXhpc3RzLCBgLTFgIGlzIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBJZCBUaGUgZ2l2ZW4gc3RlcCBpZFxuICAgICAqIEByZXR1cm4gez99IFRoZSBmb3VuZCBpbmRleCBvZiBhIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gc3RlcCBpZCwgb3IgYC0xYCBpZiBubyBzdGVwIHdpdGggdGhlIGdpdmVuIGlkIGlzIGluY2x1ZGVkIGluIHRoZSB3aXphcmRcbiAgICAgKi9cbiAgICBnZXRJbmRleE9mU3RlcFdpdGhJZChzdGVwSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l6YXJkU3RlcHMuZmluZEluZGV4KCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzdGVwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzdGVwID0+IHN0ZXAuc3RlcElkID09PSBzdGVwSWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBbW1dpemFyZFN0ZXBdXSBgc3RlcGAuXG4gICAgICogSWYgdGhlIGdpdmVuIFtbV2l6YXJkU3RlcF1dIGlzIG5vdCBjb250YWluZWQgaW5zaWRlIHRoaXMgd2l6YXJkLCBgLTFgIGlzIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0ZXAgVGhlIGdpdmVuIFtbV2l6YXJkU3RlcF1dXG4gICAgICogQHJldHVybiB7P30gVGhlIGZvdW5kIGluZGV4IG9mIGBzdGVwYCBvciBgLTFgIGlmIHRoZSBzdGVwIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgd2l6YXJkXG4gICAgICovXG4gICAgZ2V0SW5kZXhPZlN0ZXAoc3RlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXphcmRTdGVwcy5pbmRleE9mKHN0ZXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBjb3JyZWN0IFtbTW92aW5nRGlyZWN0aW9uXV0gdmFsdWUgZm9yIGEgZ2l2ZW4gYGRlc3RpbmF0aW9uU3RlcGAgY29tcGFyZWQgdG8gdGhlIGBjdXJyZW50U3RlcEluZGV4YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZGVzdGluYXRpb25TdGVwIFRoZSBnaXZlbiBkZXN0aW5hdGlvbiBzdGVwXG4gICAgICogQHJldHVybiB7P30gVGhlIGNhbGN1bGF0ZWQgW1tNb3ZpbmdEaXJlY3Rpb25dXVxuICAgICAqL1xuICAgIGdldE1vdmluZ0RpcmVjdGlvbihkZXN0aW5hdGlvblN0ZXApIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBsZXQgbW92aW5nRGlyZWN0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb25TdGVwID4gdGhpcy5jdXJyZW50U3RlcEluZGV4KSB7XG4gICAgICAgICAgICBtb3ZpbmdEaXJlY3Rpb24gPSBNb3ZpbmdEaXJlY3Rpb24uRm9yd2FyZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzdGluYXRpb25TdGVwIDwgdGhpcy5jdXJyZW50U3RlcEluZGV4KSB7XG4gICAgICAgICAgICBtb3ZpbmdEaXJlY3Rpb24gPSBNb3ZpbmdEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW92aW5nRGlyZWN0aW9uID0gTW92aW5nRGlyZWN0aW9uLlN0YXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmluZ0RpcmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzLCB3aGV0aGVyIGEgd2l6YXJkIHN0ZXAsIGFzIGRlZmluZWQgYnkgdGhlIGdpdmVuIGRlc3RpbmF0aW9uIGluZGV4LCBjYW4gYmUgdHJhbnNpdGlvbmVkIHRvLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY29udHJvbHMgbmF2aWdhdGlvbiBieSBbW2dvVG9TdGVwXV0sIFtbZ29Ub1ByZXZpb3VzU3RlcF1dLCBhbmQgW1tnb1RvTmV4dFN0ZXBdXSBkaXJlY3RpdmVzLlxuICAgICAqIE5hdmlnYXRpb24gYnkgbmF2aWdhdGlvbiBiYXIgaXMgZ292ZXJuZWQgYnkgW1tpc05hdmlnYWJsZV1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvbkluZGV4IFRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gc3RlcFxuICAgICAqIEByZXR1cm4gez99IEEgW1tQcm9taXNlXV0gY29udGFpbmluZyBgdHJ1ZWAsIGlmIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGNhbiBiZSB0cmFuc2l0aW9uZWQgdG8gYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGNhbkdvVG9TdGVwKGRlc3RpbmF0aW9uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5jYW5Hb1RvU3RlcCh0aGlzLCBkZXN0aW5hdGlvbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gdHJhbnNpdGlvbiB0byB0aGUgd2l6YXJkIHN0ZXAsIGFzIGRlbm90ZWQgYnkgdGhlIGdpdmVuIGRlc3RpbmF0aW9uIGluZGV4LlxuICAgICAqXG4gICAgICogTm90ZTogWW91IGRvIG5vdCBoYXZlIHRvIGNhbGwgW1tjYW5Hb1RvU3RlcF1dIGJlZm9yZSBjYWxsaW5nIFtbZ29Ub1N0ZXBdXS5cbiAgICAgKiBUaGUgW1tjYW5Hb1RvU3RlcF1dIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvbkluZGV4IFRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gd2l6YXJkIHN0ZXAsIHdoaWNoIHNob3VsZCBiZSBlbnRlcmVkXG4gICAgICogQHBhcmFtIHs/PX0gcHJlRmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgc3RlcCBoYXMgYmVlbiB0cmFuc2l0aW9uZWRcbiAgICAgKiBAcGFyYW0gez89fSBwb3N0RmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIHRyYW5zaXRpb25lZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ29Ub1N0ZXAoZGVzdGluYXRpb25JbmRleCwgcHJlRmluYWxpemUsIHBvc3RGaW5hbGl6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uLmdvVG9TdGVwKHRoaXMsIGRlc3RpbmF0aW9uSW5kZXgsIHByZUZpbmFsaXplLCBwb3N0RmluYWxpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byB0cmFuc2l0aW9uIHRoZSB3aXphcmQgdG8gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Pz19IHByZUZpbmFsaXplIEFuIGV2ZW50IGVtaXR0ZXIsIHRvIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHN0ZXAgaGFzIGJlZW4gdHJhbnNpdGlvbmVkXG4gICAgICogQHBhcmFtIHs/PX0gcG9zdEZpbmFsaXplIEFuIGV2ZW50IGVtaXR0ZXIsIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgc3RlcCBoYXMgYmVlbiB0cmFuc2l0aW9uZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdvVG9QcmV2aW91c1N0ZXAocHJlRmluYWxpemUsIHBvc3RGaW5hbGl6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uLmdvVG9TdGVwKHRoaXMsIHRoaXMuY3VycmVudFN0ZXBJbmRleCAtIDEsIHByZUZpbmFsaXplLCBwb3N0RmluYWxpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byB0cmFuc2l0aW9uIHRoZSB3aXphcmQgdG8gdGhlIG5leHQgc3RlcFxuICAgICAqXG4gICAgICogQHBhcmFtIHs/PX0gcHJlRmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgc3RlcCBoYXMgYmVlbiB0cmFuc2l0aW9uZWRcbiAgICAgKiBAcGFyYW0gez89fSBwb3N0RmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIHRyYW5zaXRpb25lZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ29Ub05leHRTdGVwKHByZUZpbmFsaXplLCBwb3N0RmluYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5nb1RvU3RlcCh0aGlzLCB0aGlzLmN1cnJlbnRTdGVwSW5kZXggKyAxLCBwcmVGaW5hbGl6ZSwgcG9zdEZpbmFsaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzLCB3aGV0aGVyIHRoZSB3aXphcmQgc3RlcCwgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGNhbiBiZSBuYXZpZ2F0ZWQgdG8gdXNpbmcgdGhlIG5hdmlnYXRpb24gYmFyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvbkluZGV4IFRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gc3RlcFxuICAgICAqIEByZXR1cm4gez99IFRydWUgaWYgdGhlIHN0ZXAgY2FuIGJlIG5hdmlnYXRlZCB0bywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNOYXZpZ2FibGUoZGVzdGluYXRpb25JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uLmlzTmF2aWdhYmxlKHRoaXMsIGRlc3RpbmF0aW9uSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN0YXRlIG9mIHRoaXMgd2l6YXJkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZXNldCh0aGlzKTtcbiAgICB9XG59XG5XaXphcmRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXdpemFyZCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGF3LXdpemFyZC1uYXZpZ2F0aW9uLWJhclxcbiAgW2RpcmVjdGlvbl09XFxcIm5hdkJhckRpcmVjdGlvblxcXCJcXG4gICpuZ0lmPVxcXCJuYXZCYXJMb2NhdGlvbiA9PSAndG9wJyB8fCBuYXZCYXJMb2NhdGlvbiA9PSAnbGVmdCdcXFwiXFxuICBbbmdDbGFzc109XFxcIntcXG4gICAgdmVydGljYWw6IG5hdkJhckxvY2F0aW9uID09ICdsZWZ0JyxcXG4gICAgaG9yaXpvbnRhbDogbmF2QmFyTG9jYXRpb24gPT0gJ3RvcCcsXFxuICAgIHNtYWxsOiBuYXZCYXJMYXlvdXQgPT0gJ3NtYWxsJyxcXG4gICAgJ2xhcmdlLWZpbGxlZCc6IG5hdkJhckxheW91dCA9PSAnbGFyZ2UtZmlsbGVkJyxcXG4gICAgJ2xhcmdlLWZpbGxlZC1zeW1ib2xzJzogbmF2QmFyTGF5b3V0ID09ICdsYXJnZS1maWxsZWQtc3ltYm9scycsXFxuICAgICdsYXJnZS1lbXB0eSc6IG5hdkJhckxheW91dCA9PSAnbGFyZ2UtZW1wdHknLFxcbiAgICAnbGFyZ2UtZW1wdHktc3ltYm9scyc6IG5hdkJhckxheW91dCA9PSAnbGFyZ2UtZW1wdHktc3ltYm9scydcXG4gIH1cXFwiPlxcbjwvYXctd2l6YXJkLW5hdmlnYXRpb24tYmFyPlxcblxcbjxkaXYgW25nQ2xhc3NdPVxcXCJ7XFxuICAnd2l6YXJkLXN0ZXBzJzogdHJ1ZSxcXG4gIHZlcnRpY2FsOiBuYXZCYXJMb2NhdGlvbiA9PSAnbGVmdCcgfHwgbmF2QmFyTG9jYXRpb24gPT0gJ3JpZ2h0JyxcXG4gIGhvcml6b250YWw6IG5hdkJhckxvY2F0aW9uID09ICd0b3AnIHx8IG5hdkJhckxvY2F0aW9uID09ICdib3R0b20nXFxufVxcXCI+XFxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuPC9kaXY+XFxuXFxuPGF3LXdpemFyZC1uYXZpZ2F0aW9uLWJhclxcbiAgW2RpcmVjdGlvbl09XFxcIm5hdkJhckRpcmVjdGlvblxcXCJcXG4gICpuZ0lmPVxcXCJuYXZCYXJMb2NhdGlvbiA9PSAnYm90dG9tJyB8fCBuYXZCYXJMb2NhdGlvbiA9PSAncmlnaHQnXFxcIlxcbiAgW25nQ2xhc3NdPVxcXCJ7XFxuICAgIHZlcnRpY2FsOiBuYXZCYXJMb2NhdGlvbiA9PSAncmlnaHQnLFxcbiAgICBob3Jpem9udGFsOiBuYXZCYXJMb2NhdGlvbiA9PSAnYm90dG9tJyxcXG4gICAgc21hbGw6IG5hdkJhckxheW91dCA9PSAnc21hbGwnLFxcbiAgICAnbGFyZ2UtZmlsbGVkJzogbmF2QmFyTGF5b3V0ID09ICdsYXJnZS1maWxsZWQnLFxcbiAgICAnbGFyZ2UtZmlsbGVkLXN5bWJvbHMnOiBuYXZCYXJMYXlvdXQgPT0gJ2xhcmdlLWZpbGxlZC1zeW1ib2xzJyxcXG4gICAgJ2xhcmdlLWVtcHR5JzogbmF2QmFyTGF5b3V0ID09ICdsYXJnZS1lbXB0eScsXFxuICAgICdsYXJnZS1lbXB0eS1zeW1ib2xzJzogbmF2QmFyTGF5b3V0ID09ICdsYXJnZS1lbXB0eS1zeW1ib2xzJ1xcbiAgfVxcXCI+XFxuPC9hdy13aXphcmQtbmF2aWdhdGlvbi1iYXI+XFxuXCJcbiAgICAgICAgICAgIH1dIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbldpemFyZENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtdO1xuV2l6YXJkQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHdpemFyZFN0ZXBzUXVlcnlMaXN0OiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtXaXphcmRTdGVwLF0gfV0sXG4gICAgbmF2QmFyTG9jYXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG5hdkJhckxheW91dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbmF2QmFyRGlyZWN0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZWZhdWx0U3RlcEluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlTmF2aWdhdGlvbkJhcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaG9yaXpvbnRhbE9yaWVudGF0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5ob3Jpem9udGFsJyxdIH1dLFxuICAgIHZlcnRpY2FsT3JpZW50YXRpb246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnZlcnRpY2FsJyxdIH1dXG59O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQSBRdWVyeUxpc3QgY29udGFpbmluZyBhbGwgW1tXaXphcmRTdGVwXV1zIGluc2lkZSB0aGlzIHdpemFyZFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFdpemFyZENvbXBvbmVudC5wcm90b3R5cGUud2l6YXJkU3RlcHNRdWVyeUxpc3Q7XG4gICAgLyoqXG4gICAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGJhciBpbnNpZGUgdGhlIHdpemFyZC5cbiAgICAgKiBUaGlzIGxvY2F0aW9uIGNhbiBiZSBlaXRoZXIgdG9wLCBib3R0b20sIGxlZnQgb3IgcmlnaHRcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBXaXphcmRDb21wb25lbnQucHJvdG90eXBlLm5hdkJhckxvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXlvdXQgb2YgdGhlIG5hdmlnYXRpb24gYmFyIGluc2lkZSB0aGUgd2l6YXJkLlxuICAgICAqIFRoZSBsYXlvdXQgY2FuIGJlIGVpdGhlciBzbWFsbCwgbGFyZ2UtZmlsbGVkLCBsYXJnZS1lbXB0eSBvciBsYXJnZS1zeW1ib2xzXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgV2l6YXJkQ29tcG9uZW50LnByb3RvdHlwZS5uYXZCYXJMYXlvdXQ7XG4gICAgLyoqXG4gICAgICogVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgc3RlcHMgaW5zaWRlIHRoZSBuYXZpZ2F0aW9uIGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAgICogVGhlIGRpcmVjdGlvbiBjYW4gYmUgZWl0aGVyIGBsZWZ0LXRvLXJpZ2h0YCBvciBgcmlnaHQtdG8tbGVmdGBcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBXaXphcmRDb21wb25lbnQucHJvdG90eXBlLm5hdkJhckRpcmVjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdpemFyZENvbXBvbmVudC5wcm90b3R5cGUuX2RlZmF1bHRTdGVwSW5kZXg7XG4gICAgLyoqXG4gICAgICogVHJ1ZSwgaWYgdGhlIG5hdmlnYXRpb24gYmFyIHNob3VsZG4ndCBiZSB1c2VkIGZvciBuYXZpZ2F0aW5nXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgV2l6YXJkQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlTmF2aWdhdGlvbkJhcjtcbiAgICAvKipcbiAgICAgKiBUaGUgbmF2aWdhdGlvbiBtb2RlIHVzZWQgdG8gbmF2aWdhdGUgaW5zaWRlIHRoZSB3aXphcmRcbiAgICAgKlxuICAgICAqIEZvciBvdXRzaWRlIGFjY2VzcywgdXNlIHRoZSBbW25hdmlnYXRpb25dXSBnZXR0ZXIuXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXaXphcmRDb21wb25lbnQucHJvdG90eXBlLl9uYXZpZ2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFsbCB3aXphcmQgc3RlcHMgYmVsb25naW5nIHRvIHRoaXMgbW9kZWxcbiAgICAgKlxuICAgICAqIEZvciBvdXRzaWRlIGFjY2VzcywgdXNlIHRoZSBbW3dpemFyZFN0ZXBzXV0gZ2V0dGVyLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2l6YXJkQ29tcG9uZW50LnByb3RvdHlwZS5fd2l6YXJkU3RlcHM7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBhbmQgc2VsZWN0ZWQgc3RlcCBpbnNpZGUgdGhlIHdpemFyZFN0ZXBzIFF1ZXJ5TGlzdC5cbiAgICAgKiBJZiB0aGlzIHdpemFyZCBjb250YWlucyBubyBzdGVwcywgY3VycmVudFN0ZXBJbmRleCBpcyAtMVxuICAgICAqXG4gICAgICogTm90ZTogRG8gbm90IG1vZGlmeSB0aGlzIGZpZWxkIGRpcmVjdGx5LiAgSW5zdGVhZCwgdXNlIG5hdmlnYXRpb24gbWV0aG9kczpcbiAgICAgKiBbW2dvVG9TdGVwXV0sIFtbZ29Ub1ByZXZpb3VzU3RlcF1dLCBbW2dvVG9OZXh0U3RlcF1dLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFdpemFyZENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFN0ZXBJbmRleDtcbn1cbiJdfQ==