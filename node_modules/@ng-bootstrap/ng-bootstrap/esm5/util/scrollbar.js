/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
var noop = (/**
 * @return {?}
 */
function () { });
var ɵ0 = noop;
/**
 * Utility to handle the scrollbar.
 *
 * It allows to compensate the lack of a vertical scrollbar by adding an
 * equivalent padding on the right of the body, and to remove this compensation.
 */
var ScrollBar = /** @class */ (function () {
    function ScrollBar(_document) {
        this._document = _document;
    }
    /**
     * To be called right before a potential vertical scrollbar would be removed:
     *
     * - if there was a scrollbar, adds some compensation padding to the body
     * to keep the same layout as when the scrollbar is there
     * - if there was none, there is nothing to do
     *
     * @return a callback used to revert the compensation (noop if there was none,
     * otherwise a function removing the padding)
     */
    /**
     * To be called right before a potential vertical scrollbar would be removed:
     *
     * - if there was a scrollbar, adds some compensation padding to the body
     * to keep the same layout as when the scrollbar is there
     * - if there was none, there is nothing to do
     *
     * @return {?} a callback used to revert the compensation (noop if there was none,
     * otherwise a function removing the padding)
     */
    ScrollBar.prototype.compensate = /**
     * To be called right before a potential vertical scrollbar would be removed:
     *
     * - if there was a scrollbar, adds some compensation padding to the body
     * to keep the same layout as when the scrollbar is there
     * - if there was none, there is nothing to do
     *
     * @return {?} a callback used to revert the compensation (noop if there was none,
     * otherwise a function removing the padding)
     */
    function () {
        /** @type {?} */
        var width = this._getWidth();
        return !this._isPresent(width) ? noop : this._adjustBody(width);
    };
    /**
     * Adds a padding of the given width on the right of the body.
     *
     * @return a callback used to revert the padding to its previous value
     */
    /**
     * Adds a padding of the given width on the right of the body.
     *
     * @private
     * @param {?} scrollbarWidth
     * @return {?} a callback used to revert the padding to its previous value
     */
    ScrollBar.prototype._adjustBody = /**
     * Adds a padding of the given width on the right of the body.
     *
     * @private
     * @param {?} scrollbarWidth
     * @return {?} a callback used to revert the padding to its previous value
     */
    function (scrollbarWidth) {
        /** @type {?} */
        var body = this._document.body;
        /** @type {?} */
        var userSetPaddingStyle = body.style.paddingRight;
        /** @type {?} */
        var actualPadding = parseFloat(window.getComputedStyle(body)['padding-right']);
        body.style['padding-right'] = actualPadding + scrollbarWidth + "px";
        return (/**
         * @return {?}
         */
        function () { return body.style['padding-right'] = userSetPaddingStyle; });
    };
    /**
     * Tells whether a scrollbar is currently present on the body.
     *
     * @return true if scrollbar is present, false otherwise
     */
    /**
     * Tells whether a scrollbar is currently present on the body.
     *
     * @private
     * @param {?} scrollbarWidth
     * @return {?} true if scrollbar is present, false otherwise
     */
    ScrollBar.prototype._isPresent = /**
     * Tells whether a scrollbar is currently present on the body.
     *
     * @private
     * @param {?} scrollbarWidth
     * @return {?} true if scrollbar is present, false otherwise
     */
    function (scrollbarWidth) {
        /** @type {?} */
        var rect = this._document.body.getBoundingClientRect();
        /** @type {?} */
        var bodyToViewportGap = window.innerWidth - (rect.left + rect.right);
        /** @type {?} */
        var uncertainty = 0.1 * scrollbarWidth;
        return bodyToViewportGap >= scrollbarWidth - uncertainty;
    };
    /**
     * Calculates and returns the width of a scrollbar.
     *
     * @return the width of a scrollbar on this page
     */
    /**
     * Calculates and returns the width of a scrollbar.
     *
     * @private
     * @return {?} the width of a scrollbar on this page
     */
    ScrollBar.prototype._getWidth = /**
     * Calculates and returns the width of a scrollbar.
     *
     * @private
     * @return {?} the width of a scrollbar on this page
     */
    function () {
        /** @type {?} */
        var measurer = this._document.createElement('div');
        measurer.className = 'modal-scrollbar-measure';
        /** @type {?} */
        var body = this._document.body;
        body.appendChild(measurer);
        /** @type {?} */
        var width = measurer.getBoundingClientRect().width - measurer.clientWidth;
        body.removeChild(measurer);
        return width;
    };
    /** @nocollapse */
    ScrollBar.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    /** @nocollapse */ ScrollBar.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function ScrollBar_Factory() { return new ScrollBar(i0.ɵɵinject(i1.DOCUMENT)); }, token: ScrollBar, providedIn: "root" });
ScrollBar.ɵfac = function ScrollBar_Factory(t) { return new (t || ScrollBar)(ɵngcc0.ɵɵinject(DOCUMENT)); };
ScrollBar.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollBar, factory: function (t) { return ScrollBar.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollBar, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
    return ScrollBar;
}());
export { ScrollBar };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScrollBar.prototype._document;
}
export { ɵ0 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS91dGlsL3Njcm9sbGJhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUEwSU0sQUFHQTs7Ozs7Ozs7Ozs7Ozs7a0NBS3dNIiwiZmlsZSI6InNjcm9sbGJhci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0ICogYXMgaTAgZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCAqIGFzIGkxIGZyb20gXCJAYW5ndWxhci9jb21tb25cIjtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBub29wID0gKC8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKCkgeyB9KTtcbnZhciDJtTAgPSBub29wO1xuLyoqXG4gKiBVdGlsaXR5IHRvIGhhbmRsZSB0aGUgc2Nyb2xsYmFyLlxuICpcbiAqIEl0IGFsbG93cyB0byBjb21wZW5zYXRlIHRoZSBsYWNrIG9mIGEgdmVydGljYWwgc2Nyb2xsYmFyIGJ5IGFkZGluZyBhblxuICogZXF1aXZhbGVudCBwYWRkaW5nIG9uIHRoZSByaWdodCBvZiB0aGUgYm9keSwgYW5kIHRvIHJlbW92ZSB0aGlzIGNvbXBlbnNhdGlvbi5cbiAqL1xudmFyIFNjcm9sbEJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxCYXIoX2RvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBjYWxsZWQgcmlnaHQgYmVmb3JlIGEgcG90ZW50aWFsIHZlcnRpY2FsIHNjcm9sbGJhciB3b3VsZCBiZSByZW1vdmVkOlxuICAgICAqXG4gICAgICogLSBpZiB0aGVyZSB3YXMgYSBzY3JvbGxiYXIsIGFkZHMgc29tZSBjb21wZW5zYXRpb24gcGFkZGluZyB0byB0aGUgYm9keVxuICAgICAqIHRvIGtlZXAgdGhlIHNhbWUgbGF5b3V0IGFzIHdoZW4gdGhlIHNjcm9sbGJhciBpcyB0aGVyZVxuICAgICAqIC0gaWYgdGhlcmUgd2FzIG5vbmUsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBjYWxsYmFjayB1c2VkIHRvIHJldmVydCB0aGUgY29tcGVuc2F0aW9uIChub29wIGlmIHRoZXJlIHdhcyBub25lLFxuICAgICAqIG90aGVyd2lzZSBhIGZ1bmN0aW9uIHJlbW92aW5nIHRoZSBwYWRkaW5nKVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRvIGJlIGNhbGxlZCByaWdodCBiZWZvcmUgYSBwb3RlbnRpYWwgdmVydGljYWwgc2Nyb2xsYmFyIHdvdWxkIGJlIHJlbW92ZWQ6XG4gICAgICpcbiAgICAgKiAtIGlmIHRoZXJlIHdhcyBhIHNjcm9sbGJhciwgYWRkcyBzb21lIGNvbXBlbnNhdGlvbiBwYWRkaW5nIHRvIHRoZSBib2R5XG4gICAgICogdG8ga2VlcCB0aGUgc2FtZSBsYXlvdXQgYXMgd2hlbiB0aGUgc2Nyb2xsYmFyIGlzIHRoZXJlXG4gICAgICogLSBpZiB0aGVyZSB3YXMgbm9uZSwgdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAqXG4gICAgICogQHJldHVybiB7P30gYSBjYWxsYmFjayB1c2VkIHRvIHJldmVydCB0aGUgY29tcGVuc2F0aW9uIChub29wIGlmIHRoZXJlIHdhcyBub25lLFxuICAgICAqIG90aGVyd2lzZSBhIGZ1bmN0aW9uIHJlbW92aW5nIHRoZSBwYWRkaW5nKVxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuY29tcGVuc2F0ZSA9IC8qKlxuICAgICAqIFRvIGJlIGNhbGxlZCByaWdodCBiZWZvcmUgYSBwb3RlbnRpYWwgdmVydGljYWwgc2Nyb2xsYmFyIHdvdWxkIGJlIHJlbW92ZWQ6XG4gICAgICpcbiAgICAgKiAtIGlmIHRoZXJlIHdhcyBhIHNjcm9sbGJhciwgYWRkcyBzb21lIGNvbXBlbnNhdGlvbiBwYWRkaW5nIHRvIHRoZSBib2R5XG4gICAgICogdG8ga2VlcCB0aGUgc2FtZSBsYXlvdXQgYXMgd2hlbiB0aGUgc2Nyb2xsYmFyIGlzIHRoZXJlXG4gICAgICogLSBpZiB0aGVyZSB3YXMgbm9uZSwgdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAqXG4gICAgICogQHJldHVybiB7P30gYSBjYWxsYmFjayB1c2VkIHRvIHJldmVydCB0aGUgY29tcGVuc2F0aW9uIChub29wIGlmIHRoZXJlIHdhcyBub25lLFxuICAgICAqIG90aGVyd2lzZSBhIGZ1bmN0aW9uIHJlbW92aW5nIHRoZSBwYWRkaW5nKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9nZXRXaWR0aCgpO1xuICAgICAgICByZXR1cm4gIXRoaXMuX2lzUHJlc2VudCh3aWR0aCkgPyBub29wIDogdGhpcy5fYWRqdXN0Qm9keSh3aWR0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcGFkZGluZyBvZiB0aGUgZ2l2ZW4gd2lkdGggb24gdGhlIHJpZ2h0IG9mIHRoZSBib2R5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIGNhbGxiYWNrIHVzZWQgdG8gcmV2ZXJ0IHRoZSBwYWRkaW5nIHRvIGl0cyBwcmV2aW91cyB2YWx1ZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwYWRkaW5nIG9mIHRoZSBnaXZlbiB3aWR0aCBvbiB0aGUgcmlnaHQgb2YgdGhlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYmFyV2lkdGhcbiAgICAgKiBAcmV0dXJuIHs/fSBhIGNhbGxiYWNrIHVzZWQgdG8gcmV2ZXJ0IHRoZSBwYWRkaW5nIHRvIGl0cyBwcmV2aW91cyB2YWx1ZVxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuX2FkanVzdEJvZHkgPSAvKipcbiAgICAgKiBBZGRzIGEgcGFkZGluZyBvZiB0aGUgZ2l2ZW4gd2lkdGggb24gdGhlIHJpZ2h0IG9mIHRoZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHNjcm9sbGJhcldpZHRoXG4gICAgICogQHJldHVybiB7P30gYSBjYWxsYmFjayB1c2VkIHRvIHJldmVydCB0aGUgcGFkZGluZyB0byBpdHMgcHJldmlvdXMgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2RvY3VtZW50LmJvZHk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHVzZXJTZXRQYWRkaW5nU3R5bGUgPSBib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoYm9keSlbJ3BhZGRpbmctcmlnaHQnXSk7XG4gICAgICAgIGJvZHkuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSA9IGFjdHVhbFBhZGRpbmcgKyBzY3JvbGxiYXJXaWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuICgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvZHkuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSA9IHVzZXJTZXRQYWRkaW5nU3R5bGU7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVsbHMgd2hldGhlciBhIHNjcm9sbGJhciBpcyBjdXJyZW50bHkgcHJlc2VudCBvbiB0aGUgYm9keS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBzY3JvbGxiYXIgaXMgcHJlc2VudCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGVsbHMgd2hldGhlciBhIHNjcm9sbGJhciBpcyBjdXJyZW50bHkgcHJlc2VudCBvbiB0aGUgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxiYXJXaWR0aFxuICAgICAqIEByZXR1cm4gez99IHRydWUgaWYgc2Nyb2xsYmFyIGlzIHByZXNlbnQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuX2lzUHJlc2VudCA9IC8qKlxuICAgICAqIFRlbGxzIHdoZXRoZXIgYSBzY3JvbGxiYXIgaXMgY3VycmVudGx5IHByZXNlbnQgb24gdGhlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYmFyV2lkdGhcbiAgICAgKiBAcmV0dXJuIHs/fSB0cnVlIGlmIHNjcm9sbGJhciBpcyBwcmVzZW50LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX2RvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGJvZHlUb1ZpZXdwb3J0R2FwID0gd2luZG93LmlubmVyV2lkdGggLSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHVuY2VydGFpbnR5ID0gMC4xICogc2Nyb2xsYmFyV2lkdGg7XG4gICAgICAgIHJldHVybiBib2R5VG9WaWV3cG9ydEdhcCA+PSBzY3JvbGxiYXJXaWR0aCAtIHVuY2VydGFpbnR5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgd2lkdGggb2YgYSBzY3JvbGxiYXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSB3aWR0aCBvZiBhIHNjcm9sbGJhciBvbiB0aGlzIHBhZ2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSB3aWR0aCBvZiBhIHNjcm9sbGJhci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P30gdGhlIHdpZHRoIG9mIGEgc2Nyb2xsYmFyIG9uIHRoaXMgcGFnZVxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuX2dldFdpZHRoID0gLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgd2lkdGggb2YgYSBzY3JvbGxiYXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99IHRoZSB3aWR0aCBvZiBhIHNjcm9sbGJhciBvbiB0aGlzIHBhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG1lYXN1cmVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1lYXN1cmVyLmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSc7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKG1lYXN1cmVyKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgd2lkdGggPSBtZWFzdXJlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIG1lYXN1cmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKG1lYXN1cmVyKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgU2Nyb2xsQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTY3JvbGxCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH1dIH1cbiAgICBdOyB9O1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBTY3JvbGxCYXIubmdJbmplY3RhYmxlRGVmID0gaTAuybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBTY3JvbGxCYXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBTY3JvbGxCYXIoaTAuybXJtWluamVjdChpMS5ET0NVTUVOVCkpOyB9LCB0b2tlbjogU2Nyb2xsQmFyLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gU2Nyb2xsQmFyO1xufSgpKTtcbmV4cG9ydCB7IFNjcm9sbEJhciB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLl9kb2N1bWVudDtcbn1cbmV4cG9ydCB7IMm1MCB9O1xuIl19