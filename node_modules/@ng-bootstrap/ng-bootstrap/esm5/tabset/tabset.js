/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, Directive, EventEmitter, Input, Output, QueryList, TemplateRef, ViewEncapsulation } from '@angular/core';
import { NgbTabsetConfig } from './tabset-config';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function NgbTabset_li_1_ng_template_3_Template(rf, ctx) { }
function NgbTabset_li_1_Template(rf, ctx) { if (rf & 1) {
    var _r146 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵlistener("click", function NgbTabset_li_1_Template_a_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r146); var tab_r143 = ctx.$implicit; var ctx_r145 = ɵngcc0.ɵɵnextContext(); ctx_r145.select(tab_r143.id); return $event.preventDefault(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵtemplate(3, NgbTabset_li_1_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r143 = ctx.$implicit;
    var ctx_r141 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", tab_r143.id === ctx_r141.activeId)("disabled", tab_r143.disabled);
    ɵngcc0.ɵɵproperty("id", tab_r143.id);
    ɵngcc0.ɵɵattribute("tabindex", tab_r143.disabled ? "-1" : undefined)("aria-controls", !ctx_r141.destroyOnHide || tab_r143.id === ctx_r141.activeId ? tab_r143.id + "-panel" : null)("aria-selected", tab_r143.id === ctx_r141.activeId)("aria-disabled", tab_r143.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tab_r143.title, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r143.titleTpl == null ? null : tab_r143.titleTpl.templateRef);
} }
function NgbTabset_ng_template_3_div_0_ng_template_1_Template(rf, ctx) { }
function NgbTabset_ng_template_3_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NgbTabset_ng_template_3_div_0_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r147 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r148 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("tab-pane ", tab_r147.id === ctx_r148.activeId ? "active" : null, "");
    ɵngcc0.ɵɵpropertyInterpolate1("id", "", tab_r147.id, "-panel");
    ɵngcc0.ɵɵattribute("aria-labelledby", tab_r147.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r147.contentTpl == null ? null : tab_r147.contentTpl.templateRef);
} }
function NgbTabset_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgbTabset_ng_template_3_div_0_Template, 2, 6, "div", 7);
} if (rf & 2) {
    var tab_r147 = ctx.$implicit;
    var ctx_r142 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r142.destroyOnHide || tab_r147.id === ctx_r142.activeId);
} }
var nextId = 0;
/**
 * A directive to wrap tab titles that need to contain HTML markup or other directives.
 *
 * Alternatively you could use the `NgbTab.title` input for string titles.
 */
var NgbTabTitle = /** @class */ (function () {
    function NgbTabTitle(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbTabTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbTabTitle.ɵfac = function NgbTabTitle_Factory(t) { return new (t || NgbTabTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgbTabTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTabTitle, selectors: [["ng-template", "ngbTabTitle", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabTitle, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbTabTitle]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return NgbTabTitle;
}());
export { NgbTabTitle };
if (false) {
    /** @type {?} */
    NgbTabTitle.prototype.templateRef;
}
/**
 * A directive to wrap content to be displayed in a tab.
 */
var NgbTabContent = /** @class */ (function () {
    function NgbTabContent(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbTabContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbTabContent.ɵfac = function NgbTabContent_Factory(t) { return new (t || NgbTabContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgbTabContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTabContent, selectors: [["ng-template", "ngbTabContent", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbTabContent]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return NgbTabContent;
}());
export { NgbTabContent };
if (false) {
    /** @type {?} */
    NgbTabContent.prototype.templateRef;
}
/**
 * A directive representing an individual tab.
 */
var NgbTab = /** @class */ (function () {
    function NgbTab() {
        /**
         * The tab identifier.
         *
         * Must be unique for the entire document for proper accessibility support.
         */
        this.id = "ngb-tab-" + nextId++;
        /**
         * If `true`, the current tab is disabled and can't be toggled.
         */
        this.disabled = false;
    }
    /**
     * @return {?}
     */
    NgbTab.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.titleTpl = this.titleTpls.first;
        this.contentTpl = this.contentTpls.first;
    };
    NgbTab.propDecorators = {
        id: [{ type: Input }],
        title: [{ type: Input }],
        disabled: [{ type: Input }],
        titleTpls: [{ type: ContentChildren, args: [NgbTabTitle, { descendants: false },] }],
        contentTpls: [{ type: ContentChildren, args: [NgbTabContent, { descendants: false },] }]
    };
NgbTab.ɵfac = function NgbTab_Factory(t) { return new (t || NgbTab)(); };
NgbTab.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTab, selectors: [["ngb-tab"]], contentQueries: function NgbTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTabTitle, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTabContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTpls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTpls = _t);
    } }, inputs: { id: "id", disabled: "disabled", title: "title" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTab, [{
        type: Directive,
        args: [{ selector: 'ngb-tab' }]
    }], function () { return []; }, { id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], title: [{
            type: Input
        }], titleTpls: [{
            type: ContentChildren,
            args: [NgbTabTitle, { descendants: false }]
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbTabContent, { descendants: false }]
        }] }); })();
    return NgbTab;
}());
export { NgbTab };
if (false) {
    /**
     * The tab identifier.
     *
     * Must be unique for the entire document for proper accessibility support.
     * @type {?}
     */
    NgbTab.prototype.id;
    /**
     * The tab title.
     *
     * Use the [`NgbTabTitle`](#/components/tabset/api#NgbTabTitle) directive for non-string titles.
     * @type {?}
     */
    NgbTab.prototype.title;
    /**
     * If `true`, the current tab is disabled and can't be toggled.
     * @type {?}
     */
    NgbTab.prototype.disabled;
    /** @type {?} */
    NgbTab.prototype.titleTpl;
    /** @type {?} */
    NgbTab.prototype.contentTpl;
    /** @type {?} */
    NgbTab.prototype.titleTpls;
    /** @type {?} */
    NgbTab.prototype.contentTpls;
}
/**
 * The payload of the change event fired right before the tab change.
 * @record
 */
export function NgbTabChangeEvent() { }
if (false) {
    /**
     * The id of the currently active tab.
     * @type {?}
     */
    NgbTabChangeEvent.prototype.activeId;
    /**
     * The id of the newly selected tab.
     * @type {?}
     */
    NgbTabChangeEvent.prototype.nextId;
    /**
     * Calling this function will prevent tab switching.
     * @type {?}
     */
    NgbTabChangeEvent.prototype.preventDefault;
}
/**
 * A component that makes it easy to create tabbed interface.
 */
var NgbTabset = /** @class */ (function () {
    function NgbTabset(config) {
        /**
         * If `true`, non-visible tabs content will be removed from DOM. Otherwise it will just be hidden.
         */
        this.destroyOnHide = true;
        /**
         * A tab change event emitted right before the tab change happens.
         *
         * See [`NgbTabChangeEvent`](#/components/tabset/api#NgbTabChangeEvent) for payload details.
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    Object.defineProperty(NgbTabset.prototype, "justify", {
        /**
         * The horizontal alignment of the tabs with flexbox utilities.
         */
        set: /**
         * The horizontal alignment of the tabs with flexbox utilities.
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (className === 'fill' || className === 'justified') {
                this.justifyClass = "nav-" + className;
            }
            else {
                this.justifyClass = "justify-content-" + className;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the tab with the given id and shows its associated content panel.
     *
     * Any other tab that was previously selected becomes unselected and its associated pane is removed from DOM or
     * hidden depending on the `destroyOnHide` value.
     */
    /**
     * Selects the tab with the given id and shows its associated content panel.
     *
     * Any other tab that was previously selected becomes unselected and its associated pane is removed from DOM or
     * hidden depending on the `destroyOnHide` value.
     * @param {?} tabId
     * @return {?}
     */
    NgbTabset.prototype.select = /**
     * Selects the tab with the given id and shows its associated content panel.
     *
     * Any other tab that was previously selected becomes unselected and its associated pane is removed from DOM or
     * hidden depending on the `destroyOnHide` value.
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        /** @type {?} */
        var selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: (/**
                 * @return {?}
                 */
                function () { defaultPrevented_1 = true; }) });
            if (!defaultPrevented_1) {
                this.activeId = selectedTab.id;
            }
        }
    };
    /**
     * @return {?}
     */
    NgbTabset.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        var activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    NgbTabset.prototype._getTabById = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var tabsWithId = this.tabs.filter((/**
         * @param {?} tab
         * @return {?}
         */
        function (tab) { return tab.id === id; }));
        return tabsWithId.length ? tabsWithId[0] : null;
    };
    /** @nocollapse */
    NgbTabset.ctorParameters = function () { return [
        { type: NgbTabsetConfig }
    ]; };
    NgbTabset.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NgbTab,] }],
        activeId: [{ type: Input }],
        destroyOnHide: [{ type: Input }],
        justify: [{ type: Input }],
        orientation: [{ type: Input }],
        type: [{ type: Input }],
        tabChange: [{ type: Output }]
    };
NgbTabset.ɵfac = function NgbTabset_Factory(t) { return new (t || NgbTabset)(ɵngcc0.ɵɵdirectiveInject(NgbTabsetConfig)); };
NgbTabset.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgbTabset, selectors: [["ngb-tabset"]], contentQueries: function NgbTabset_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTab, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { destroyOnHide: "destroyOnHide", type: "type", justify: "justify", orientation: "orientation", activeId: "activeId" }, outputs: { tabChange: "tabChange" }, exportAs: ["ngbTabset"], decls: 4, vars: 4, consts: [["role", "tablist"], ["class", "nav-item", 4, "ngFor", "ngForOf"], [1, "tab-content"], ["ngFor", "", 3, "ngForOf"], [1, "nav-item"], ["href", "", "role", "tab", 1, "nav-link", 3, "id", "click"], [3, "ngTemplateOutlet"], ["role", "tabpanel", 3, "class", "id", 4, "ngIf"], ["role", "tabpanel", 3, "id"]], template: function NgbTabset_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NgbTabset_li_1_Template, 4, 11, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NgbTabset_ng_template_3_Template, 1, 1, "ng-template", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap("nav nav-" + ctx.type + (ctx.orientation == "horizontal" ? " " + ctx.justifyClass : " flex-column"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabset, [{
        type: Component,
        args: [{
                selector: 'ngb-tabset',
                exportAs: 'ngbTabset',
                encapsulation: ViewEncapsulation.None,
                template: "\n    <ul [class]=\"'nav nav-' + type + (orientation == 'horizontal'?  ' ' + justifyClass : ' flex-column')\" role=\"tablist\">\n      <li class=\"nav-item\" *ngFor=\"let tab of tabs\">\n        <a [id]=\"tab.id\" class=\"nav-link\" [class.active]=\"tab.id === activeId\" [class.disabled]=\"tab.disabled\"\n          href (click)=\"select(tab.id); $event.preventDefault()\" role=\"tab\" [attr.tabindex]=\"(tab.disabled ? '-1': undefined)\"\n          [attr.aria-controls]=\"(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)\"\n          [attr.aria-selected]=\"tab.id === activeId\" [attr.aria-disabled]=\"tab.disabled\">\n          {{tab.title}}<ng-template [ngTemplateOutlet]=\"tab.titleTpl?.templateRef\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    <div class=\"tab-content\">\n      <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n        <div\n          class=\"tab-pane {{tab.id === activeId ? 'active' : null}}\"\n          *ngIf=\"!destroyOnHide || tab.id === activeId\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"tab.id\" id=\"{{tab.id}}-panel\">\n          <ng-template [ngTemplateOutlet]=\"tab.contentTpl?.templateRef\"></ng-template>\n        </div>\n      </ng-template>\n    </div>\n  "
            }]
    }], function () { return [{ type: NgbTabsetConfig }]; }, { destroyOnHide: [{
            type: Input
        }], tabChange: [{
            type: Output
        }], type: [{
            type: Input
        }], justify: [{
            type: Input
        }], orientation: [{
            type: Input
        }], activeId: [{
            type: Input
        }], tabs: [{
            type: ContentChildren,
            args: [NgbTab]
        }] }); })();
    return NgbTabset;
}());
export { NgbTabset };
if (false) {
    /** @type {?} */
    NgbTabset.prototype.justifyClass;
    /** @type {?} */
    NgbTabset.prototype.tabs;
    /**
     * The identifier of the tab that should be opened **initially**.
     *
     * For subsequent tab switches use the `.select()` method and the `(tabChange)` event.
     * @type {?}
     */
    NgbTabset.prototype.activeId;
    /**
     * If `true`, non-visible tabs content will be removed from DOM. Otherwise it will just be hidden.
     * @type {?}
     */
    NgbTabset.prototype.destroyOnHide;
    /**
     * The orientation of the tabset.
     * @type {?}
     */
    NgbTabset.prototype.orientation;
    /**
     * Type of navigation to be used for tabs.
     *
     * Currently Bootstrap supports only `"tabs"` and `"pills"`.
     *
     * Since `3.0.0` can also be an arbitrary string (ex. for custom themes).
     * @type {?}
     */
    NgbTabset.prototype.type;
    /**
     * A tab change event emitted right before the tab change happens.
     *
     * See [`NgbTabChangeEvent`](#/components/tabset/api#NgbTabChangeEvent) for payload details.
     * @type {?}
     */
    NgbTabset.prototype.tabChange;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS90YWJzZXQvdGFic2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9BOzs7Ozs7Ozs7S0FTSyxBQUdDOzs7Ozs7Ozs7OzRFQUlHOzs7Ozs7Ozs7Ozs7OztLQWNKLEFBR0M7Ozs7Ozs7Ozs7NEVBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFxQ0gsQUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaUtBLEFBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFhQSIsImZpbGUiOiJ0YWJzZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ2JUYWJzZXRDb25maWcgfSBmcm9tICcuL3RhYnNldC1jb25maWcnO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIG5leHRJZCA9IDA7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIHdyYXAgdGFiIHRpdGxlcyB0aGF0IG5lZWQgdG8gY29udGFpbiBIVE1MIG1hcmt1cCBvciBvdGhlciBkaXJlY3RpdmVzLlxuICpcbiAqIEFsdGVybmF0aXZlbHkgeW91IGNvdWxkIHVzZSB0aGUgYE5nYlRhYi50aXRsZWAgaW5wdXQgZm9yIHN0cmluZyB0aXRsZXMuXG4gKi9cbnZhciBOZ2JUYWJUaXRsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ2JUYWJUaXRsZSh0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIE5nYlRhYlRpdGxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW25nYlRhYlRpdGxlXScgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE5nYlRhYlRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBOZ2JUYWJUaXRsZTtcbn0oKSk7XG5leHBvcnQgeyBOZ2JUYWJUaXRsZSB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE5nYlRhYlRpdGxlLnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcbn1cbi8qKlxuICogQSBkaXJlY3RpdmUgdG8gd3JhcCBjb250ZW50IHRvIGJlIGRpc3BsYXllZCBpbiBhIHRhYi5cbiAqL1xudmFyIE5nYlRhYkNvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdiVGFiQ29udGVudCh0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIE5nYlRhYkNvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbmdiVGFiQ29udGVudF0nIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBOZ2JUYWJDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBOZ2JUYWJDb250ZW50O1xufSgpKTtcbmV4cG9ydCB7IE5nYlRhYkNvbnRlbnQgfTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBOZ2JUYWJDb250ZW50LnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcbn1cbi8qKlxuICogQSBkaXJlY3RpdmUgcmVwcmVzZW50aW5nIGFuIGluZGl2aWR1YWwgdGFiLlxuICovXG52YXIgTmdiVGFiID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nYlRhYigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YWIgaWRlbnRpZmllci5cbiAgICAgICAgICpcbiAgICAgICAgICogTXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIHByb3BlciBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gXCJuZ2ItdGFiLVwiICsgbmV4dElkKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBjdXJyZW50IHRhYiBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhcmUgdXNpbmcgQENvbnRlbnRDaGlsZHJlbiBpbnN0ZWFkIG9mIEBDb250ZW50Q2hpbGQgYXMgaW4gdGhlIEFuZ3VsYXIgdmVyc2lvbiBiZWluZyB1c2VkXG4gICAgICAgIC8vIG9ubHkgQENvbnRlbnRDaGlsZHJlbiBhbGxvd3MgdXMgdG8gc3BlY2lmeSB0aGUge2Rlc2NlbmRhbnRzOiBmYWxzZX0gb3B0aW9uLlxuICAgICAgICAvLyBXaXRob3V0IHtkZXNjZW5kYW50czogZmFsc2V9IHdlIGFyZSBoaXR0aW5nIGJ1Z3MgZGVzY3JpYmVkIGluOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmctYm9vdHN0cmFwL25nLWJvb3RzdHJhcC9pc3N1ZXMvMjI0MFxuICAgICAgICB0aGlzLnRpdGxlVHBsID0gdGhpcy50aXRsZVRwbHMuZmlyc3Q7XG4gICAgICAgIHRoaXMuY29udGVudFRwbCA9IHRoaXMuY29udGVudFRwbHMuZmlyc3Q7XG4gICAgfTtcbiAgICBOZ2JUYWIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbmdiLXRhYicgfSxdIH1cbiAgICBdO1xuICAgIE5nYlRhYi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgaWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgdGl0bGVUcGxzOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOZ2JUYWJUaXRsZSwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dLFxuICAgICAgICBjb250ZW50VHBsczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdiVGFiQ29udGVudCwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dXG4gICAgfTtcbiAgICByZXR1cm4gTmdiVGFiO1xufSgpKTtcbmV4cG9ydCB7IE5nYlRhYiB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRhYiBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogTXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIHByb3BlciBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiVGFiLnByb3RvdHlwZS5pZDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGFiIHRpdGxlLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBbYE5nYlRhYlRpdGxlYF0oIy9jb21wb25lbnRzL3RhYnNldC9hcGkjTmdiVGFiVGl0bGUpIGRpcmVjdGl2ZSBmb3Igbm9uLXN0cmluZyB0aXRsZXMuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiVGFiLnByb3RvdHlwZS50aXRsZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBjdXJyZW50IHRhYiBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWIucHJvdG90eXBlLmRpc2FibGVkO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBOZ2JUYWIucHJvdG90eXBlLnRpdGxlVHBsO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBOZ2JUYWIucHJvdG90eXBlLmNvbnRlbnRUcGw7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE5nYlRhYi5wcm90b3R5cGUudGl0bGVUcGxzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBOZ2JUYWIucHJvdG90eXBlLmNvbnRlbnRUcGxzO1xufVxuLyoqXG4gKiBUaGUgcGF5bG9hZCBvZiB0aGUgY2hhbmdlIGV2ZW50IGZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgdGFiIGNoYW5nZS5cbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5nYlRhYkNoYW5nZUV2ZW50KCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nYlRhYkNoYW5nZUV2ZW50LnByb3RvdHlwZS5hY3RpdmVJZDtcbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIG5ld2x5IHNlbGVjdGVkIHRhYi5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWJDaGFuZ2VFdmVudC5wcm90b3R5cGUubmV4dElkO1xuICAgIC8qKlxuICAgICAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgdGFiIHN3aXRjaGluZy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWJDaGFuZ2VFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQ7XG59XG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgbWFrZXMgaXQgZWFzeSB0byBjcmVhdGUgdGFiYmVkIGludGVyZmFjZS5cbiAqL1xudmFyIE5nYlRhYnNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ2JUYWJzZXQoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIG5vbi12aXNpYmxlIHRhYnMgY29udGVudCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00uIE90aGVyd2lzZSBpdCB3aWxsIGp1c3QgYmUgaGlkZGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95T25IaWRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGFiIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgdGFiIGNoYW5nZSBoYXBwZW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW2BOZ2JUYWJDaGFuZ2VFdmVudGBdKCMvY29tcG9uZW50cy90YWJzZXQvYXBpI05nYlRhYkNoYW5nZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbmZpZy50eXBlO1xuICAgICAgICB0aGlzLmp1c3RpZnkgPSBjb25maWcuanVzdGlmeTtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IGNvbmZpZy5vcmllbnRhdGlvbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nYlRhYnNldC5wcm90b3R5cGUsIFwianVzdGlmeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRhYnMgd2l0aCBmbGV4Ym94IHV0aWxpdGllcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGFicyB3aXRoIGZsZXhib3ggdXRpbGl0aWVzLlxuICAgICAgICAgKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2ZpbGwnIHx8IGNsYXNzTmFtZSA9PT0gJ2p1c3RpZmllZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmp1c3RpZnlDbGFzcyA9IFwibmF2LVwiICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qdXN0aWZ5Q2xhc3MgPSBcImp1c3RpZnktY29udGVudC1cIiArIGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgdGFiIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBzaG93cyBpdHMgYXNzb2NpYXRlZCBjb250ZW50IHBhbmVsLlxuICAgICAqXG4gICAgICogQW55IG90aGVyIHRhYiB0aGF0IHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkIGJlY29tZXMgdW5zZWxlY3RlZCBhbmQgaXRzIGFzc29jaWF0ZWQgcGFuZSBpcyByZW1vdmVkIGZyb20gRE9NIG9yXG4gICAgICogaGlkZGVuIGRlcGVuZGluZyBvbiB0aGUgYGRlc3Ryb3lPbkhpZGVgIHZhbHVlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHRhYiB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgc2hvd3MgaXRzIGFzc29jaWF0ZWQgY29udGVudCBwYW5lbC5cbiAgICAgKlxuICAgICAqIEFueSBvdGhlciB0YWIgdGhhdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZCBiZWNvbWVzIHVuc2VsZWN0ZWQgYW5kIGl0cyBhc3NvY2lhdGVkIHBhbmUgaXMgcmVtb3ZlZCBmcm9tIERPTSBvclxuICAgICAqIGhpZGRlbiBkZXBlbmRpbmcgb24gdGhlIGBkZXN0cm95T25IaWRlYCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez99IHRhYklkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWJzZXQucHJvdG90eXBlLnNlbGVjdCA9IC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHRhYiB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgc2hvd3MgaXRzIGFzc29jaWF0ZWQgY29udGVudCBwYW5lbC5cbiAgICAgKlxuICAgICAqIEFueSBvdGhlciB0YWIgdGhhdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZCBiZWNvbWVzIHVuc2VsZWN0ZWQgYW5kIGl0cyBhc3NvY2lhdGVkIHBhbmUgaXMgcmVtb3ZlZCBmcm9tIERPTSBvclxuICAgICAqIGhpZGRlbiBkZXBlbmRpbmcgb24gdGhlIGBkZXN0cm95T25IaWRlYCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez99IHRhYklkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc2VsZWN0ZWRUYWIgPSB0aGlzLl9nZXRUYWJCeUlkKHRhYklkKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVGFiICYmICFzZWxlY3RlZFRhYi5kaXNhYmxlZCAmJiB0aGlzLmFjdGl2ZUlkICE9PSBzZWxlY3RlZFRhYi5pZCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50YWJDaGFuZ2UuZW1pdCh7IGFjdGl2ZUlkOiB0aGlzLmFjdGl2ZUlkLCBuZXh0SWQ6IHNlbGVjdGVkVGFiLmlkLCBwcmV2ZW50RGVmYXVsdDogKC8qKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBkZWZhdWx0UHJldmVudGVkXzEgPSB0cnVlOyB9KSB9KTtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZF8xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJZCA9IHNlbGVjdGVkVGFiLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nYlRhYnNldC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF1dG8tY29ycmVjdCBhY3RpdmVJZCB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBzZXQgaW5jb3JyZWN0bHkgYXMgaW5wdXRcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgYWN0aXZlVGFiID0gdGhpcy5fZ2V0VGFiQnlJZCh0aGlzLmFjdGl2ZUlkKTtcbiAgICAgICAgdGhpcy5hY3RpdmVJZCA9IGFjdGl2ZVRhYiA/IGFjdGl2ZVRhYi5pZCA6ICh0aGlzLnRhYnMubGVuZ3RoID8gdGhpcy50YWJzLmZpcnN0LmlkIDogbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nYlRhYnNldC5wcm90b3R5cGUuX2dldFRhYkJ5SWQgPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB0YWJzV2l0aElkID0gdGhpcy50YWJzLmZpbHRlcigoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGFiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodGFiKSB7IHJldHVybiB0YWIuaWQgPT09IGlkOyB9KSk7XG4gICAgICAgIHJldHVybiB0YWJzV2l0aElkLmxlbmd0aCA/IHRhYnNXaXRoSWRbMF0gOiBudWxsO1xuICAgIH07XG4gICAgTmdiVGFic2V0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25nYi10YWJzZXQnLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nYlRhYnNldCcsXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8dWwgW2NsYXNzXT1cXFwiJ25hdiBuYXYtJyArIHR5cGUgKyAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnPyAgJyAnICsganVzdGlmeUNsYXNzIDogJyBmbGV4LWNvbHVtbicpXFxcIiByb2xlPVxcXCJ0YWJsaXN0XFxcIj5cXG4gICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIiAqbmdGb3I9XFxcImxldCB0YWIgb2YgdGFic1xcXCI+XFxuICAgICAgICA8YSBbaWRdPVxcXCJ0YWIuaWRcXFwiIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgW2NsYXNzLmFjdGl2ZV09XFxcInRhYi5pZCA9PT0gYWN0aXZlSWRcXFwiIFtjbGFzcy5kaXNhYmxlZF09XFxcInRhYi5kaXNhYmxlZFxcXCJcXG4gICAgICAgICAgaHJlZiAoY2xpY2spPVxcXCJzZWxlY3QodGFiLmlkKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcXFwiIHJvbGU9XFxcInRhYlxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCIodGFiLmRpc2FibGVkID8gJy0xJzogdW5kZWZpbmVkKVxcXCJcXG4gICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XFxcIighZGVzdHJveU9uSGlkZSB8fCB0YWIuaWQgPT09IGFjdGl2ZUlkID8gdGFiLmlkICsgJy1wYW5lbCcgOiBudWxsKVxcXCJcXG4gICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XFxcInRhYi5pZCA9PT0gYWN0aXZlSWRcXFwiIFthdHRyLmFyaWEtZGlzYWJsZWRdPVxcXCJ0YWIuZGlzYWJsZWRcXFwiPlxcbiAgICAgICAgICB7e3RhYi50aXRsZX19PG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwidGFiLnRpdGxlVHBsPy50ZW1wbGF0ZVJlZlxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L2xpPlxcbiAgICA8L3VsPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC10YWIgW25nRm9yT2ZdPVxcXCJ0YWJzXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1wYW5lIHt7dGFiLmlkID09PSBhY3RpdmVJZCA/ICdhY3RpdmUnIDogbnVsbH19XFxcIlxcbiAgICAgICAgICAqbmdJZj1cXFwiIWRlc3Ryb3lPbkhpZGUgfHwgdGFiLmlkID09PSBhY3RpdmVJZFxcXCJcXG4gICAgICAgICAgcm9sZT1cXFwidGFicGFuZWxcXFwiXFxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcInRhYi5pZFxcXCIgaWQ9XFxcInt7dGFiLmlkfX0tcGFuZWxcXFwiPlxcbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJ0YWIuY29udGVudFRwbD8udGVtcGxhdGVSZWZcXFwiPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICA8L2Rpdj5cXG4gIFwiXG4gICAgICAgICAgICAgICAgfV0gfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTmdiVGFic2V0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IE5nYlRhYnNldENvbmZpZyB9XG4gICAgXTsgfTtcbiAgICBOZ2JUYWJzZXQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIHRhYnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05nYlRhYixdIH1dLFxuICAgICAgICBhY3RpdmVJZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGRlc3Ryb3lPbkhpZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBqdXN0aWZ5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICB0eXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgdGFiQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV1cbiAgICB9O1xuICAgIHJldHVybiBOZ2JUYWJzZXQ7XG59KCkpO1xuZXhwb3J0IHsgTmdiVGFic2V0IH07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdiVGFic2V0LnByb3RvdHlwZS5qdXN0aWZ5Q2xhc3M7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE5nYlRhYnNldC5wcm90b3R5cGUudGFicztcbiAgICAvKipcbiAgICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgdGFiIHRoYXQgc2hvdWxkIGJlIG9wZW5lZCAqKmluaXRpYWxseSoqLlxuICAgICAqXG4gICAgICogRm9yIHN1YnNlcXVlbnQgdGFiIHN3aXRjaGVzIHVzZSB0aGUgYC5zZWxlY3QoKWAgbWV0aG9kIGFuZCB0aGUgYCh0YWJDaGFuZ2UpYCBldmVudC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWJzZXQucHJvdG90eXBlLmFjdGl2ZUlkO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgbm9uLXZpc2libGUgdGFicyBjb250ZW50IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTS4gT3RoZXJ3aXNlIGl0IHdpbGwganVzdCBiZSBoaWRkZW4uXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiVGFic2V0LnByb3RvdHlwZS5kZXN0cm95T25IaWRlO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgdGFic2V0LlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nYlRhYnNldC5wcm90b3R5cGUub3JpZW50YXRpb247XG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBuYXZpZ2F0aW9uIHRvIGJlIHVzZWQgZm9yIHRhYnMuXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgQm9vdHN0cmFwIHN1cHBvcnRzIG9ubHkgYFwidGFic1wiYCBhbmQgYFwicGlsbHNcImAuXG4gICAgICpcbiAgICAgKiBTaW5jZSBgMy4wLjBgIGNhbiBhbHNvIGJlIGFuIGFyYml0cmFyeSBzdHJpbmcgKGV4LiBmb3IgY3VzdG9tIHRoZW1lcykuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiVGFic2V0LnByb3RvdHlwZS50eXBlO1xuICAgIC8qKlxuICAgICAqIEEgdGFiIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgdGFiIGNoYW5nZSBoYXBwZW5zLlxuICAgICAqXG4gICAgICogU2VlIFtgTmdiVGFiQ2hhbmdlRXZlbnRgXSgjL2NvbXBvbmVudHMvdGFic2V0L2FwaSNOZ2JUYWJDaGFuZ2VFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JUYWJzZXQucHJvdG90eXBlLnRhYkNoYW5nZTtcbn1cbiJdfQ==