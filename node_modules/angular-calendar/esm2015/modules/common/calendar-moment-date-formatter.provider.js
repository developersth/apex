import * as tslib_1 from "tslib";
import { InjectionToken, Inject, Injectable } from '@angular/core';
import { getWeekViewPeriod } from './util';
import { DateAdapter } from '../../date-adapters/date-adapter';
import * as ɵngcc0 from '@angular/core';
export const MOMENT = new InjectionToken('Moment');
/**
 * This will use <a href="http://momentjs.com/" target="_blank">moment</a> to do all date formatting. To use this class:
 *
 * ```typescript
 * import { CalendarDateFormatter, CalendarMomentDateFormatter, MOMENT } from 'angular-calendar';
 * import moment from 'moment';
 *
 * // in your component
 * provide: [{
 *   provide: MOMENT, useValue: moment
 * }, {
 *   provide: CalendarDateFormatter, useClass: CalendarMomentDateFormatter
 * }]
 *
 * ```
 */
let CalendarMomentDateFormatter = class CalendarMomentDateFormatter {
    /**
     * @hidden
     */
    constructor(moment, dateAdapter) {
        this.moment = moment;
        this.dateAdapter = dateAdapter;
    }
    /**
     * The month view header week day labels
     */
    monthViewColumnHeader({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('dddd');
    }
    /**
     * The month view cell day number
     */
    monthViewDayNumber({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('D');
    }
    /**
     * The month view title
     */
    monthViewTitle({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('MMMM YYYY');
    }
    /**
     * The week view header week day labels
     */
    weekViewColumnHeader({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('dddd');
    }
    /**
     * The week view sub header day and month labels
     */
    weekViewColumnSubHeader({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('MMM D');
    }
    /**
     * The week view title
     */
    weekViewTitle({ date, locale, weekStartsOn, excludeDays, daysInWeek }) {
        const { viewStart, viewEnd } = getWeekViewPeriod(this.dateAdapter, date, weekStartsOn, excludeDays, daysInWeek);
        const format = (dateToFormat, showYear) => this.moment(dateToFormat)
            .locale(locale)
            .format('MMM D' + (showYear ? ', YYYY' : ''));
        return `${format(viewStart, viewStart.getUTCFullYear() !== viewEnd.getUTCFullYear())} - ${format(viewEnd, true)}`;
    }
    /**
     * The time formatting down the left hand side of the week view
     */
    weekViewHour({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('ha');
    }
    /**
     * The time formatting down the left hand side of the day view
     */
    dayViewHour({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('ha');
    }
    /**
     * The day view title
     */
    dayViewTitle({ date, locale }) {
        return this.moment(date)
            .locale(locale)
            .format('dddd, D MMMM, YYYY');
    }
};
CalendarMomentDateFormatter.ɵfac = function CalendarMomentDateFormatter_Factory(t) { return new (t || CalendarMomentDateFormatter)(ɵngcc0.ɵɵinject(MOMENT), ɵngcc0.ɵɵinject(DateAdapter)); };
CalendarMomentDateFormatter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CalendarMomentDateFormatter, factory: CalendarMomentDateFormatter.ɵfac });
CalendarMomentDateFormatter.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MOMENT,] }] },
    { type: DateAdapter }
];
CalendarMomentDateFormatter = tslib_1.__decorate([ tslib_1.__param(0, Inject(MOMENT)),
    tslib_1.__metadata("design:paramtypes", [Object, DateAdapter])
], CalendarMomentDateFormatter);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CalendarMomentDateFormatter, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MOMENT]
            }] }, { type: DateAdapter }]; }, null); })();
export { CalendarMomentDateFormatter };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvYW5ndWxhci1jYWxlbmRhci9lc20yMDE1L21vZHVsZXMvY29tbW9uL2NhbGVuZGFyLW1vbWVudC1kYXRlLWZvcm1hdHRlci5wcm92aWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUpBbUdFOzs7OztrREFLZ0QsQUFFL0M7Ozs7Ozs7O3lEQUU2QiIsImZpbGUiOiJjYWxlbmRhci1tb21lbnQtZGF0ZS1mb3JtYXR0ZXIucHJvdmlkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0V2Vla1ZpZXdQZXJpb2QgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9kYXRlLWFkYXB0ZXJzL2RhdGUtYWRhcHRlcic7XG5leHBvcnQgY29uc3QgTU9NRU5UID0gbmV3IEluamVjdGlvblRva2VuKCdNb21lbnQnKTtcbi8qKlxuICogVGhpcyB3aWxsIHVzZSA8YSBocmVmPVwiaHR0cDovL21vbWVudGpzLmNvbS9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5tb21lbnQ8L2E+IHRvIGRvIGFsbCBkYXRlIGZvcm1hdHRpbmcuIFRvIHVzZSB0aGlzIGNsYXNzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENhbGVuZGFyRGF0ZUZvcm1hdHRlciwgQ2FsZW5kYXJNb21lbnREYXRlRm9ybWF0dGVyLCBNT01FTlQgfSBmcm9tICdhbmd1bGFyLWNhbGVuZGFyJztcbiAqIGltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbiAqXG4gKiAvLyBpbiB5b3VyIGNvbXBvbmVudFxuICogcHJvdmlkZTogW3tcbiAqICAgcHJvdmlkZTogTU9NRU5ULCB1c2VWYWx1ZTogbW9tZW50XG4gKiB9LCB7XG4gKiAgIHByb3ZpZGU6IENhbGVuZGFyRGF0ZUZvcm1hdHRlciwgdXNlQ2xhc3M6IENhbGVuZGFyTW9tZW50RGF0ZUZvcm1hdHRlclxuICogfV1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IENhbGVuZGFyTW9tZW50RGF0ZUZvcm1hdHRlciA9IGNsYXNzIENhbGVuZGFyTW9tZW50RGF0ZUZvcm1hdHRlciB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vbWVudCwgZGF0ZUFkYXB0ZXIpIHtcbiAgICAgICAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG4gICAgICAgIHRoaXMuZGF0ZUFkYXB0ZXIgPSBkYXRlQWRhcHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1vbnRoIHZpZXcgaGVhZGVyIHdlZWsgZGF5IGxhYmVsc1xuICAgICAqL1xuICAgIG1vbnRoVmlld0NvbHVtbkhlYWRlcih7IGRhdGUsIGxvY2FsZSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbWVudChkYXRlKVxuICAgICAgICAgICAgLmxvY2FsZShsb2NhbGUpXG4gICAgICAgICAgICAuZm9ybWF0KCdkZGRkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtb250aCB2aWV3IGNlbGwgZGF5IG51bWJlclxuICAgICAqL1xuICAgIG1vbnRoVmlld0RheU51bWJlcih7IGRhdGUsIGxvY2FsZSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbWVudChkYXRlKVxuICAgICAgICAgICAgLmxvY2FsZShsb2NhbGUpXG4gICAgICAgICAgICAuZm9ybWF0KCdEJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtb250aCB2aWV3IHRpdGxlXG4gICAgICovXG4gICAgbW9udGhWaWV3VGl0bGUoeyBkYXRlLCBsb2NhbGUgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb21lbnQoZGF0ZSlcbiAgICAgICAgICAgIC5sb2NhbGUobG9jYWxlKVxuICAgICAgICAgICAgLmZvcm1hdCgnTU1NTSBZWVlZJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3ZWVrIHZpZXcgaGVhZGVyIHdlZWsgZGF5IGxhYmVsc1xuICAgICAqL1xuICAgIHdlZWtWaWV3Q29sdW1uSGVhZGVyKHsgZGF0ZSwgbG9jYWxlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KGRhdGUpXG4gICAgICAgICAgICAubG9jYWxlKGxvY2FsZSlcbiAgICAgICAgICAgIC5mb3JtYXQoJ2RkZGQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHdlZWsgdmlldyBzdWIgaGVhZGVyIGRheSBhbmQgbW9udGggbGFiZWxzXG4gICAgICovXG4gICAgd2Vla1ZpZXdDb2x1bW5TdWJIZWFkZXIoeyBkYXRlLCBsb2NhbGUgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb21lbnQoZGF0ZSlcbiAgICAgICAgICAgIC5sb2NhbGUobG9jYWxlKVxuICAgICAgICAgICAgLmZvcm1hdCgnTU1NIEQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHdlZWsgdmlldyB0aXRsZVxuICAgICAqL1xuICAgIHdlZWtWaWV3VGl0bGUoeyBkYXRlLCBsb2NhbGUsIHdlZWtTdGFydHNPbiwgZXhjbHVkZURheXMsIGRheXNJbldlZWsgfSkge1xuICAgICAgICBjb25zdCB7IHZpZXdTdGFydCwgdmlld0VuZCB9ID0gZ2V0V2Vla1ZpZXdQZXJpb2QodGhpcy5kYXRlQWRhcHRlciwgZGF0ZSwgd2Vla1N0YXJ0c09uLCBleGNsdWRlRGF5cywgZGF5c0luV2Vlayk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IChkYXRlVG9Gb3JtYXQsIHNob3dZZWFyKSA9PiB0aGlzLm1vbWVudChkYXRlVG9Gb3JtYXQpXG4gICAgICAgICAgICAubG9jYWxlKGxvY2FsZSlcbiAgICAgICAgICAgIC5mb3JtYXQoJ01NTSBEJyArIChzaG93WWVhciA/ICcsIFlZWVknIDogJycpKTtcbiAgICAgICAgcmV0dXJuIGAke2Zvcm1hdCh2aWV3U3RhcnQsIHZpZXdTdGFydC5nZXRVVENGdWxsWWVhcigpICE9PSB2aWV3RW5kLmdldFVUQ0Z1bGxZZWFyKCkpfSAtICR7Zm9ybWF0KHZpZXdFbmQsIHRydWUpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIGZvcm1hdHRpbmcgZG93biB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIHdlZWsgdmlld1xuICAgICAqL1xuICAgIHdlZWtWaWV3SG91cih7IGRhdGUsIGxvY2FsZSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbWVudChkYXRlKVxuICAgICAgICAgICAgLmxvY2FsZShsb2NhbGUpXG4gICAgICAgICAgICAuZm9ybWF0KCdoYScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBmb3JtYXR0aW5nIGRvd24gdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBkYXkgdmlld1xuICAgICAqL1xuICAgIGRheVZpZXdIb3VyKHsgZGF0ZSwgbG9jYWxlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KGRhdGUpXG4gICAgICAgICAgICAubG9jYWxlKGxvY2FsZSlcbiAgICAgICAgICAgIC5mb3JtYXQoJ2hhJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkYXkgdmlldyB0aXRsZVxuICAgICAqL1xuICAgIGRheVZpZXdUaXRsZSh7IGRhdGUsIGxvY2FsZSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbWVudChkYXRlKVxuICAgICAgICAgICAgLmxvY2FsZShsb2NhbGUpXG4gICAgICAgICAgICAuZm9ybWF0KCdkZGRkLCBEIE1NTU0sIFlZWVknKTtcbiAgICB9XG59O1xuQ2FsZW5kYXJNb21lbnREYXRlRm9ybWF0dGVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNT01FTlQsXSB9XSB9LFxuICAgIHsgdHlwZTogRGF0ZUFkYXB0ZXIgfVxuXTtcbkNhbGVuZGFyTW9tZW50RGF0ZUZvcm1hdHRlciA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIHRzbGliXzEuX19wYXJhbSgwLCBJbmplY3QoTU9NRU5UKSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgRGF0ZUFkYXB0ZXJdKVxuXSwgQ2FsZW5kYXJNb21lbnREYXRlRm9ybWF0dGVyKTtcbmV4cG9ydCB7IENhbGVuZGFyTW9tZW50RGF0ZUZvcm1hdHRlciB9O1xuIl19