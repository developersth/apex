import * as tslib_1 from "tslib";
import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { lte } from './validator';
import * as ɵngcc0 from '@angular/core';
var LESS_THAN_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return LessThanEqualValidator; }),
    multi: true
};
var LessThanEqualValidator = /** @class */ (function () {
    function LessThanEqualValidator() {
    }
    LessThanEqualValidator.prototype.ngOnInit = function () {
        this.validator = lte(this.lte);
    };
    LessThanEqualValidator.prototype.ngOnChanges = function (changes) {
        for (var key in changes) {
            if (key === 'lte') {
                this.validator = lte(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    };
    LessThanEqualValidator.prototype.validate = function (c) {
        return this.validator(c);
    };
    LessThanEqualValidator.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], LessThanEqualValidator.prototype, "lte", void 0);
LessThanEqualValidator.ɵfac = function LessThanEqualValidator_Factory(t) { return new (t || LessThanEqualValidator)(); };
LessThanEqualValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LessThanEqualValidator, selectors: [["", "lte", "", "formControlName", ""], ["", "lte", "", "formControl", ""], ["", "lte", "", "ngModel", ""]], inputs: { lte: "lte" }, features: [ɵngcc0.ɵɵProvidersFeature([LESS_THAN_EQUAL_VALIDATOR]), ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LessThanEqualValidator, [{
        type: Directive,
        args: [{
                selector: '[lte][formControlName],[lte][formControl],[lte][ngModel]',
                providers: [LESS_THAN_EQUAL_VALIDATOR]
            }]
    }], function () { return []; }, { lte: [{
            type: Input
        }] }); })();
    return LessThanEqualValidator;
}());
export { LessThanEqualValidator };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWN1c3RvbS12YWxpZGF0b3JzL2VzbTUvc3JjL2FwcC9sZXNzLXRoYW4tZXF1YWwvZGlyZWN0aXZlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0RBOEJ3RDs7Ozs7Ozs7Ozs7b0JBTXpCIiwiZmlsZSI6ImRpcmVjdGl2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgbHRlIH0gZnJvbSAnLi92YWxpZGF0b3InO1xudmFyIExFU1NfVEhBTl9FUVVBTF9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlc3NUaGFuRXF1YWxWYWxpZGF0b3IoKSB7XG4gICAgfVxuICAgIExlc3NUaGFuRXF1YWxWYWxpZGF0b3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IGx0ZSh0aGlzLmx0ZSk7XG4gICAgfTtcbiAgICBMZXNzVGhhbkVxdWFsVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbHRlJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gbHRlKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExlc3NUaGFuRXF1YWxWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICAgIH07XG4gICAgTGVzc1RoYW5FcXVhbFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgTGVzc1RoYW5FcXVhbFZhbGlkYXRvci5wcm90b3R5cGUsIFwibHRlXCIsIHZvaWQgMCk7XG4gICAgTGVzc1RoYW5FcXVhbFZhbGlkYXRvciA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIERpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tsdGVdW2Zvcm1Db250cm9sTmFtZV0sW2x0ZV1bZm9ybUNvbnRyb2xdLFtsdGVdW25nTW9kZWxdJyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW0xFU1NfVEhBTl9FUVVBTF9WQUxJREFUT1JdXG4gICAgICAgIH0pXG4gICAgXSwgTGVzc1RoYW5FcXVhbFZhbGlkYXRvcik7XG4gICAgcmV0dXJuIExlc3NUaGFuRXF1YWxWYWxpZGF0b3I7XG59KCkpO1xuZXhwb3J0IHsgTGVzc1RoYW5FcXVhbFZhbGlkYXRvciB9O1xuIl19