import * as tslib_1 from "tslib";
import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { minDate } from './validator';
import * as ɵngcc0 from '@angular/core';
const MIN_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MinDateValidator),
    multi: true
};
let MinDateValidator = class MinDateValidator {
    ngOnInit() {
        this.validator = minDate(this.minDate);
    }
    ngOnChanges(changes) {
        for (const key in changes) {
            if (key === 'minDate') {
                this.validator = minDate(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
MinDateValidator.ɵfac = function MinDateValidator_Factory(t) { return new (t || MinDateValidator)(); };
MinDateValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MinDateValidator, selectors: [["", "minDate", "", "formControlName", ""], ["", "minDate", "", "formControl", ""], ["", "minDate", "", "ngModel", ""]], inputs: { minDate: "minDate" }, features: [ɵngcc0.ɵɵProvidersFeature([MIN_DATE_VALIDATOR]), ɵngcc0.ɵɵNgOnChangesFeature()] });
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], MinDateValidator.prototype, "minDate", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MinDateValidator, [{
        type: Directive,
        args: [{
                selector: '[minDate][formControlName],[minDate][formControl],[minDate][ngModel]',
                providers: [MIN_DATE_VALIDATOR]
            }]
    }], null, { minDate: [{
            type: Input
        }] }); })();
export { MinDateValidator };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWN1c3RvbS12YWxpZGF0b3JzL2VzbTIwMTUvc3JjL2FwcC9taW4tZGF0ZS9kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4VUF5QkU7Ozs7a0RBSWdEOzs7Ozs7Ozs7b0JBTTdCIiwiZmlsZSI6ImRpcmVjdGl2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgbWluRGF0ZSB9IGZyb20gJy4vdmFsaWRhdG9yJztcbmNvbnN0IE1JTl9EQVRFX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1pbkRhdGVWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xubGV0IE1pbkRhdGVWYWxpZGF0b3IgPSBjbGFzcyBNaW5EYXRlVmFsaWRhdG9yIHtcbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBtaW5EYXRlKHRoaXMubWluRGF0ZSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ21pbkRhdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBtaW5EYXRlKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGUoYykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbn07XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTWluRGF0ZVZhbGlkYXRvci5wcm90b3R5cGUsIFwibWluRGF0ZVwiLCB2b2lkIDApO1xuTWluRGF0ZVZhbGlkYXRvciA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbWluRGF0ZV1bZm9ybUNvbnRyb2xOYW1lXSxbbWluRGF0ZV1bZm9ybUNvbnRyb2xdLFttaW5EYXRlXVtuZ01vZGVsXScsXG4gICAgICAgIHByb3ZpZGVyczogW01JTl9EQVRFX1ZBTElEQVRPUl1cbiAgICB9KVxuXSwgTWluRGF0ZVZhbGlkYXRvcik7XG5leHBvcnQgeyBNaW5EYXRlVmFsaWRhdG9yIH07XG4iXX0=