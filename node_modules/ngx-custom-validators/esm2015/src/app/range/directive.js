import * as tslib_1 from "tslib";
import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { range } from './validator';
import * as ɵngcc0 from '@angular/core';
const RANGE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeValidator),
    multi: true
};
let RangeValidator = class RangeValidator {
    ngOnInit() {
        this.validator = range(this.range);
    }
    ngOnChanges(changes) {
        for (const key in changes) {
            if (key === 'range') {
                this.validator = range(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
RangeValidator.ɵfac = function RangeValidator_Factory(t) { return new (t || RangeValidator)(); };
RangeValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RangeValidator, selectors: [["", "range", "", "formControlName", ""], ["", "range", "", "formControl", ""], ["", "range", "", "ngModel", ""]], inputs: { range: "range" }, features: [ɵngcc0.ɵɵProvidersFeature([RANGE_VALIDATOR]), ɵngcc0.ɵɵNgOnChangesFeature()] });
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array)
], RangeValidator.prototype, "range", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RangeValidator, [{
        type: Directive,
        args: [{
                selector: '[range][formControlName],[range][formControl],[range][ngModel]',
                providers: [RANGE_VALIDATOR]
            }]
    }], null, { range: [{
            type: Input
        }] }); })();
export { RangeValidator };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWN1c3RvbS12YWxpZGF0b3JzL2VzbTIwMTUvc3JjL2FwcC9yYW5nZS9kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2VEF5QkU7Ozs7OENBSTRDOzs7Ozs7Ozs7b0JBTTNCIiwiZmlsZSI6ImRpcmVjdGl2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxJREFUT1JTIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuL3ZhbGlkYXRvcic7XG5jb25zdCBSQU5HRV9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYW5nZVZhbGlkYXRvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG5sZXQgUmFuZ2VWYWxpZGF0b3IgPSBjbGFzcyBSYW5nZVZhbGlkYXRvciB7XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gcmFuZ2UodGhpcy5yYW5nZSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gcmFuZ2UoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZShjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxufTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFJhbmdlVmFsaWRhdG9yLnByb3RvdHlwZSwgXCJyYW5nZVwiLCB2b2lkIDApO1xuUmFuZ2VWYWxpZGF0b3IgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3JhbmdlXVtmb3JtQ29udHJvbE5hbWVdLFtyYW5nZV1bZm9ybUNvbnRyb2xdLFtyYW5nZV1bbmdNb2RlbF0nLFxuICAgICAgICBwcm92aWRlcnM6IFtSQU5HRV9WQUxJREFUT1JdXG4gICAgfSlcbl0sIFJhbmdlVmFsaWRhdG9yKTtcbmV4cG9ydCB7IFJhbmdlVmFsaWRhdG9yIH07XG4iXX0=