{"version":3,"sources":["/Users/macpro/kritsadee/SVN/Cybersoft/apex/node_modules/ngx-image-cropper/bundles/ngx-image-cropper.umd.js"],"names":[],"mappings":"AAAA;oKAC2E;4IACG;gGACxC;wCACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA8jBnD,AAGA;;;;;;;gDAC0L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA0mB1L,AAGA;;;;;;;gDAC8M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAqS9M,AAGA;;;;;;;gDACsO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAk0BtO,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAiJD;;;;;;;;;;;;;;;;;;;gDAaC","file":"ngx-image-cropper.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('ngx-image-cropper', ['exports', '@angular/core', '@angular/platform-browser', '@angular/common'], factory) :\n    (global = global || self, factory(global['ngx-image-cropper'] = {}, global.ng.core, global.ng.platformBrowser, global.ng.common));\n}(this, (function (exports, core, platformBrowser, common) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __createBinding(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    }\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n\r\n    function __values(o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\r\n\r\n    function __classPrivateFieldGet(receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    }\r\n\r\n    function __classPrivateFieldSet(receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/interfaces/move-start.interface.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @record\n     */\n    function MoveStart() { }\n    if (false) {\n        /** @type {?} */\n        MoveStart.prototype.active;\n        /** @type {?} */\n        MoveStart.prototype.type;\n        /** @type {?} */\n        MoveStart.prototype.position;\n        /** @type {?} */\n        MoveStart.prototype.x1;\n        /** @type {?} */\n        MoveStart.prototype.y1;\n        /** @type {?} */\n        MoveStart.prototype.x2;\n        /** @type {?} */\n        MoveStart.prototype.y2;\n        /** @type {?} */\n        MoveStart.prototype.clientX;\n        /** @type {?} */\n        MoveStart.prototype.clientY;\n    }\n    /** @enum {string} */\n    var MoveTypes = {\n        Move: \"move\",\n        Resize: \"resize\",\n        Pinch: \"pinch\",\n    };\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/utils/resize.utils.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /*\n     * Hermite resize - fast image resize/resample using Hermite filter.\n     * https://github.com/viliusle/Hermite-resize\n     */\n    /**\n     * @param {?} canvas\n     * @param {?} width\n     * @param {?} height\n     * @return {?}\n     */\n    function resizeCanvas(canvas, width, height) {\n        /** @type {?} */\n        var width_source = canvas.width;\n        /** @type {?} */\n        var height_source = canvas.height;\n        width = Math.round(width);\n        height = Math.round(height);\n        /** @type {?} */\n        var ratio_w = width_source / width;\n        /** @type {?} */\n        var ratio_h = height_source / height;\n        /** @type {?} */\n        var ratio_w_half = Math.ceil(ratio_w / 2);\n        /** @type {?} */\n        var ratio_h_half = Math.ceil(ratio_h / 2);\n        /** @type {?} */\n        var ctx = canvas.getContext('2d');\n        if (ctx) {\n            /** @type {?} */\n            var img = ctx.getImageData(0, 0, width_source, height_source);\n            /** @type {?} */\n            var img2 = ctx.createImageData(width, height);\n            /** @type {?} */\n            var data = img.data;\n            /** @type {?} */\n            var data2 = img2.data;\n            for (var j = 0; j < height; j++) {\n                for (var i = 0; i < width; i++) {\n                    /** @type {?} */\n                    var x2 = (i + j * width) * 4;\n                    /** @type {?} */\n                    var center_y = j * ratio_h;\n                    /** @type {?} */\n                    var weight = 0;\n                    /** @type {?} */\n                    var weights = 0;\n                    /** @type {?} */\n                    var weights_alpha = 0;\n                    /** @type {?} */\n                    var gx_r = 0;\n                    /** @type {?} */\n                    var gx_g = 0;\n                    /** @type {?} */\n                    var gx_b = 0;\n                    /** @type {?} */\n                    var gx_a = 0;\n                    /** @type {?} */\n                    var xx_start = Math.floor(i * ratio_w);\n                    /** @type {?} */\n                    var yy_start = Math.floor(j * ratio_h);\n                    /** @type {?} */\n                    var xx_stop = Math.ceil((i + 1) * ratio_w);\n                    /** @type {?} */\n                    var yy_stop = Math.ceil((j + 1) * ratio_h);\n                    xx_stop = Math.min(xx_stop, width_source);\n                    yy_stop = Math.min(yy_stop, height_source);\n                    for (var yy = yy_start; yy < yy_stop; yy++) {\n                        /** @type {?} */\n                        var dy = Math.abs(center_y - yy) / ratio_h_half;\n                        /** @type {?} */\n                        var center_x = i * ratio_w;\n                        /** @type {?} */\n                        var w0 = dy * dy;\n                        for (var xx = xx_start; xx < xx_stop; xx++) {\n                            /** @type {?} */\n                            var dx = Math.abs(center_x - xx) / ratio_w_half;\n                            /** @type {?} */\n                            var w = Math.sqrt(w0 + dx * dx);\n                            if (w >= 1) {\n                                //pixel too far\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            /** @type {?} */\n                            var pos_x = 4 * (xx + yy * width_source);\n                            //alpha\n                            gx_a += weight * data[pos_x + 3];\n                            weights_alpha += weight;\n                            //colors\n                            if (data[pos_x + 3] < 255)\n                                weight = weight * data[pos_x + 3] / 250;\n                            gx_r += weight * data[pos_x];\n                            gx_g += weight * data[pos_x + 1];\n                            gx_b += weight * data[pos_x + 2];\n                            weights += weight;\n                        }\n                    }\n                    data2[x2] = gx_r / weights;\n                    data2[x2 + 1] = gx_g / weights;\n                    data2[x2 + 2] = gx_b / weights;\n                    data2[x2 + 3] = gx_a / weights_alpha;\n                }\n            }\n            canvas.width = width;\n            canvas.height = height;\n            //draw\n            ctx.putImageData(img2, 0, 0);\n        }\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/services/crop.service.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var CropService = /** @class */ (function () {\n        function CropService() {\n        }\n        /**\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        CropService.prototype.crop = /**\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        function (sourceImage, loadedImage, cropper, settings) {\n            /** @type {?} */\n            var imagePosition = this.getImagePosition(sourceImage, loadedImage, cropper, settings);\n            /** @type {?} */\n            var width = imagePosition.x2 - imagePosition.x1;\n            /** @type {?} */\n            var height = imagePosition.y2 - imagePosition.y1;\n            /** @type {?} */\n            var cropCanvas = (/** @type {?} */ (document.createElement('canvas')));\n            cropCanvas.width = width;\n            cropCanvas.height = height;\n            /** @type {?} */\n            var ctx = cropCanvas.getContext('2d');\n            if (!ctx) {\n                return;\n            }\n            if (settings.backgroundColor != null) {\n                ctx.fillStyle = settings.backgroundColor;\n                ctx.fillRect(0, 0, width, height);\n            }\n            /** @type {?} */\n            var scaleX = (settings.transform.scale || 1) * (settings.transform.flipH ? -1 : 1);\n            /** @type {?} */\n            var scaleY = (settings.transform.scale || 1) * (settings.transform.flipV ? -1 : 1);\n            /** @type {?} */\n            var transformedImage = loadedImage.transformed;\n            ctx.setTransform(scaleX, 0, 0, scaleY, transformedImage.size.width / 2, transformedImage.size.height / 2);\n            ctx.translate(-imagePosition.x1 / scaleX, -imagePosition.y1 / scaleY);\n            ctx.rotate((settings.transform.rotate || 0) * Math.PI / 180);\n            ctx.drawImage(transformedImage.image, -transformedImage.size.width / 2, -transformedImage.size.height / 2);\n            /** @type {?} */\n            var output = {\n                width: width, height: height,\n                imagePosition: imagePosition,\n                cropperPosition: __assign({}, cropper)\n            };\n            if (settings.containWithinAspectRatio) {\n                output.offsetImagePosition = this.getOffsetImagePosition(sourceImage, loadedImage, cropper, settings);\n            }\n            /** @type {?} */\n            var resizeRatio = this.getResizeRatio(width, height, settings);\n            if (resizeRatio !== 1) {\n                output.width = Math.round(width * resizeRatio);\n                output.height = settings.maintainAspectRatio\n                    ? Math.round(output.width / settings.aspectRatio)\n                    : Math.round(height * resizeRatio);\n                resizeCanvas(cropCanvas, output.width, output.height);\n            }\n            output.base64 = cropCanvas.toDataURL('image/' + settings.format, this.getQuality(settings));\n            return output;\n        };\n        /**\n         * @private\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        CropService.prototype.getImagePosition = /**\n         * @private\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        function (sourceImage, loadedImage, cropper, settings) {\n            /** @type {?} */\n            var sourceImageElement = sourceImage.nativeElement;\n            /** @type {?} */\n            var ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;\n            /** @type {?} */\n            var out = {\n                x1: Math.round(cropper.x1 * ratio),\n                y1: Math.round(cropper.y1 * ratio),\n                x2: Math.round(cropper.x2 * ratio),\n                y2: Math.round(cropper.y2 * ratio)\n            };\n            if (!settings.containWithinAspectRatio) {\n                out.x1 = Math.max(out.x1, 0);\n                out.y1 = Math.max(out.y1, 0);\n                out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);\n                out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);\n            }\n            return out;\n        };\n        /**\n         * @private\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        CropService.prototype.getOffsetImagePosition = /**\n         * @private\n         * @param {?} sourceImage\n         * @param {?} loadedImage\n         * @param {?} cropper\n         * @param {?} settings\n         * @return {?}\n         */\n        function (sourceImage, loadedImage, cropper, settings) {\n            /** @type {?} */\n            var canvasRotation = settings.canvasRotation + loadedImage.exifTransform.rotate;\n            /** @type {?} */\n            var sourceImageElement = sourceImage.nativeElement;\n            /** @type {?} */\n            var ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;\n            /** @type {?} */\n            var offsetX;\n            /** @type {?} */\n            var offsetY;\n            if (canvasRotation % 2) {\n                offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.height) / 2;\n                offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.width) / 2;\n            }\n            else {\n                offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.width) / 2;\n                offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.height) / 2;\n            }\n            /** @type {?} */\n            var out = {\n                x1: Math.round(cropper.x1 * ratio) - offsetX,\n                y1: Math.round(cropper.y1 * ratio) - offsetY,\n                x2: Math.round(cropper.x2 * ratio) - offsetX,\n                y2: Math.round(cropper.y2 * ratio) - offsetY\n            };\n            if (!settings.containWithinAspectRatio) {\n                out.x1 = Math.max(out.x1, 0);\n                out.y1 = Math.max(out.y1, 0);\n                out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);\n                out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);\n            }\n            return out;\n        };\n        /**\n         * @param {?} width\n         * @param {?} height\n         * @param {?} settings\n         * @return {?}\n         */\n        CropService.prototype.getResizeRatio = /**\n         * @param {?} width\n         * @param {?} height\n         * @param {?} settings\n         * @return {?}\n         */\n        function (width, height, settings) {\n            /** @type {?} */\n            var ratioWidth = settings.resizeToWidth / width;\n            /** @type {?} */\n            var ratioHeight = settings.resizeToHeight / height;\n            /** @type {?} */\n            var ratios = new Array();\n            if (settings.resizeToWidth > 0) {\n                ratios.push(ratioWidth);\n            }\n            if (settings.resizeToHeight > 0) {\n                ratios.push(ratioHeight);\n            }\n            /** @type {?} */\n            var result = ratios.length === 0 ? 1 : Math.min.apply(Math, __spread(ratios));\n            if (result > 1 && !settings.onlyScaleDown) {\n                return result;\n            }\n            return Math.min(result, 1);\n        };\n        /**\n         * @param {?} settings\n         * @return {?}\n         */\n        CropService.prototype.getQuality = /**\n         * @param {?} settings\n         * @return {?}\n         */\n        function (settings) {\n            return Math.min(1, Math.max(0, settings.imageQuality / 100));\n        };\n        CropService.decorators = [\n            { type: core.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */ CropService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function CropService_Factory() { return new CropService(); }, token: CropService, providedIn: \"root\" });\n        return CropService;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/interfaces/cropper.settings.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var CropperSettings = /** @class */ (function () {\n        function CropperSettings() {\n            // From options\n            this.format = 'png';\n            this.maintainAspectRatio = true;\n            this.transform = {};\n            this.aspectRatio = 1;\n            this.resizeToWidth = 0;\n            this.resizeToHeight = 0;\n            this.cropperMinWidth = 0;\n            this.cropperMinHeight = 0;\n            this.cropperMaxHeight = 0;\n            this.cropperMaxWidth = 0;\n            this.cropperStaticWidth = 0;\n            this.cropperStaticHeight = 0;\n            this.canvasRotation = 0;\n            this.initialStepSize = 3;\n            this.roundCropper = false;\n            this.onlyScaleDown = false;\n            this.imageQuality = 92;\n            this.autoCrop = true;\n            this.backgroundColor = undefined;\n            this.containWithinAspectRatio = false;\n            this.hideResizeSquares = false;\n            this.alignImage = 'center';\n            // Internal\n            this.cropperScaledMinWidth = 20;\n            this.cropperScaledMinHeight = 20;\n            this.cropperScaledMaxWidth = 20;\n            this.cropperScaledMaxHeight = 20;\n            this.stepSize = this.initialStepSize;\n        }\n        /**\n         * @param {?} options\n         * @return {?}\n         */\n        CropperSettings.prototype.setOptions = /**\n         * @param {?} options\n         * @return {?}\n         */\n        function (options) {\n            var _this = this;\n            Object.keys(options)\n                .filter((/**\n             * @param {?} k\n             * @return {?}\n             */\n            function (k) { return k in _this; }))\n                .forEach((/**\n             * @param {?} k\n             * @return {?}\n             */\n            function (k) { return _this[k] = options[k]; }));\n        };\n        /**\n         * @param {?} changes\n         * @return {?}\n         */\n        CropperSettings.prototype.setOptionsFromChanges = /**\n         * @param {?} changes\n         * @return {?}\n         */\n        function (changes) {\n            var _this = this;\n            Object.keys(changes)\n                .filter((/**\n             * @param {?} k\n             * @return {?}\n             */\n            function (k) { return k in _this; }))\n                .forEach((/**\n             * @param {?} k\n             * @return {?}\n             */\n            function (k) { return _this[k] = changes[k].currentValue; }));\n        };\n        return CropperSettings;\n    }());\n    if (false) {\n        /** @type {?} */\n        CropperSettings.prototype.format;\n        /** @type {?} */\n        CropperSettings.prototype.maintainAspectRatio;\n        /** @type {?} */\n        CropperSettings.prototype.transform;\n        /** @type {?} */\n        CropperSettings.prototype.aspectRatio;\n        /** @type {?} */\n        CropperSettings.prototype.resizeToWidth;\n        /** @type {?} */\n        CropperSettings.prototype.resizeToHeight;\n        /** @type {?} */\n        CropperSettings.prototype.cropperMinWidth;\n        /** @type {?} */\n        CropperSettings.prototype.cropperMinHeight;\n        /** @type {?} */\n        CropperSettings.prototype.cropperMaxHeight;\n        /** @type {?} */\n        CropperSettings.prototype.cropperMaxWidth;\n        /** @type {?} */\n        CropperSettings.prototype.cropperStaticWidth;\n        /** @type {?} */\n        CropperSettings.prototype.cropperStaticHeight;\n        /** @type {?} */\n        CropperSettings.prototype.canvasRotation;\n        /** @type {?} */\n        CropperSettings.prototype.initialStepSize;\n        /** @type {?} */\n        CropperSettings.prototype.roundCropper;\n        /** @type {?} */\n        CropperSettings.prototype.onlyScaleDown;\n        /** @type {?} */\n        CropperSettings.prototype.imageQuality;\n        /** @type {?} */\n        CropperSettings.prototype.autoCrop;\n        /** @type {?} */\n        CropperSettings.prototype.backgroundColor;\n        /** @type {?} */\n        CropperSettings.prototype.containWithinAspectRatio;\n        /** @type {?} */\n        CropperSettings.prototype.hideResizeSquares;\n        /** @type {?} */\n        CropperSettings.prototype.alignImage;\n        /** @type {?} */\n        CropperSettings.prototype.cropperScaledMinWidth;\n        /** @type {?} */\n        CropperSettings.prototype.cropperScaledMinHeight;\n        /** @type {?} */\n        CropperSettings.prototype.cropperScaledMaxWidth;\n        /** @type {?} */\n        CropperSettings.prototype.cropperScaledMaxHeight;\n        /** @type {?} */\n        CropperSettings.prototype.stepSize;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/utils/exif.utils.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    // Black 2x1 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90° CCW)\n    // Source: https://github.com/blueimp/JavaScript-Load-Image\n    /** @type {?} */\n    var testAutoOrientationImageURL = 'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n        'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n        'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n        'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\n        'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\n        'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n    /**\n     * @return {?}\n     */\n    function supportsAutomaticRotation() {\n        return new Promise((/**\n         * @param {?} resolve\n         * @return {?}\n         */\n        function (resolve) {\n            /** @type {?} */\n            var img = new Image();\n            img.onload = (/**\n             * @return {?}\n             */\n            function () {\n                // Check if browser supports automatic image orientation:\n                /** @type {?} */\n                var supported = img.width === 1 && img.height === 2;\n                resolve(supported);\n            });\n            img.src = testAutoOrientationImageURL;\n        }));\n    }\n    /**\n     * @param {?} exifRotationOrBase64Image\n     * @return {?}\n     */\n    function getTransformationsFromExifData(exifRotationOrBase64Image) {\n        if (typeof exifRotationOrBase64Image === 'string') {\n            exifRotationOrBase64Image = getExifRotation(exifRotationOrBase64Image);\n        }\n        switch (exifRotationOrBase64Image) {\n            case 2:\n                return { rotate: 0, flip: true };\n            case 3:\n                return { rotate: 2, flip: false };\n            case 4:\n                return { rotate: 2, flip: true };\n            case 5:\n                return { rotate: 1, flip: true };\n            case 6:\n                return { rotate: 1, flip: false };\n            case 7:\n                return { rotate: 3, flip: true };\n            case 8:\n                return { rotate: 3, flip: false };\n            default:\n                return { rotate: 0, flip: false };\n        }\n    }\n    /**\n     * @param {?} imageBase64\n     * @return {?}\n     */\n    function getExifRotation(imageBase64) {\n        /** @type {?} */\n        var view = new DataView(base64ToArrayBuffer(imageBase64));\n        if (view.getUint16(0, false) != 0xFFD8) {\n            return -2;\n        }\n        /** @type {?} */\n        var length = view.byteLength;\n        /** @type {?} */\n        var offset = 2;\n        while (offset < length) {\n            if (view.getUint16(offset + 2, false) <= 8)\n                return -1;\n            /** @type {?} */\n            var marker = view.getUint16(offset, false);\n            offset += 2;\n            if (marker == 0xFFE1) {\n                if (view.getUint32(offset += 2, false) != 0x45786966) {\n                    return -1;\n                }\n                /** @type {?} */\n                var little = view.getUint16(offset += 6, false) == 0x4949;\n                offset += view.getUint32(offset + 4, little);\n                /** @type {?} */\n                var tags = view.getUint16(offset, little);\n                offset += 2;\n                for (var i = 0; i < tags; i++) {\n                    if (view.getUint16(offset + (i * 12), little) == 0x0112) {\n                        return view.getUint16(offset + (i * 12) + 8, little);\n                    }\n                }\n            }\n            else if ((marker & 0xFF00) != 0xFF00) {\n                break;\n            }\n            else {\n                offset += view.getUint16(offset, false);\n            }\n        }\n        return -1;\n    }\n    /**\n     * @param {?} imageBase64\n     * @return {?}\n     */\n    function base64ToArrayBuffer(imageBase64) {\n        imageBase64 = imageBase64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n        /** @type {?} */\n        var binaryString = atob(imageBase64);\n        /** @type {?} */\n        var len = binaryString.length;\n        /** @type {?} */\n        var bytes = new Uint8Array(len);\n        for (var i = 0; i < len; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/services/load-image.service.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @record\n     */\n    function LoadImageBase64() { }\n    if (false) {\n        /** @type {?} */\n        LoadImageBase64.prototype.originalImage;\n        /** @type {?} */\n        LoadImageBase64.prototype.originalBase64;\n    }\n    var LoadImageService = /** @class */ (function () {\n        function LoadImageService() {\n            this.autoRotateSupported = supportsAutomaticRotation();\n        }\n        /**\n         * @param {?} file\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.loadImageFile = /**\n         * @param {?} file\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (file, cropperSettings) {\n            var _this = this;\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                /** @type {?} */\n                var fileReader = new FileReader();\n                fileReader.onload = (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.loadImage(event.target.result, file.type, cropperSettings)\n                        .then(resolve)\n                        .catch(reject);\n                });\n                fileReader.readAsDataURL(file);\n            }));\n        };\n        /**\n         * @private\n         * @param {?} imageBase64\n         * @param {?} imageType\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.loadImage = /**\n         * @private\n         * @param {?} imageBase64\n         * @param {?} imageType\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (imageBase64, imageType, cropperSettings) {\n            if (!this.isValidImageType(imageType)) {\n                return Promise.reject(new Error('Invalid image type'));\n            }\n            return this.loadBase64Image(imageBase64, cropperSettings);\n        };\n        /**\n         * @private\n         * @param {?} type\n         * @return {?}\n         */\n        LoadImageService.prototype.isValidImageType = /**\n         * @private\n         * @param {?} type\n         * @return {?}\n         */\n        function (type) {\n            return /image\\/(png|jpg|jpeg|bmp|gif|tiff|webp)/.test(type);\n        };\n        /**\n         * @param {?} url\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.loadImageFromURL = /**\n         * @param {?} url\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (url, cropperSettings) {\n            var _this = this;\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                /** @type {?} */\n                var img = new Image();\n                img.onerror = (/**\n                 * @return {?}\n                 */\n                function () { return reject; });\n                img.onload = (/**\n                 * @return {?}\n                 */\n                function () {\n                    /** @type {?} */\n                    var canvas = document.createElement('canvas');\n                    /** @type {?} */\n                    var context = canvas.getContext('2d');\n                    canvas.width = img.width;\n                    canvas.height = img.height;\n                    context.drawImage(img, 0, 0);\n                    _this.loadBase64Image(canvas.toDataURL(), cropperSettings).then(resolve);\n                });\n                img.crossOrigin = 'anonymous';\n                img.src = url;\n            }));\n        };\n        /**\n         * @param {?} imageBase64\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.loadBase64Image = /**\n         * @param {?} imageBase64\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (imageBase64, cropperSettings) {\n            var _this = this;\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                /** @type {?} */\n                var originalImage = new Image();\n                originalImage.onload = (/**\n                 * @return {?}\n                 */\n                function () { return resolve({\n                    originalImage: originalImage,\n                    originalBase64: imageBase64\n                }); });\n                originalImage.onerror = reject;\n                originalImage.src = imageBase64;\n            })).then((/**\n             * @param {?} res\n             * @return {?}\n             */\n            function (res) { return _this.transformImageBase64(res, cropperSettings); }));\n        };\n        /**\n         * @private\n         * @param {?} res\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.transformImageBase64 = /**\n         * @private\n         * @param {?} res\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (res, cropperSettings) {\n            return __awaiter(this, void 0, void 0, function () {\n                var autoRotate, exifTransform, loadedImage;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.autoRotateSupported];\n                        case 1:\n                            autoRotate = _a.sent();\n                            return [4 /*yield*/, getTransformationsFromExifData(autoRotate ? -1 : res.originalBase64)];\n                        case 2:\n                            exifTransform = _a.sent();\n                            if (!res.originalImage || !res.originalImage.complete) {\n                                return [2 /*return*/, Promise.reject(new Error('No image loaded'))];\n                            }\n                            loadedImage = {\n                                original: {\n                                    base64: res.originalBase64,\n                                    image: res.originalImage,\n                                    size: {\n                                        width: res.originalImage.naturalWidth,\n                                        height: res.originalImage.naturalHeight\n                                    }\n                                },\n                                exifTransform: exifTransform\n                            };\n                            return [2 /*return*/, this.transformLoadedImage(loadedImage, cropperSettings)];\n                    }\n                });\n            });\n        };\n        /**\n         * @param {?} loadedImage\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.transformLoadedImage = /**\n         * @param {?} loadedImage\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (loadedImage, cropperSettings) {\n            return __awaiter(this, void 0, void 0, function () {\n                var canvasRotation, originalSize, transformedSize, canvas, ctx, transformedBase64, transformedImage;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            canvasRotation = cropperSettings.canvasRotation + loadedImage.exifTransform.rotate;\n                            originalSize = {\n                                width: loadedImage.original.image.naturalWidth,\n                                height: loadedImage.original.image.naturalHeight\n                            };\n                            if (canvasRotation === 0 && !loadedImage.exifTransform.flip && !cropperSettings.containWithinAspectRatio) {\n                                return [2 /*return*/, {\n                                        original: {\n                                            base64: loadedImage.original.base64,\n                                            image: loadedImage.original.image,\n                                            size: __assign({}, originalSize)\n                                        },\n                                        transformed: {\n                                            base64: loadedImage.original.base64,\n                                            image: loadedImage.original.image,\n                                            size: __assign({}, originalSize)\n                                        },\n                                        exifTransform: loadedImage.exifTransform\n                                    }];\n                            }\n                            transformedSize = this.getTransformedSize(originalSize, loadedImage.exifTransform, cropperSettings);\n                            canvas = document.createElement('canvas');\n                            canvas.width = transformedSize.width;\n                            canvas.height = transformedSize.height;\n                            ctx = canvas.getContext('2d');\n                            ctx.setTransform(loadedImage.exifTransform.flip ? -1 : 1, 0, 0, 1, canvas.width / 2, canvas.height / 2);\n                            ctx.rotate(Math.PI * (canvasRotation / 2));\n                            ctx.drawImage(loadedImage.original.image, -originalSize.width / 2, -originalSize.height / 2);\n                            transformedBase64 = canvas.toDataURL();\n                            return [4 /*yield*/, this.loadImageFromBase64(transformedBase64)];\n                        case 1:\n                            transformedImage = _a.sent();\n                            return [2 /*return*/, {\n                                    original: {\n                                        base64: loadedImage.original.base64,\n                                        image: loadedImage.original.image,\n                                        size: __assign({}, originalSize)\n                                    },\n                                    transformed: {\n                                        base64: transformedBase64,\n                                        image: transformedImage,\n                                        size: {\n                                            width: transformedImage.width,\n                                            height: transformedImage.height\n                                        }\n                                    },\n                                    exifTransform: loadedImage.exifTransform\n                                }];\n                    }\n                });\n            });\n        };\n        /**\n         * @private\n         * @param {?} imageBase64\n         * @return {?}\n         */\n        LoadImageService.prototype.loadImageFromBase64 = /**\n         * @private\n         * @param {?} imageBase64\n         * @return {?}\n         */\n        function (imageBase64) {\n            return new Promise(((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                /** @type {?} */\n                var image = new Image();\n                image.onload = (/**\n                 * @return {?}\n                 */\n                function () { return resolve(image); });\n                image.onerror = reject;\n                image.src = imageBase64;\n            })));\n        };\n        /**\n         * @private\n         * @param {?} originalSize\n         * @param {?} exifTransform\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        LoadImageService.prototype.getTransformedSize = /**\n         * @private\n         * @param {?} originalSize\n         * @param {?} exifTransform\n         * @param {?} cropperSettings\n         * @return {?}\n         */\n        function (originalSize, exifTransform, cropperSettings) {\n            /** @type {?} */\n            var canvasRotation = cropperSettings.canvasRotation + exifTransform.rotate;\n            if (cropperSettings.containWithinAspectRatio) {\n                if (canvasRotation % 2) {\n                    /** @type {?} */\n                    var minWidthToContain = originalSize.width * cropperSettings.aspectRatio;\n                    /** @type {?} */\n                    var minHeightToContain = originalSize.height / cropperSettings.aspectRatio;\n                    return {\n                        width: Math.max(originalSize.height, minWidthToContain),\n                        height: Math.max(originalSize.width, minHeightToContain)\n                    };\n                }\n                else {\n                    /** @type {?} */\n                    var minWidthToContain = originalSize.height * cropperSettings.aspectRatio;\n                    /** @type {?} */\n                    var minHeightToContain = originalSize.width / cropperSettings.aspectRatio;\n                    return {\n                        width: Math.max(originalSize.width, minWidthToContain),\n                        height: Math.max(originalSize.height, minHeightToContain)\n                    };\n                }\n            }\n            if (canvasRotation % 2) {\n                return {\n                    height: originalSize.width,\n                    width: originalSize.height\n                };\n            }\n            return {\n                width: originalSize.width,\n                height: originalSize.height\n            };\n        };\n        LoadImageService.decorators = [\n            { type: core.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */ LoadImageService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function LoadImageService_Factory() { return new LoadImageService(); }, token: LoadImageService, providedIn: \"root\" });\n        return LoadImageService;\n    }());\n    if (false) {\n        /**\n         * @type {?}\n         * @private\n         */\n        LoadImageService.prototype.autoRotateSupported;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/services/cropper-position.service.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var CropperPositionService = /** @class */ (function () {\n        function CropperPositionService() {\n        }\n        /**\n         * @param {?} sourceImage\n         * @param {?} cropperPosition\n         * @param {?} settings\n         * @return {?}\n         */\n        CropperPositionService.prototype.resetCropperPosition = /**\n         * @param {?} sourceImage\n         * @param {?} cropperPosition\n         * @param {?} settings\n         * @return {?}\n         */\n        function (sourceImage, cropperPosition, settings) {\n            /** @type {?} */\n            var sourceImageElement = sourceImage.nativeElement;\n            if (settings.cropperStaticHeight && settings.cropperStaticWidth) {\n                cropperPosition.x1 = 0;\n                cropperPosition.x2 = sourceImageElement.offsetWidth > settings.cropperStaticWidth ?\n                    settings.cropperStaticWidth : sourceImageElement.offsetWidth;\n                cropperPosition.y1 = 0;\n                cropperPosition.y2 = sourceImageElement.offsetHeight > settings.cropperStaticHeight ?\n                    settings.cropperStaticHeight : sourceImageElement.offsetHeight;\n            }\n            else {\n                /** @type {?} */\n                var cropperWidth = Math.min(settings.cropperScaledMaxWidth, sourceImageElement.offsetWidth);\n                /** @type {?} */\n                var cropperHeight = Math.min(settings.cropperScaledMaxHeight, sourceImageElement.offsetHeight);\n                if (!settings.maintainAspectRatio) {\n                    cropperPosition.x1 = 0;\n                    cropperPosition.x2 = cropperWidth;\n                    cropperPosition.y1 = 0;\n                    cropperPosition.y2 = cropperHeight;\n                }\n                else if (cropperWidth / settings.aspectRatio < cropperHeight) {\n                    cropperPosition.x1 = 0;\n                    cropperPosition.x2 = cropperWidth;\n                    /** @type {?} */\n                    var cropperHeightWithAspectRatio = cropperWidth / settings.aspectRatio;\n                    cropperPosition.y1 = (sourceImageElement.offsetHeight - cropperHeightWithAspectRatio) / 2;\n                    cropperPosition.y2 = cropperPosition.y1 + cropperHeightWithAspectRatio;\n                }\n                else {\n                    cropperPosition.y1 = 0;\n                    cropperPosition.y2 = cropperHeight;\n                    /** @type {?} */\n                    var cropperWidthWithAspectRatio = cropperHeight * settings.aspectRatio;\n                    cropperPosition.x1 = (sourceImageElement.offsetWidth - cropperWidthWithAspectRatio) / 2;\n                    cropperPosition.x2 = cropperPosition.x1 + cropperWidthWithAspectRatio;\n                }\n            }\n        };\n        /**\n         * @param {?} event\n         * @param {?} moveStart\n         * @param {?} cropperPosition\n         * @return {?}\n         */\n        CropperPositionService.prototype.move = /**\n         * @param {?} event\n         * @param {?} moveStart\n         * @param {?} cropperPosition\n         * @return {?}\n         */\n        function (event, moveStart, cropperPosition) {\n            /** @type {?} */\n            var diffX = this.getClientX(event) - moveStart.clientX;\n            /** @type {?} */\n            var diffY = this.getClientY(event) - moveStart.clientY;\n            cropperPosition.x1 = moveStart.x1 + diffX;\n            cropperPosition.y1 = moveStart.y1 + diffY;\n            cropperPosition.x2 = moveStart.x2 + diffX;\n            cropperPosition.y2 = moveStart.y2 + diffY;\n        };\n        /**\n         * @param {?} event\n         * @param {?} moveStart\n         * @param {?} cropperPosition\n         * @param {?} maxSize\n         * @param {?} settings\n         * @return {?}\n         */\n        CropperPositionService.prototype.resize = /**\n         * @param {?} event\n         * @param {?} moveStart\n         * @param {?} cropperPosition\n         * @param {?} maxSize\n         * @param {?} settings\n         * @return {?}\n         */\n        function (event, moveStart, cropperPosition, maxSize, settings) {\n            /** @type {?} */\n            var moveX = this.getClientX(event) - moveStart.clientX;\n            /** @type {?} */\n            var moveY = this.getClientY(event) - moveStart.clientY;\n            switch (moveStart.position) {\n                case 'left':\n                    cropperPosition.x1 = Math.min(Math.max(moveStart.x1 + moveX, cropperPosition.x2 - settings.cropperScaledMaxWidth), cropperPosition.x2 - settings.cropperScaledMinWidth);\n                    break;\n                case 'topleft':\n                    cropperPosition.x1 = Math.min(Math.max(moveStart.x1 + moveX, cropperPosition.x2 - settings.cropperScaledMaxWidth), cropperPosition.x2 - settings.cropperScaledMinWidth);\n                    cropperPosition.y1 = Math.min(Math.max(moveStart.y1 + moveY, cropperPosition.y2 - settings.cropperScaledMaxHeight), cropperPosition.y2 - settings.cropperScaledMinHeight);\n                    break;\n                case 'top':\n                    cropperPosition.y1 = Math.min(Math.max(moveStart.y1 + moveY, cropperPosition.y2 - settings.cropperScaledMaxHeight), cropperPosition.y2 - settings.cropperScaledMinHeight);\n                    break;\n                case 'topright':\n                    cropperPosition.x2 = Math.max(Math.min(moveStart.x2 + moveX, cropperPosition.x1 + settings.cropperScaledMaxWidth), cropperPosition.x1 + settings.cropperScaledMinWidth);\n                    cropperPosition.y1 = Math.min(Math.max(moveStart.y1 + moveY, cropperPosition.y2 - settings.cropperScaledMaxHeight), cropperPosition.y2 - settings.cropperScaledMinHeight);\n                    break;\n                case 'right':\n                    cropperPosition.x2 = Math.max(Math.min(moveStart.x2 + moveX, cropperPosition.x1 + settings.cropperScaledMaxWidth), cropperPosition.x1 + settings.cropperScaledMinWidth);\n                    break;\n                case 'bottomright':\n                    cropperPosition.x2 = Math.max(Math.min(moveStart.x2 + moveX, cropperPosition.x1 + settings.cropperScaledMaxWidth), cropperPosition.x1 + settings.cropperScaledMinWidth);\n                    cropperPosition.y2 = Math.max(Math.min(moveStart.y2 + moveY, cropperPosition.y1 + settings.cropperScaledMaxHeight), cropperPosition.y1 + settings.cropperScaledMinHeight);\n                    break;\n                case 'bottom':\n                    cropperPosition.y2 = Math.max(Math.min(moveStart.y2 + moveY, cropperPosition.y1 + settings.cropperScaledMaxHeight), cropperPosition.y1 + settings.cropperScaledMinHeight);\n                    break;\n                case 'bottomleft':\n                    cropperPosition.x1 = Math.min(Math.max(moveStart.x1 + moveX, cropperPosition.x2 - settings.cropperScaledMaxWidth), cropperPosition.x2 - settings.cropperScaledMinWidth);\n                    cropperPosition.y2 = Math.max(Math.min(moveStart.y2 + moveY, cropperPosition.y1 + settings.cropperScaledMaxHeight), cropperPosition.y1 + settings.cropperScaledMinHeight);\n                    break;\n                case 'center':\n                    /** @type {?} */\n                    var scale = event.scale;\n                    /** @type {?} */\n                    var newWidth = Math.min(Math.max(settings.cropperScaledMinWidth, (Math.abs(moveStart.x2 - moveStart.x1)) * scale), settings.cropperScaledMaxWidth);\n                    /** @type {?} */\n                    var newHeight = Math.min(Math.max(settings.cropperScaledMinHeight, (Math.abs(moveStart.y2 - moveStart.y1)) * scale), settings.cropperScaledMaxHeight);\n                    cropperPosition.x1 = moveStart.clientX - newWidth / 2;\n                    cropperPosition.x2 = moveStart.clientX + newWidth / 2;\n                    cropperPosition.y1 = moveStart.clientY - newHeight / 2;\n                    cropperPosition.y2 = moveStart.clientY + newHeight / 2;\n                    if (cropperPosition.x1 < 0) {\n                        cropperPosition.x2 -= cropperPosition.x1;\n                        cropperPosition.x1 = 0;\n                    }\n                    else if (cropperPosition.x2 > maxSize.width) {\n                        cropperPosition.x1 -= (cropperPosition.x2 - maxSize.width);\n                        cropperPosition.x2 = maxSize.width;\n                    }\n                    if (cropperPosition.y1 < 0) {\n                        cropperPosition.y2 -= cropperPosition.y1;\n                        cropperPosition.y1 = 0;\n                    }\n                    else if (cropperPosition.y2 > maxSize.height) {\n                        cropperPosition.y1 -= (cropperPosition.y2 - maxSize.height);\n                        cropperPosition.y2 = maxSize.height;\n                    }\n                    break;\n            }\n            if (settings.maintainAspectRatio) {\n                this.checkAspectRatio(moveStart.position, cropperPosition, maxSize, settings);\n            }\n        };\n        /**\n         * @param {?} position\n         * @param {?} cropperPosition\n         * @param {?} maxSize\n         * @param {?} settings\n         * @return {?}\n         */\n        CropperPositionService.prototype.checkAspectRatio = /**\n         * @param {?} position\n         * @param {?} cropperPosition\n         * @param {?} maxSize\n         * @param {?} settings\n         * @return {?}\n         */\n        function (position, cropperPosition, maxSize, settings) {\n            /** @type {?} */\n            var overflowX = 0;\n            /** @type {?} */\n            var overflowY = 0;\n            switch (position) {\n                case 'top':\n                    cropperPosition.x2 = cropperPosition.x1 + (cropperPosition.y2 - cropperPosition.y1) * settings.aspectRatio;\n                    overflowX = Math.max(cropperPosition.x2 - maxSize.width, 0);\n                    overflowY = Math.max(0 - cropperPosition.y1, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x2 -= (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y1 += (overflowY * settings.aspectRatio) > overflowX ? overflowY : overflowX / settings.aspectRatio;\n                    }\n                    break;\n                case 'bottom':\n                    cropperPosition.x2 = cropperPosition.x1 + (cropperPosition.y2 - cropperPosition.y1) * settings.aspectRatio;\n                    overflowX = Math.max(cropperPosition.x2 - maxSize.width, 0);\n                    overflowY = Math.max(cropperPosition.y2 - maxSize.height, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x2 -= (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y2 -= (overflowY * settings.aspectRatio) > overflowX ? overflowY : (overflowX / settings.aspectRatio);\n                    }\n                    break;\n                case 'topleft':\n                    cropperPosition.y1 = cropperPosition.y2 - (cropperPosition.x2 - cropperPosition.x1) / settings.aspectRatio;\n                    overflowX = Math.max(0 - cropperPosition.x1, 0);\n                    overflowY = Math.max(0 - cropperPosition.y1, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x1 += (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y1 += (overflowY * settings.aspectRatio) > overflowX ? overflowY : overflowX / settings.aspectRatio;\n                    }\n                    break;\n                case 'topright':\n                    cropperPosition.y1 = cropperPosition.y2 - (cropperPosition.x2 - cropperPosition.x1) / settings.aspectRatio;\n                    overflowX = Math.max(cropperPosition.x2 - maxSize.width, 0);\n                    overflowY = Math.max(0 - cropperPosition.y1, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x2 -= (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y1 += (overflowY * settings.aspectRatio) > overflowX ? overflowY : overflowX / settings.aspectRatio;\n                    }\n                    break;\n                case 'right':\n                case 'bottomright':\n                    cropperPosition.y2 = cropperPosition.y1 + (cropperPosition.x2 - cropperPosition.x1) / settings.aspectRatio;\n                    overflowX = Math.max(cropperPosition.x2 - maxSize.width, 0);\n                    overflowY = Math.max(cropperPosition.y2 - maxSize.height, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x2 -= (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y2 -= (overflowY * settings.aspectRatio) > overflowX ? overflowY : overflowX / settings.aspectRatio;\n                    }\n                    break;\n                case 'left':\n                case 'bottomleft':\n                    cropperPosition.y2 = cropperPosition.y1 + (cropperPosition.x2 - cropperPosition.x1) / settings.aspectRatio;\n                    overflowX = Math.max(0 - cropperPosition.x1, 0);\n                    overflowY = Math.max(cropperPosition.y2 - maxSize.height, 0);\n                    if (overflowX > 0 || overflowY > 0) {\n                        cropperPosition.x1 += (overflowY * settings.aspectRatio) > overflowX ? (overflowY * settings.aspectRatio) : overflowX;\n                        cropperPosition.y2 -= (overflowY * settings.aspectRatio) > overflowX ? overflowY : overflowX / settings.aspectRatio;\n                    }\n                    break;\n                case 'center':\n                    cropperPosition.x2 = cropperPosition.x1 + (cropperPosition.y2 - cropperPosition.y1) * settings.aspectRatio;\n                    cropperPosition.y2 = cropperPosition.y1 + (cropperPosition.x2 - cropperPosition.x1) / settings.aspectRatio;\n                    /** @type {?} */\n                    var overflowX1 = Math.max(0 - cropperPosition.x1, 0);\n                    /** @type {?} */\n                    var overflowX2 = Math.max(cropperPosition.x2 - maxSize.width, 0);\n                    /** @type {?} */\n                    var overflowY1 = Math.max(cropperPosition.y2 - maxSize.height, 0);\n                    /** @type {?} */\n                    var overflowY2 = Math.max(0 - cropperPosition.y1, 0);\n                    if (overflowX1 > 0 || overflowX2 > 0 || overflowY1 > 0 || overflowY2 > 0) {\n                        cropperPosition.x1 += (overflowY1 * settings.aspectRatio) > overflowX1 ? (overflowY1 * settings.aspectRatio) : overflowX1;\n                        cropperPosition.x2 -= (overflowY2 * settings.aspectRatio) > overflowX2 ? (overflowY2 * settings.aspectRatio) : overflowX2;\n                        cropperPosition.y1 += (overflowY2 * settings.aspectRatio) > overflowX2 ? overflowY2 : overflowX2 / settings.aspectRatio;\n                        cropperPosition.y2 -= (overflowY1 * settings.aspectRatio) > overflowX1 ? overflowY1 : overflowX1 / settings.aspectRatio;\n                    }\n                    break;\n            }\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        CropperPositionService.prototype.getClientX = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            return (event.touches && event.touches[0] ? event.touches[0].clientX : event.clientX) || 0;\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        CropperPositionService.prototype.getClientY = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            return (event.touches && event.touches[0] ? event.touches[0].clientY : event.clientY) || 0;\n        };\n        CropperPositionService.decorators = [\n            { type: core.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */ CropperPositionService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function CropperPositionService_Factory() { return new CropperPositionService(); }, token: CropperPositionService, providedIn: \"root\" });\n        return CropperPositionService;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/utils/keyboard.utils.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    function getPositionForKey(key) {\n        switch (key) {\n            case 'ArrowUp':\n                return 'top';\n            case 'ArrowRight':\n                return 'right';\n            case 'ArrowDown':\n                return 'bottom';\n            case 'ArrowLeft':\n            default:\n                return 'left';\n        }\n    }\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    function getInvertedPositionForKey(key) {\n        switch (key) {\n            case 'ArrowUp':\n                return 'bottom';\n            case 'ArrowRight':\n                return 'left';\n            case 'ArrowDown':\n                return 'top';\n            case 'ArrowLeft':\n            default:\n                return 'right';\n        }\n    }\n    /**\n     * @param {?} key\n     * @param {?} stepSize\n     * @return {?}\n     */\n    function getEventForKey(key, stepSize) {\n        switch (key) {\n            case 'ArrowUp':\n                return { clientX: 0, clientY: stepSize * -1 };\n            case 'ArrowRight':\n                return { clientX: stepSize, clientY: 0 };\n            case 'ArrowDown':\n                return { clientX: 0, clientY: stepSize };\n            case 'ArrowLeft':\n            default:\n                return { clientX: stepSize * -1, clientY: 0 };\n        }\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/component/image-cropper.component.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var ImageCropperComponent = /** @class */ (function () {\n        function ImageCropperComponent(cropService, cropperPositionService, loadImageService, sanitizer, cd) {\n            this.cropService = cropService;\n            this.cropperPositionService = cropperPositionService;\n            this.loadImageService = loadImageService;\n            this.sanitizer = sanitizer;\n            this.cd = cd;\n            this.Hammer = typeof window !== 'undefined'\n                ? (/** @type {?} */ (((/** @type {?} */ (window))).Hammer))\n                : null;\n            this.settings = new CropperSettings();\n            this.setImageMaxSizeRetries = 0;\n            this.marginLeft = '0px';\n            this.moveTypes = MoveTypes;\n            this.imageVisible = false;\n            this.format = this.settings.format;\n            this.transform = {};\n            this.maintainAspectRatio = this.settings.maintainAspectRatio;\n            this.aspectRatio = this.settings.aspectRatio;\n            this.resizeToWidth = this.settings.resizeToWidth;\n            this.resizeToHeight = this.settings.resizeToHeight;\n            this.cropperMinWidth = this.settings.cropperMinWidth;\n            this.cropperMinHeight = this.settings.cropperMinHeight;\n            this.cropperMaxHeight = this.settings.cropperMaxHeight;\n            this.cropperMaxWidth = this.settings.cropperMaxWidth;\n            this.cropperStaticWidth = this.settings.cropperStaticWidth;\n            this.cropperStaticHeight = this.settings.cropperStaticHeight;\n            this.canvasRotation = this.settings.canvasRotation;\n            this.initialStepSize = this.settings.initialStepSize;\n            this.roundCropper = this.settings.roundCropper;\n            this.onlyScaleDown = this.settings.onlyScaleDown;\n            this.imageQuality = this.settings.imageQuality;\n            this.autoCrop = this.settings.autoCrop;\n            this.backgroundColor = this.settings.backgroundColor;\n            this.containWithinAspectRatio = this.settings.containWithinAspectRatio;\n            this.hideResizeSquares = this.settings.hideResizeSquares;\n            this.cropper = {\n                x1: -100,\n                y1: -100,\n                x2: 10000,\n                y2: 10000\n            };\n            this.alignImage = this.settings.alignImage;\n            this.disabled = false;\n            this.imageCropped = new core.EventEmitter();\n            this.startCropImage = new core.EventEmitter();\n            this.imageLoaded = new core.EventEmitter();\n            this.cropperReady = new core.EventEmitter();\n            this.loadImageFailed = new core.EventEmitter();\n            this.reset();\n        }\n        /**\n         * @param {?} changes\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.ngOnChanges = /**\n         * @param {?} changes\n         * @return {?}\n         */\n        function (changes) {\n            var _this = this;\n            this.onChangesUpdateSettings(changes);\n            this.onChangesInputImage(changes);\n            if (this.loadedImage && this.loadedImage.original.image.complete\n                && (changes.containWithinAspectRatio || changes.canvasRotation)) {\n                this.loadImageService\n                    .transformLoadedImage(this.loadedImage, this.settings)\n                    .then((/**\n                 * @param {?} res\n                 * @return {?}\n                 */\n                function (res) { return _this.setLoadedImage(res); }))\n                    .catch((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) { return _this.loadImageError(err); }));\n            }\n            if (changes.cropper) {\n                this.setMaxSize();\n                this.setCropperScaledMinSize();\n                this.setCropperScaledMaxSize();\n                this.checkCropperPosition(false);\n                this.doAutoCrop();\n                this.cd.markForCheck();\n            }\n            if (changes.aspectRatio && this.imageVisible) {\n                this.resetCropperPosition();\n            }\n            if (changes.transform) {\n                this.transform = this.transform || {};\n                this.setCssTransform();\n                this.doAutoCrop();\n            }\n        };\n        /**\n         * @private\n         * @param {?} changes\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.onChangesUpdateSettings = /**\n         * @private\n         * @param {?} changes\n         * @return {?}\n         */\n        function (changes) {\n            this.settings.setOptionsFromChanges(changes);\n            if (this.settings.cropperStaticHeight && this.settings.cropperStaticWidth) {\n                this.settings.setOptions({\n                    hideResizeSquares: true,\n                    cropperMinWidth: this.settings.cropperStaticWidth,\n                    cropperMinHeight: this.settings.cropperStaticHeight,\n                    cropperMaxHeight: this.settings.cropperStaticHeight,\n                    cropperMaxWidth: this.settings.cropperStaticWidth,\n                    maintainAspectRatio: false\n                });\n            }\n        };\n        /**\n         * @private\n         * @param {?} changes\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.onChangesInputImage = /**\n         * @private\n         * @param {?} changes\n         * @return {?}\n         */\n        function (changes) {\n            if (changes.imageChangedEvent || changes.imageURL || changes.imageBase64 || changes.imageFile) {\n                this.reset();\n            }\n            if (changes.imageChangedEvent && this.isValidImageChangedEvent()) {\n                this.loadImageFile(this.imageChangedEvent.target.files[0]);\n            }\n            if (changes.imageURL && this.imageURL) {\n                this.loadImageFromURL(this.imageURL);\n            }\n            if (changes.imageBase64 && this.imageBase64) {\n                this.loadBase64Image(this.imageBase64);\n            }\n            if (changes.imageFile && this.imageFile) {\n                this.loadImageFile(this.imageFile);\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.isValidImageChangedEvent = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            return this.imageChangedEvent\n                && this.imageChangedEvent.target\n                && this.imageChangedEvent.target.files\n                && this.imageChangedEvent.target.files.length > 0;\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setCssTransform = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            this.safeTransformStyle = this.sanitizer.bypassSecurityTrustStyle('scaleX(' + (this.transform.scale || 1) * (this.transform.flipH ? -1 : 1) + ')' +\n                'scaleY(' + (this.transform.scale || 1) * (this.transform.flipV ? -1 : 1) + ')' +\n                'rotate(' + (this.transform.rotate || 0) + 'deg)');\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.ngOnInit = /**\n         * @return {?}\n         */\n        function () {\n            this.settings.stepSize = this.initialStepSize;\n            this.activatePinchGesture();\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.reset = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            this.imageVisible = false;\n            this.loadedImage = null;\n            this.safeImgDataUrl = 'data:image/png;base64,iVBORw0KGg'\n                + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU'\n                + 'AAarVyFEAAAAASUVORK5CYII=';\n            this.moveStart = {\n                active: false,\n                type: null,\n                position: null,\n                x1: 0,\n                y1: 0,\n                x2: 0,\n                y2: 0,\n                clientX: 0,\n                clientY: 0\n            };\n            this.maxSize = {\n                width: 0,\n                height: 0\n            };\n            this.cropper.x1 = -100;\n            this.cropper.y1 = -100;\n            this.cropper.x2 = 10000;\n            this.cropper.y2 = 10000;\n        };\n        /**\n         * @private\n         * @param {?} file\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.loadImageFile = /**\n         * @private\n         * @param {?} file\n         * @return {?}\n         */\n        function (file) {\n            var _this = this;\n            this.loadImageService\n                .loadImageFile(file, this.settings)\n                .then((/**\n             * @param {?} res\n             * @return {?}\n             */\n            function (res) { return _this.setLoadedImage(res); }))\n                .catch((/**\n             * @param {?} err\n             * @return {?}\n             */\n            function (err) { return _this.loadImageError(err); }));\n        };\n        /**\n         * @private\n         * @param {?} imageBase64\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.loadBase64Image = /**\n         * @private\n         * @param {?} imageBase64\n         * @return {?}\n         */\n        function (imageBase64) {\n            var _this = this;\n            this.loadImageService\n                .loadBase64Image(imageBase64, this.settings)\n                .then((/**\n             * @param {?} res\n             * @return {?}\n             */\n            function (res) { return _this.setLoadedImage(res); }))\n                .catch((/**\n             * @param {?} err\n             * @return {?}\n             */\n            function (err) { return _this.loadImageError(err); }));\n        };\n        /**\n         * @private\n         * @param {?} url\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.loadImageFromURL = /**\n         * @private\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            var _this = this;\n            this.loadImageService\n                .loadImageFromURL(url, this.settings)\n                .then((/**\n             * @param {?} res\n             * @return {?}\n             */\n            function (res) { return _this.setLoadedImage(res); }))\n                .catch((/**\n             * @param {?} err\n             * @return {?}\n             */\n            function (err) { return _this.loadImageError(err); }));\n        };\n        /**\n         * @private\n         * @param {?} loadedImage\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setLoadedImage = /**\n         * @private\n         * @param {?} loadedImage\n         * @return {?}\n         */\n        function (loadedImage) {\n            this.loadedImage = loadedImage;\n            this.safeImgDataUrl = this.sanitizer.bypassSecurityTrustResourceUrl(loadedImage.transformed.base64);\n            this.cd.markForCheck();\n        };\n        /**\n         * @private\n         * @param {?} error\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.loadImageError = /**\n         * @private\n         * @param {?} error\n         * @return {?}\n         */\n        function (error) {\n            console.error(error);\n            this.loadImageFailed.emit();\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.imageLoadedInView = /**\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            if (this.loadedImage != null) {\n                this.imageLoaded.emit(this.loadedImage);\n                this.setImageMaxSizeRetries = 0;\n                setTimeout((/**\n                 * @return {?}\n                 */\n                function () { return _this.checkImageMaxSizeRecursively(); }));\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.checkImageMaxSizeRecursively = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            if (this.setImageMaxSizeRetries > 40) {\n                this.loadImageFailed.emit();\n            }\n            else if (this.sourceImageLoaded()) {\n                this.setMaxSize();\n                this.setCropperScaledMinSize();\n                this.setCropperScaledMaxSize();\n                this.resetCropperPosition();\n                this.cropperReady.emit(__assign({}, this.maxSize));\n                this.cd.markForCheck();\n            }\n            else {\n                this.setImageMaxSizeRetries++;\n                setTimeout((/**\n                 * @return {?}\n                 */\n                function () { return _this.checkImageMaxSizeRecursively(); }), 50);\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.sourceImageLoaded = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            return this.sourceImage && this.sourceImage.nativeElement && this.sourceImage.nativeElement.offsetWidth > 0;\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.onResize = /**\n         * @return {?}\n         */\n        function () {\n            if (!this.loadedImage) {\n                return;\n            }\n            this.resizeCropperPosition();\n            this.setMaxSize();\n            this.setCropperScaledMinSize();\n            this.setCropperScaledMaxSize();\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.activatePinchGesture = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.Hammer) {\n                /** @type {?} */\n                var hammer = new this.Hammer(this.wrapper.nativeElement);\n                hammer.get('pinch').set({ enable: true });\n                hammer.on('pinchmove', this.onPinch.bind(this));\n                hammer.on('pinchend', this.pinchStop.bind(this));\n                hammer.on('pinchstart', this.startPinch.bind(this));\n            }\n            else if (core.isDevMode()) {\n                console.warn('[NgxImageCropper] Could not find HammerJS - Pinch Gesture won\\'t work');\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.resizeCropperPosition = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var sourceImageElement = this.sourceImage.nativeElement;\n            if (this.maxSize.width !== sourceImageElement.offsetWidth || this.maxSize.height !== sourceImageElement.offsetHeight) {\n                this.cropper.x1 = this.cropper.x1 * sourceImageElement.offsetWidth / this.maxSize.width;\n                this.cropper.x2 = this.cropper.x2 * sourceImageElement.offsetWidth / this.maxSize.width;\n                this.cropper.y1 = this.cropper.y1 * sourceImageElement.offsetHeight / this.maxSize.height;\n                this.cropper.y2 = this.cropper.y2 * sourceImageElement.offsetHeight / this.maxSize.height;\n            }\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.resetCropperPosition = /**\n         * @return {?}\n         */\n        function () {\n            this.cropperPositionService.resetCropperPosition(this.sourceImage, this.cropper, this.settings);\n            this.doAutoCrop();\n            this.imageVisible = true;\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.keyboardAccess = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            this.changeKeyboardStepSize(event);\n            this.keyboardMoveCropper(event);\n        };\n        /**\n         * @private\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.changeKeyboardStepSize = /**\n         * @private\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (event.key >= '1' && event.key <= '9') {\n                this.settings.stepSize = +event.key;\n                return;\n            }\n        };\n        /**\n         * @private\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.keyboardMoveCropper = /**\n         * @private\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            /** @type {?} */\n            var keyboardWhiteList = ['ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft'];\n            if (!(keyboardWhiteList.includes(event.key))) {\n                return;\n            }\n            /** @type {?} */\n            var moveType = event.shiftKey ? MoveTypes.Resize : MoveTypes.Move;\n            /** @type {?} */\n            var position = event.altKey ? getInvertedPositionForKey(event.key) : getPositionForKey(event.key);\n            /** @type {?} */\n            var moveEvent = getEventForKey(event.key, this.settings.stepSize);\n            event.preventDefault();\n            event.stopPropagation();\n            this.startMove({ clientX: 0, clientY: 0 }, moveType, position);\n            this.moveImg(moveEvent);\n            this.moveStop();\n        };\n        /**\n         * @param {?} event\n         * @param {?} moveType\n         * @param {?=} position\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.startMove = /**\n         * @param {?} event\n         * @param {?} moveType\n         * @param {?=} position\n         * @return {?}\n         */\n        function (event, moveType, position) {\n            if (position === void 0) { position = null; }\n            if (this.moveStart && this.moveStart.active && this.moveStart.type === MoveTypes.Pinch) {\n                return;\n            }\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            this.moveStart = __assign({ active: true, type: moveType, position: position, clientX: this.cropperPositionService.getClientX(event), clientY: this.cropperPositionService.getClientY(event) }, this.cropper);\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.startPinch = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (!this.safeImgDataUrl) {\n                return;\n            }\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            this.moveStart = __assign({ active: true, type: MoveTypes.Pinch, position: 'center', clientX: this.cropper.x1 + (this.cropper.x2 - this.cropper.x1) / 2, clientY: this.cropper.y1 + (this.cropper.y2 - this.cropper.y1) / 2 }, this.cropper);\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.moveImg = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (this.moveStart.active) {\n                if (event.stopPropagation) {\n                    event.stopPropagation();\n                }\n                if (event.preventDefault) {\n                    event.preventDefault();\n                }\n                if (this.moveStart.type === MoveTypes.Move) {\n                    this.cropperPositionService.move(event, this.moveStart, this.cropper);\n                    this.checkCropperPosition(true);\n                }\n                else if (this.moveStart.type === MoveTypes.Resize) {\n                    if (!this.cropperStaticWidth && !this.cropperStaticHeight) {\n                        this.cropperPositionService.resize(event, this.moveStart, this.cropper, this.maxSize, this.settings);\n                    }\n                    this.checkCropperPosition(false);\n                }\n                this.cd.detectChanges();\n            }\n        };\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.onPinch = /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (this.moveStart.active) {\n                if (event.stopPropagation) {\n                    event.stopPropagation();\n                }\n                if (event.preventDefault) {\n                    event.preventDefault();\n                }\n                if (this.moveStart.type === MoveTypes.Pinch) {\n                    this.cropperPositionService.resize(event, this.moveStart, this.cropper, this.maxSize, this.settings);\n                    this.checkCropperPosition(false);\n                }\n                this.cd.detectChanges();\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setMaxSize = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.sourceImage) {\n                /** @type {?} */\n                var sourceImageElement = this.sourceImage.nativeElement;\n                this.maxSize.width = sourceImageElement.offsetWidth;\n                this.maxSize.height = sourceImageElement.offsetHeight;\n                this.marginLeft = this.sanitizer.bypassSecurityTrustStyle('calc(50% - ' + this.maxSize.width / 2 + 'px)');\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setCropperScaledMinSize = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.loadedImage && this.loadedImage.transformed && this.loadedImage.transformed.image) {\n                this.setCropperScaledMinWidth();\n                this.setCropperScaledMinHeight();\n            }\n            else {\n                this.settings.cropperScaledMinWidth = 20;\n                this.settings.cropperScaledMinHeight = 20;\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setCropperScaledMinWidth = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            this.settings.cropperScaledMinWidth = this.cropperMinWidth > 0\n                ? Math.max(20, this.cropperMinWidth / this.loadedImage.transformed.image.width * this.maxSize.width)\n                : 20;\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setCropperScaledMinHeight = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.maintainAspectRatio) {\n                this.settings.cropperScaledMinHeight = Math.max(20, this.settings.cropperScaledMinWidth / this.aspectRatio);\n            }\n            else if (this.cropperMinHeight > 0) {\n                this.settings.cropperScaledMinHeight = Math.max(20, this.cropperMinHeight / this.loadedImage.transformed.image.height * this.maxSize.height);\n            }\n            else {\n                this.settings.cropperScaledMinHeight = 20;\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.setCropperScaledMaxSize = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.loadedImage && this.loadedImage.transformed && this.loadedImage.transformed.image) {\n                /** @type {?} */\n                var ratio = this.loadedImage.transformed.size.width / this.maxSize.width;\n                this.settings.cropperScaledMaxWidth = this.cropperMaxWidth > 20 ? this.cropperMaxWidth / ratio : this.maxSize.width;\n                this.settings.cropperScaledMaxHeight = this.cropperMaxHeight > 20 ? this.cropperMaxHeight / ratio : this.maxSize.height;\n                if (this.maintainAspectRatio) {\n                    if (this.settings.cropperScaledMaxWidth > this.settings.cropperScaledMaxHeight * this.aspectRatio) {\n                        this.settings.cropperScaledMaxWidth = this.settings.cropperScaledMaxHeight * this.aspectRatio;\n                    }\n                    else if (this.settings.cropperScaledMaxWidth < this.settings.cropperScaledMaxHeight * this.aspectRatio) {\n                        this.settings.cropperScaledMaxHeight = this.settings.cropperScaledMaxWidth / this.aspectRatio;\n                    }\n                }\n            }\n            else {\n                this.settings.cropperScaledMaxWidth = this.maxSize.width;\n                this.settings.cropperScaledMaxHeight = this.maxSize.height;\n            }\n        };\n        /**\n         * @private\n         * @param {?=} maintainSize\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.checkCropperPosition = /**\n         * @private\n         * @param {?=} maintainSize\n         * @return {?}\n         */\n        function (maintainSize) {\n            if (maintainSize === void 0) { maintainSize = false; }\n            if (this.cropper.x1 < 0) {\n                this.cropper.x2 -= maintainSize ? this.cropper.x1 : 0;\n                this.cropper.x1 = 0;\n            }\n            if (this.cropper.y1 < 0) {\n                this.cropper.y2 -= maintainSize ? this.cropper.y1 : 0;\n                this.cropper.y1 = 0;\n            }\n            if (this.cropper.x2 > this.maxSize.width) {\n                this.cropper.x1 -= maintainSize ? (this.cropper.x2 - this.maxSize.width) : 0;\n                this.cropper.x2 = this.maxSize.width;\n            }\n            if (this.cropper.y2 > this.maxSize.height) {\n                this.cropper.y1 -= maintainSize ? (this.cropper.y2 - this.maxSize.height) : 0;\n                this.cropper.y2 = this.maxSize.height;\n            }\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.moveStop = /**\n         * @return {?}\n         */\n        function () {\n            if (this.moveStart.active) {\n                this.moveStart.active = false;\n                this.doAutoCrop();\n            }\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.pinchStop = /**\n         * @return {?}\n         */\n        function () {\n            if (this.moveStart.active) {\n                this.moveStart.active = false;\n                this.doAutoCrop();\n            }\n        };\n        /**\n         * @private\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.doAutoCrop = /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            if (this.autoCrop) {\n                this.crop();\n            }\n        };\n        /**\n         * @return {?}\n         */\n        ImageCropperComponent.prototype.crop = /**\n         * @return {?}\n         */\n        function () {\n            if (this.sourceImage && this.sourceImage.nativeElement && this.loadedImage.transformed.image != null) {\n                this.startCropImage.emit();\n                /** @type {?} */\n                var output = this.cropService.crop(this.sourceImage, this.loadedImage, this.cropper, this.settings);\n                if (output != null) {\n                    this.imageCropped.emit(output);\n                }\n                return output;\n            }\n            return null;\n        };\n        ImageCropperComponent.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'image-cropper',\n                        template: \"<div [style.background]=\\\"imageVisible && backgroundColor\\\"\\n     #wrapper\\n>\\n    <img\\n      #sourceImage\\n      class=\\\"source-image\\\"\\n      *ngIf=\\\"safeImgDataUrl\\\"\\n      [src]=\\\"safeImgDataUrl\\\"\\n      [style.visibility]=\\\"imageVisible ? 'visible' : 'hidden'\\\"\\n      [style.transform]=\\\"safeTransformStyle\\\"\\n      (load)=\\\"imageLoadedInView()\\\"\\n    />\\n    <div\\n        class=\\\"overlay\\\"\\n        [style.width.px]=\\\"maxSize.width\\\"\\n        [style.height.px]=\\\"maxSize.height\\\"\\n        [style.margin-left]=\\\"alignImage === 'center' ? marginLeft : null\\\"\\n    ></div>\\n    <div class=\\\"cropper\\\"\\n         *ngIf=\\\"imageVisible\\\"\\n         [class.rounded]=\\\"roundCropper\\\"\\n         [style.top.px]=\\\"cropper.y1\\\"\\n         [style.left.px]=\\\"cropper.x1\\\"\\n         [style.width.px]=\\\"cropper.x2 - cropper.x1\\\"\\n         [style.height.px]=\\\"cropper.y2 - cropper.y1\\\"\\n         [style.margin-left]=\\\"alignImage === 'center' ? marginLeft : null\\\"\\n         [style.visibility]=\\\"imageVisible ? 'visible' : 'hidden'\\\"\\n         (keydown)=\\\"keyboardAccess($event)\\\"\\n         tabindex=\\\"0\\\"\\n    >\\n        <div\\n            (mousedown)=\\\"startMove($event, moveTypes.Move)\\\"\\n            (touchstart)=\\\"startMove($event, moveTypes.Move)\\\"\\n            class=\\\"move\\\">\\n        </div>\\n        <ng-container *ngIf=\\\"!hideResizeSquares\\\">\\n            <span class=\\\"resize topleft\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'topleft')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'topleft')\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize top\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize topright\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'topright')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'topright')\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize right\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize bottomright\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'bottomright')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'bottomright')\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize bottom\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize bottomleft\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'bottomleft')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'bottomleft')\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize left\\\">\\n                <span class=\\\"square\\\"></span>\\n            </span>\\n            <span class=\\\"resize-bar top\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'top')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'top')\\\">\\n            </span>\\n            <span class=\\\"resize-bar right\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'right')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'right')\\\">\\n            </span>\\n            <span class=\\\"resize-bar bottom\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'bottom')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'bottom')\\\">\\n            </span>\\n            <span class=\\\"resize-bar left\\\"\\n                  (mousedown)=\\\"startMove($event, moveTypes.Resize, 'left')\\\"\\n                  (touchstart)=\\\"startMove($event, moveTypes.Resize, 'left')\\\">\\n            </span>\\n        </ng-container>\\n    </div>\\n</div>\\n\",\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\":host{display:flex;position:relative;width:100%;max-width:100%;max-height:100%;overflow:hidden;padding:5px;text-align:center}:host>div{width:100%;position:relative}:host>div img.source-image{max-width:100%;max-height:100%;transform-origin:center}:host .overlay{position:absolute;pointer-events:none;touch-action:none;outline:var(--cropper-overlay-color,#fff) solid 100vw;top:0;left:0}:host .cropper{position:absolute;display:flex;color:#53535c;background:0 0;outline:rgba(255,255,255,.3) solid 100vw;outline:var(--cropper-outline-color,rgba(255,255,255,.3)) solid 100vw;touch-action:none}:host .cropper:after{position:absolute;content:\\\"\\\";top:0;bottom:0;left:0;right:0;pointer-events:none;border:1px dashed;opacity:.75;color:inherit;z-index:1}:host .cropper .move{width:100%;cursor:move;border:1px solid rgba(255,255,255,.5)}:host .cropper:focus .move{border-color:#1e90ff;border-width:2px}:host .cropper .resize{position:absolute;display:inline-block;line-height:6px;padding:8px;opacity:.85;z-index:1}:host .cropper .resize .square{display:inline-block;background:#53535c;width:6px;height:6px;border:1px solid rgba(255,255,255,.5);box-sizing:content-box}:host .cropper .resize.topleft{top:-12px;left:-12px;cursor:nwse-resize}:host .cropper .resize.top{top:-12px;left:calc(50% - 12px);cursor:ns-resize}:host .cropper .resize.topright{top:-12px;right:-12px;cursor:nesw-resize}:host .cropper .resize.right{top:calc(50% - 12px);right:-12px;cursor:ew-resize}:host .cropper .resize.bottomright{bottom:-12px;right:-12px;cursor:nwse-resize}:host .cropper .resize.bottom{bottom:-12px;left:calc(50% - 12px);cursor:ns-resize}:host .cropper .resize.bottomleft{bottom:-12px;left:-12px;cursor:nesw-resize}:host .cropper .resize.left{top:calc(50% - 12px);left:-12px;cursor:ew-resize}:host .cropper .resize-bar{position:absolute;z-index:1}:host .cropper .resize-bar.top{top:-11px;left:11px;width:calc(100% - 22px);height:22px;cursor:ns-resize}:host .cropper .resize-bar.right{top:11px;right:-11px;height:calc(100% - 22px);width:22px;cursor:ew-resize}:host .cropper .resize-bar.bottom{bottom:-11px;left:11px;width:calc(100% - 22px);height:22px;cursor:ns-resize}:host .cropper .resize-bar.left{top:11px;left:-11px;height:calc(100% - 22px);width:22px;cursor:ew-resize}:host .cropper.rounded{outline-color:transparent}:host .cropper.rounded:after{border-radius:100%;box-shadow:0 0 0 100vw rgba(255,255,255,.3);box-shadow:0 0 0 100vw var(--cropper-outline-color,rgba(255,255,255,.3))}@media (orientation:portrait){:host .cropper{outline-width:100vh}:host .cropper.rounded:after{box-shadow:0 0 0 100vh rgba(255,255,255,.3);box-shadow:0 0 0 100vh var(--cropper-outline-color,rgba(255,255,255,.3))}}:host .cropper.rounded .move{border-radius:100%}:host.disabled .cropper .move,:host.disabled .cropper .resize,:host.disabled .cropper .resize-bar{display:none}\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        ImageCropperComponent.ctorParameters = function () { return [\n            { type: CropService },\n            { type: CropperPositionService },\n            { type: LoadImageService },\n            { type: platformBrowser.DomSanitizer },\n            { type: core.ChangeDetectorRef }\n        ]; };\n        ImageCropperComponent.propDecorators = {\n            wrapper: [{ type: core.ViewChild, args: ['wrapper', { static: true },] }],\n            sourceImage: [{ type: core.ViewChild, args: ['sourceImage', { static: false },] }],\n            imageChangedEvent: [{ type: core.Input }],\n            imageURL: [{ type: core.Input }],\n            imageBase64: [{ type: core.Input }],\n            imageFile: [{ type: core.Input }],\n            format: [{ type: core.Input }],\n            transform: [{ type: core.Input }],\n            maintainAspectRatio: [{ type: core.Input }],\n            aspectRatio: [{ type: core.Input }],\n            resizeToWidth: [{ type: core.Input }],\n            resizeToHeight: [{ type: core.Input }],\n            cropperMinWidth: [{ type: core.Input }],\n            cropperMinHeight: [{ type: core.Input }],\n            cropperMaxHeight: [{ type: core.Input }],\n            cropperMaxWidth: [{ type: core.Input }],\n            cropperStaticWidth: [{ type: core.Input }],\n            cropperStaticHeight: [{ type: core.Input }],\n            canvasRotation: [{ type: core.Input }],\n            initialStepSize: [{ type: core.Input }],\n            roundCropper: [{ type: core.Input }],\n            onlyScaleDown: [{ type: core.Input }],\n            imageQuality: [{ type: core.Input }],\n            autoCrop: [{ type: core.Input }],\n            backgroundColor: [{ type: core.Input }],\n            containWithinAspectRatio: [{ type: core.Input }],\n            hideResizeSquares: [{ type: core.Input }],\n            cropper: [{ type: core.Input }],\n            alignImage: [{ type: core.HostBinding, args: ['style.text-align',] }, { type: core.Input }],\n            disabled: [{ type: core.HostBinding, args: ['class.disabled',] }, { type: core.Input }],\n            imageCropped: [{ type: core.Output }],\n            startCropImage: [{ type: core.Output }],\n            imageLoaded: [{ type: core.Output }],\n            cropperReady: [{ type: core.Output }],\n            loadImageFailed: [{ type: core.Output }],\n            onResize: [{ type: core.HostListener, args: ['window:resize',] }],\n            moveImg: [{ type: core.HostListener, args: ['document:mousemove', ['$event'],] }, { type: core.HostListener, args: ['document:touchmove', ['$event'],] }],\n            moveStop: [{ type: core.HostListener, args: ['document:mouseup',] }, { type: core.HostListener, args: ['document:touchend',] }]\n        };\n        return ImageCropperComponent;\n    }());\n    if (false) {\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.Hammer;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.settings;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.setImageMaxSizeRetries;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.moveStart;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.loadedImage;\n        /** @type {?} */\n        ImageCropperComponent.prototype.safeImgDataUrl;\n        /** @type {?} */\n        ImageCropperComponent.prototype.safeTransformStyle;\n        /** @type {?} */\n        ImageCropperComponent.prototype.marginLeft;\n        /** @type {?} */\n        ImageCropperComponent.prototype.maxSize;\n        /** @type {?} */\n        ImageCropperComponent.prototype.moveTypes;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageVisible;\n        /** @type {?} */\n        ImageCropperComponent.prototype.wrapper;\n        /** @type {?} */\n        ImageCropperComponent.prototype.sourceImage;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageChangedEvent;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageURL;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageBase64;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageFile;\n        /** @type {?} */\n        ImageCropperComponent.prototype.format;\n        /** @type {?} */\n        ImageCropperComponent.prototype.transform;\n        /** @type {?} */\n        ImageCropperComponent.prototype.maintainAspectRatio;\n        /** @type {?} */\n        ImageCropperComponent.prototype.aspectRatio;\n        /** @type {?} */\n        ImageCropperComponent.prototype.resizeToWidth;\n        /** @type {?} */\n        ImageCropperComponent.prototype.resizeToHeight;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperMinWidth;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperMinHeight;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperMaxHeight;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperMaxWidth;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperStaticWidth;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperStaticHeight;\n        /** @type {?} */\n        ImageCropperComponent.prototype.canvasRotation;\n        /** @type {?} */\n        ImageCropperComponent.prototype.initialStepSize;\n        /** @type {?} */\n        ImageCropperComponent.prototype.roundCropper;\n        /** @type {?} */\n        ImageCropperComponent.prototype.onlyScaleDown;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageQuality;\n        /** @type {?} */\n        ImageCropperComponent.prototype.autoCrop;\n        /** @type {?} */\n        ImageCropperComponent.prototype.backgroundColor;\n        /** @type {?} */\n        ImageCropperComponent.prototype.containWithinAspectRatio;\n        /** @type {?} */\n        ImageCropperComponent.prototype.hideResizeSquares;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropper;\n        /** @type {?} */\n        ImageCropperComponent.prototype.alignImage;\n        /** @type {?} */\n        ImageCropperComponent.prototype.disabled;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageCropped;\n        /** @type {?} */\n        ImageCropperComponent.prototype.startCropImage;\n        /** @type {?} */\n        ImageCropperComponent.prototype.imageLoaded;\n        /** @type {?} */\n        ImageCropperComponent.prototype.cropperReady;\n        /** @type {?} */\n        ImageCropperComponent.prototype.loadImageFailed;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.cropService;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.cropperPositionService;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.loadImageService;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.sanitizer;\n        /**\n         * @type {?}\n         * @private\n         */\n        ImageCropperComponent.prototype.cd;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/image-cropper.module.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var ImageCropperModule = /** @class */ (function () {\n        function ImageCropperModule() {\n        }\n        ImageCropperModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [\n                            common.CommonModule\n                        ],\n                        declarations: [\n                            ImageCropperComponent\n                        ],\n                        exports: [\n                            ImageCropperComponent\n                        ]\n                    },] }\n        ];\n        return ImageCropperModule;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/interfaces/index.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n\n    /**\n     * @fileoverview added by tsickle\n     * Generated from: lib/utils/blob.utils.ts\n     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @param {?} base64Image\n     * @return {?}\n     */\n    function base64ToFile(base64Image) {\n        /** @type {?} */\n        var split = base64Image.split(',');\n        /** @type {?} */\n        var type = split[0].replace('data:', '').replace(';base64', '');\n        /** @type {?} */\n        var byteString = atob(split[1]);\n        /** @type {?} */\n        var ab = new ArrayBuffer(byteString.length);\n        /** @type {?} */\n        var ia = new Uint8Array(ab);\n        for (var i = 0; i < byteString.length; i += 1) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n        return new Blob([ab], { type: type });\n    }\n\n    exports.ImageCropperComponent = ImageCropperComponent;\n    exports.ImageCropperModule = ImageCropperModule;\n    exports.base64ToFile = base64ToFile;\n    exports.resizeCanvas = resizeCanvas;\n    exports.ɵa = CropService;\n    exports.ɵb = CropperPositionService;\n    exports.ɵc = LoadImageService;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}