/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/crop.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { resizeCanvas } from '../utils/resize.utils';
import * as i0 from "@angular/core";
import * as ɵngcc0 from '@angular/core';
var CropService = /** @class */ (function () {
    function CropService() {
    }
    /**
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    CropService.prototype.crop = /**
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    function (sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        var imagePosition = this.getImagePosition(sourceImage, loadedImage, cropper, settings);
        /** @type {?} */
        var width = imagePosition.x2 - imagePosition.x1;
        /** @type {?} */
        var height = imagePosition.y2 - imagePosition.y1;
        /** @type {?} */
        var cropCanvas = (/** @type {?} */ (document.createElement('canvas')));
        cropCanvas.width = width;
        cropCanvas.height = height;
        /** @type {?} */
        var ctx = cropCanvas.getContext('2d');
        if (!ctx) {
            return;
        }
        if (settings.backgroundColor != null) {
            ctx.fillStyle = settings.backgroundColor;
            ctx.fillRect(0, 0, width, height);
        }
        /** @type {?} */
        var scaleX = (settings.transform.scale || 1) * (settings.transform.flipH ? -1 : 1);
        /** @type {?} */
        var scaleY = (settings.transform.scale || 1) * (settings.transform.flipV ? -1 : 1);
        /** @type {?} */
        var transformedImage = loadedImage.transformed;
        ctx.setTransform(scaleX, 0, 0, scaleY, transformedImage.size.width / 2, transformedImage.size.height / 2);
        ctx.translate(-imagePosition.x1 / scaleX, -imagePosition.y1 / scaleY);
        ctx.rotate((settings.transform.rotate || 0) * Math.PI / 180);
        ctx.drawImage(transformedImage.image, -transformedImage.size.width / 2, -transformedImage.size.height / 2);
        /** @type {?} */
        var output = {
            width: width, height: height,
            imagePosition: imagePosition,
            cropperPosition: tslib_1.__assign({}, cropper)
        };
        if (settings.containWithinAspectRatio) {
            output.offsetImagePosition = this.getOffsetImagePosition(sourceImage, loadedImage, cropper, settings);
        }
        /** @type {?} */
        var resizeRatio = this.getResizeRatio(width, height, settings);
        if (resizeRatio !== 1) {
            output.width = Math.round(width * resizeRatio);
            output.height = settings.maintainAspectRatio
                ? Math.round(output.width / settings.aspectRatio)
                : Math.round(height * resizeRatio);
            resizeCanvas(cropCanvas, output.width, output.height);
        }
        output.base64 = cropCanvas.toDataURL('image/' + settings.format, this.getQuality(settings));
        return output;
    };
    /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    CropService.prototype.getImagePosition = /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    function (sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        var sourceImageElement = sourceImage.nativeElement;
        /** @type {?} */
        var ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;
        /** @type {?} */
        var out = {
            x1: Math.round(cropper.x1 * ratio),
            y1: Math.round(cropper.y1 * ratio),
            x2: Math.round(cropper.x2 * ratio),
            y2: Math.round(cropper.y2 * ratio)
        };
        if (!settings.containWithinAspectRatio) {
            out.x1 = Math.max(out.x1, 0);
            out.y1 = Math.max(out.y1, 0);
            out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);
            out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);
        }
        return out;
    };
    /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    CropService.prototype.getOffsetImagePosition = /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    function (sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        var canvasRotation = settings.canvasRotation + loadedImage.exifTransform.rotate;
        /** @type {?} */
        var sourceImageElement = sourceImage.nativeElement;
        /** @type {?} */
        var ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;
        /** @type {?} */
        var offsetX;
        /** @type {?} */
        var offsetY;
        if (canvasRotation % 2) {
            offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.height) / 2;
            offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.width) / 2;
        }
        else {
            offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.width) / 2;
            offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.height) / 2;
        }
        /** @type {?} */
        var out = {
            x1: Math.round(cropper.x1 * ratio) - offsetX,
            y1: Math.round(cropper.y1 * ratio) - offsetY,
            x2: Math.round(cropper.x2 * ratio) - offsetX,
            y2: Math.round(cropper.y2 * ratio) - offsetY
        };
        if (!settings.containWithinAspectRatio) {
            out.x1 = Math.max(out.x1, 0);
            out.y1 = Math.max(out.y1, 0);
            out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);
            out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);
        }
        return out;
    };
    /**
     * @param {?} width
     * @param {?} height
     * @param {?} settings
     * @return {?}
     */
    CropService.prototype.getResizeRatio = /**
     * @param {?} width
     * @param {?} height
     * @param {?} settings
     * @return {?}
     */
    function (width, height, settings) {
        /** @type {?} */
        var ratioWidth = settings.resizeToWidth / width;
        /** @type {?} */
        var ratioHeight = settings.resizeToHeight / height;
        /** @type {?} */
        var ratios = new Array();
        if (settings.resizeToWidth > 0) {
            ratios.push(ratioWidth);
        }
        if (settings.resizeToHeight > 0) {
            ratios.push(ratioHeight);
        }
        /** @type {?} */
        var result = ratios.length === 0 ? 1 : Math.min.apply(Math, tslib_1.__spread(ratios));
        if (result > 1 && !settings.onlyScaleDown) {
            return result;
        }
        return Math.min(result, 1);
    };
    /**
     * @param {?} settings
     * @return {?}
     */
    CropService.prototype.getQuality = /**
     * @param {?} settings
     * @return {?}
     */
    function (settings) {
        return Math.min(1, Math.max(0, settings.imageQuality / 100));
    };
    /** @nocollapse */ CropService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function CropService_Factory() { return new CropService(); }, token: CropService, providedIn: "root" });
CropService.ɵfac = function CropService_Factory(t) { return new (t || CropService)(); };
CropService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CropService, factory: function (t) { return CropService.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CropService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
    return CropService;
}());
export { CropService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWltYWdlLWNyb3BwZXIvZXNtNS9saWIvc2VydmljZXMvY3JvcC5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFvTU0sQUFHQTs7Ozs7OztnREFDd0wiLCJmaWxlIjoiY3JvcC5zZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBsaWIvc2VydmljZXMvY3JvcC5zZXJ2aWNlLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyByZXNpemVDYW52YXMgfSBmcm9tICcuLi91dGlscy9yZXNpemUudXRpbHMnO1xuaW1wb3J0ICogYXMgaTAgZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbnZhciBDcm9wU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDcm9wU2VydmljZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VJbWFnZVxuICAgICAqIEBwYXJhbSB7P30gbG9hZGVkSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGNyb3BwZXJcbiAgICAgKiBAcGFyYW0gez99IHNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDcm9wU2VydmljZS5wcm90b3R5cGUuY3JvcCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHNvdXJjZUltYWdlLCBsb2FkZWRJbWFnZSwgY3JvcHBlciwgc2V0dGluZ3MpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaW1hZ2VQb3NpdGlvbiA9IHRoaXMuZ2V0SW1hZ2VQb3NpdGlvbihzb3VyY2VJbWFnZSwgbG9hZGVkSW1hZ2UsIGNyb3BwZXIsIHNldHRpbmdzKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZVBvc2l0aW9uLngyIC0gaW1hZ2VQb3NpdGlvbi54MTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VQb3NpdGlvbi55MiAtIGltYWdlUG9zaXRpb24ueTE7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGNyb3BDYW52YXMgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpKTtcbiAgICAgICAgY3JvcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjcm9wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY3R4ID0gY3JvcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNldHRpbmdzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBzY2FsZVggPSAoc2V0dGluZ3MudHJhbnNmb3JtLnNjYWxlIHx8IDEpICogKHNldHRpbmdzLnRyYW5zZm9ybS5mbGlwSCA/IC0xIDogMSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHNjYWxlWSA9IChzZXR0aW5ncy50cmFuc2Zvcm0uc2NhbGUgfHwgMSkgKiAoc2V0dGluZ3MudHJhbnNmb3JtLmZsaXBWID8gLTEgOiAxKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRJbWFnZSA9IGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgMCwgMCwgc2NhbGVZLCB0cmFuc2Zvcm1lZEltYWdlLnNpemUud2lkdGggLyAyLCB0cmFuc2Zvcm1lZEltYWdlLnNpemUuaGVpZ2h0IC8gMik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWltYWdlUG9zaXRpb24ueDEgLyBzY2FsZVgsIC1pbWFnZVBvc2l0aW9uLnkxIC8gc2NhbGVZKTtcbiAgICAgICAgY3R4LnJvdGF0ZSgoc2V0dGluZ3MudHJhbnNmb3JtLnJvdGF0ZSB8fCAwKSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRyYW5zZm9ybWVkSW1hZ2UuaW1hZ2UsIC10cmFuc2Zvcm1lZEltYWdlLnNpemUud2lkdGggLyAyLCAtdHJhbnNmb3JtZWRJbWFnZS5zaXplLmhlaWdodCAvIDIpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaW1hZ2VQb3NpdGlvbjogaW1hZ2VQb3NpdGlvbixcbiAgICAgICAgICAgIGNyb3BwZXJQb3NpdGlvbjogdHNsaWJfMS5fX2Fzc2lnbih7fSwgY3JvcHBlcilcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbnRhaW5XaXRoaW5Bc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgb3V0cHV0Lm9mZnNldEltYWdlUG9zaXRpb24gPSB0aGlzLmdldE9mZnNldEltYWdlUG9zaXRpb24oc291cmNlSW1hZ2UsIGxvYWRlZEltYWdlLCBjcm9wcGVyLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcmVzaXplUmF0aW8gPSB0aGlzLmdldFJlc2l6ZVJhdGlvKHdpZHRoLCBoZWlnaHQsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKHJlc2l6ZVJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBvdXRwdXQud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogcmVzaXplUmF0aW8pO1xuICAgICAgICAgICAgb3V0cHV0LmhlaWdodCA9IHNldHRpbmdzLm1haW50YWluQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICA/IE1hdGgucm91bmQob3V0cHV0LndpZHRoIC8gc2V0dGluZ3MuYXNwZWN0UmF0aW8pXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKGhlaWdodCAqIHJlc2l6ZVJhdGlvKTtcbiAgICAgICAgICAgIHJlc2l6ZUNhbnZhcyhjcm9wQ2FudmFzLCBvdXRwdXQud2lkdGgsIG91dHB1dC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5iYXNlNjQgPSBjcm9wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvJyArIHNldHRpbmdzLmZvcm1hdCwgdGhpcy5nZXRRdWFsaXR5KHNldHRpbmdzKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3JvcFNlcnZpY2UucHJvdG90eXBlLmdldEltYWdlUG9zaXRpb24gPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHNvdXJjZUltYWdlLCBsb2FkZWRJbWFnZSwgY3JvcHBlciwgc2V0dGluZ3MpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc291cmNlSW1hZ2VFbGVtZW50ID0gc291cmNlSW1hZ2UubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcmF0aW8gPSBsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLndpZHRoIC8gc291cmNlSW1hZ2VFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICB4MTogTWF0aC5yb3VuZChjcm9wcGVyLngxICogcmF0aW8pLFxuICAgICAgICAgICAgeTE6IE1hdGgucm91bmQoY3JvcHBlci55MSAqIHJhdGlvKSxcbiAgICAgICAgICAgIHgyOiBNYXRoLnJvdW5kKGNyb3BwZXIueDIgKiByYXRpbyksXG4gICAgICAgICAgICB5MjogTWF0aC5yb3VuZChjcm9wcGVyLnkyICogcmF0aW8pXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc2V0dGluZ3MuY29udGFpbldpdGhpbkFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBvdXQueDEgPSBNYXRoLm1heChvdXQueDEsIDApO1xuICAgICAgICAgICAgb3V0LnkxID0gTWF0aC5tYXgob3V0LnkxLCAwKTtcbiAgICAgICAgICAgIG91dC54MiA9IE1hdGgubWluKG91dC54MiwgbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICBvdXQueTIgPSBNYXRoLm1pbihvdXQueTIsIGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZUltYWdlXG4gICAgICogQHBhcmFtIHs/fSBsb2FkZWRJbWFnZVxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclxuICAgICAqIEBwYXJhbSB7P30gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENyb3BTZXJ2aWNlLnByb3RvdHlwZS5nZXRPZmZzZXRJbWFnZVBvc2l0aW9uID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZUltYWdlXG4gICAgICogQHBhcmFtIHs/fSBsb2FkZWRJbWFnZVxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclxuICAgICAqIEBwYXJhbSB7P30gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzb3VyY2VJbWFnZSwgbG9hZGVkSW1hZ2UsIGNyb3BwZXIsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGNhbnZhc1JvdGF0aW9uID0gc2V0dGluZ3MuY2FudmFzUm90YXRpb24gKyBsb2FkZWRJbWFnZS5leGlmVHJhbnNmb3JtLnJvdGF0ZTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc291cmNlSW1hZ2VFbGVtZW50ID0gc291cmNlSW1hZ2UubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcmF0aW8gPSBsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLndpZHRoIC8gc291cmNlSW1hZ2VFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvZmZzZXRYO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvZmZzZXRZO1xuICAgICAgICBpZiAoY2FudmFzUm90YXRpb24gJSAyKSB7XG4gICAgICAgICAgICBvZmZzZXRYID0gKGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkLnNpemUud2lkdGggLSBsb2FkZWRJbWFnZS5vcmlnaW5hbC5zaXplLmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgb2Zmc2V0WSA9IChsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLmhlaWdodCAtIGxvYWRlZEltYWdlLm9yaWdpbmFsLnNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldFggPSAobG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCAtIGxvYWRlZEltYWdlLm9yaWdpbmFsLnNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIG9mZnNldFkgPSAobG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS5oZWlnaHQgLSBsb2FkZWRJbWFnZS5vcmlnaW5hbC5zaXplLmhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgIHgxOiBNYXRoLnJvdW5kKGNyb3BwZXIueDEgKiByYXRpbykgLSBvZmZzZXRYLFxuICAgICAgICAgICAgeTE6IE1hdGgucm91bmQoY3JvcHBlci55MSAqIHJhdGlvKSAtIG9mZnNldFksXG4gICAgICAgICAgICB4MjogTWF0aC5yb3VuZChjcm9wcGVyLngyICogcmF0aW8pIC0gb2Zmc2V0WCxcbiAgICAgICAgICAgIHkyOiBNYXRoLnJvdW5kKGNyb3BwZXIueTIgKiByYXRpbykgLSBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc2V0dGluZ3MuY29udGFpbldpdGhpbkFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBvdXQueDEgPSBNYXRoLm1heChvdXQueDEsIDApO1xuICAgICAgICAgICAgb3V0LnkxID0gTWF0aC5tYXgob3V0LnkxLCAwKTtcbiAgICAgICAgICAgIG91dC54MiA9IE1hdGgubWluKG91dC54MiwgbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICBvdXQueTIgPSBNYXRoLm1pbihvdXQueTIsIGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB3aWR0aFxuICAgICAqIEBwYXJhbSB7P30gaGVpZ2h0XG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3JvcFNlcnZpY2UucHJvdG90eXBlLmdldFJlc2l6ZVJhdGlvID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB3aWR0aFxuICAgICAqIEBwYXJhbSB7P30gaGVpZ2h0XG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJhdGlvV2lkdGggPSBzZXR0aW5ncy5yZXNpemVUb1dpZHRoIC8gd2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJhdGlvSGVpZ2h0ID0gc2V0dGluZ3MucmVzaXplVG9IZWlnaHQgLyBoZWlnaHQ7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJhdGlvcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBpZiAoc2V0dGluZ3MucmVzaXplVG9XaWR0aCA+IDApIHtcbiAgICAgICAgICAgIHJhdGlvcy5wdXNoKHJhdGlvV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZXNpemVUb0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgIHJhdGlvcy5wdXNoKHJhdGlvSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciByZXN1bHQgPSByYXRpb3MubGVuZ3RoID09PSAwID8gMSA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHRzbGliXzEuX19zcHJlYWQocmF0aW9zKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPiAxICYmICFzZXR0aW5ncy5vbmx5U2NhbGVEb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyZXN1bHQsIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3JvcFNlcnZpY2UucHJvdG90eXBlLmdldFF1YWxpdHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHNldHRpbmdzLmltYWdlUXVhbGl0eSAvIDEwMCkpO1xuICAgIH07XG4gICAgQ3JvcFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBDcm9wU2VydmljZS5uZ0luamVjdGFibGVEZWYgPSBpMC7Jtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIENyb3BTZXJ2aWNlX0ZhY3RvcnkoKSB7IHJldHVybiBuZXcgQ3JvcFNlcnZpY2UoKTsgfSwgdG9rZW46IENyb3BTZXJ2aWNlLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gQ3JvcFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0IHsgQ3JvcFNlcnZpY2UgfTtcbiJdfQ==