/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/load-image.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { getTransformationsFromExifData, supportsAutomaticRotation } from '../utils/exif.utils';
import * as i0 from "@angular/core";
/**
 * @record
 */
import * as Éµngcc0 from '@angular/core';
function LoadImageBase64() { }
if (false) {
    /** @type {?} */
    LoadImageBase64.prototype.originalImage;
    /** @type {?} */
    LoadImageBase64.prototype.originalBase64;
}
export class LoadImageService {
    constructor() {
        this.autoRotateSupported = supportsAutomaticRotation();
    }
    /**
     * @param {?} file
     * @param {?} cropperSettings
     * @return {?}
     */
    loadImageFile(file, cropperSettings) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const fileReader = new FileReader();
            fileReader.onload = (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.loadImage(event.target.result, file.type, cropperSettings)
                    .then(resolve)
                    .catch(reject);
            });
            fileReader.readAsDataURL(file);
        }));
    }
    /**
     * @private
     * @param {?} imageBase64
     * @param {?} imageType
     * @param {?} cropperSettings
     * @return {?}
     */
    loadImage(imageBase64, imageType, cropperSettings) {
        if (!this.isValidImageType(imageType)) {
            return Promise.reject(new Error('Invalid image type'));
        }
        return this.loadBase64Image(imageBase64, cropperSettings);
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    isValidImageType(type) {
        return /image\/(png|jpg|jpeg|bmp|gif|tiff|webp)/.test(type);
    }
    /**
     * @param {?} url
     * @param {?} cropperSettings
     * @return {?}
     */
    loadImageFromURL(url, cropperSettings) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const img = new Image();
            img.onerror = (/**
             * @return {?}
             */
            () => reject);
            img.onload = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const canvas = document.createElement('canvas');
                /** @type {?} */
                const context = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                context.drawImage(img, 0, 0);
                this.loadBase64Image(canvas.toDataURL(), cropperSettings).then(resolve);
            });
            img.crossOrigin = 'anonymous';
            img.src = url;
        }));
    }
    /**
     * @param {?} imageBase64
     * @param {?} cropperSettings
     * @return {?}
     */
    loadBase64Image(imageBase64, cropperSettings) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const originalImage = new Image();
            originalImage.onload = (/**
             * @return {?}
             */
            () => resolve({
                originalImage,
                originalBase64: imageBase64
            }));
            originalImage.onerror = reject;
            originalImage.src = imageBase64;
        })).then((/**
         * @param {?} res
         * @return {?}
         */
        (res) => this.transformImageBase64(res, cropperSettings)));
    }
    /**
     * @private
     * @param {?} res
     * @param {?} cropperSettings
     * @return {?}
     */
    transformImageBase64(res, cropperSettings) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const autoRotate = yield this.autoRotateSupported;
            /** @type {?} */
            const exifTransform = yield getTransformationsFromExifData(autoRotate ? -1 : res.originalBase64);
            if (!res.originalImage || !res.originalImage.complete) {
                return Promise.reject(new Error('No image loaded'));
            }
            /** @type {?} */
            const loadedImage = {
                original: {
                    base64: res.originalBase64,
                    image: res.originalImage,
                    size: {
                        width: res.originalImage.naturalWidth,
                        height: res.originalImage.naturalHeight
                    }
                },
                exifTransform
            };
            return this.transformLoadedImage(loadedImage, cropperSettings);
        });
    }
    /**
     * @param {?} loadedImage
     * @param {?} cropperSettings
     * @return {?}
     */
    transformLoadedImage(loadedImage, cropperSettings) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const canvasRotation = cropperSettings.canvasRotation + loadedImage.exifTransform.rotate;
            /** @type {?} */
            const originalSize = {
                width: loadedImage.original.image.naturalWidth,
                height: loadedImage.original.image.naturalHeight
            };
            if (canvasRotation === 0 && !loadedImage.exifTransform.flip && !cropperSettings.containWithinAspectRatio) {
                return {
                    original: {
                        base64: loadedImage.original.base64,
                        image: loadedImage.original.image,
                        size: Object.assign({}, originalSize)
                    },
                    transformed: {
                        base64: loadedImage.original.base64,
                        image: loadedImage.original.image,
                        size: Object.assign({}, originalSize)
                    },
                    exifTransform: loadedImage.exifTransform
                };
            }
            /** @type {?} */
            const transformedSize = this.getTransformedSize(originalSize, loadedImage.exifTransform, cropperSettings);
            /** @type {?} */
            const canvas = document.createElement('canvas');
            canvas.width = transformedSize.width;
            canvas.height = transformedSize.height;
            /** @type {?} */
            const ctx = canvas.getContext('2d');
            ctx.setTransform(loadedImage.exifTransform.flip ? -1 : 1, 0, 0, 1, canvas.width / 2, canvas.height / 2);
            ctx.rotate(Math.PI * (canvasRotation / 2));
            ctx.drawImage(loadedImage.original.image, -originalSize.width / 2, -originalSize.height / 2);
            /** @type {?} */
            const transformedBase64 = canvas.toDataURL();
            /** @type {?} */
            const transformedImage = yield this.loadImageFromBase64(transformedBase64);
            return {
                original: {
                    base64: loadedImage.original.base64,
                    image: loadedImage.original.image,
                    size: Object.assign({}, originalSize)
                },
                transformed: {
                    base64: transformedBase64,
                    image: transformedImage,
                    size: {
                        width: transformedImage.width,
                        height: transformedImage.height
                    }
                },
                exifTransform: loadedImage.exifTransform
            };
        });
    }
    /**
     * @private
     * @param {?} imageBase64
     * @return {?}
     */
    loadImageFromBase64(imageBase64) {
        return new Promise(((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const image = new Image();
            image.onload = (/**
             * @return {?}
             */
            () => resolve(image));
            image.onerror = reject;
            image.src = imageBase64;
        })));
    }
    /**
     * @private
     * @param {?} originalSize
     * @param {?} exifTransform
     * @param {?} cropperSettings
     * @return {?}
     */
    getTransformedSize(originalSize, exifTransform, cropperSettings) {
        /** @type {?} */
        const canvasRotation = cropperSettings.canvasRotation + exifTransform.rotate;
        if (cropperSettings.containWithinAspectRatio) {
            if (canvasRotation % 2) {
                /** @type {?} */
                const minWidthToContain = originalSize.width * cropperSettings.aspectRatio;
                /** @type {?} */
                const minHeightToContain = originalSize.height / cropperSettings.aspectRatio;
                return {
                    width: Math.max(originalSize.height, minWidthToContain),
                    height: Math.max(originalSize.width, minHeightToContain)
                };
            }
            else {
                /** @type {?} */
                const minWidthToContain = originalSize.height * cropperSettings.aspectRatio;
                /** @type {?} */
                const minHeightToContain = originalSize.width / cropperSettings.aspectRatio;
                return {
                    width: Math.max(originalSize.width, minWidthToContain),
                    height: Math.max(originalSize.height, minHeightToContain)
                };
            }
        }
        if (canvasRotation % 2) {
            return {
                height: originalSize.width,
                width: originalSize.height
            };
        }
        return {
            width: originalSize.width,
            height: originalSize.height
        };
    }
}
LoadImageService.Éµfac = function LoadImageService_Factory(t) { return new (t || LoadImageService)(); };
LoadImageService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({ token: LoadImageService, factory: LoadImageService.Éµfac, providedIn: 'root' });
/** @nocollapse */ LoadImageService.ngInjectableDef = i0.ÉµÉµdefineInjectable({ factory: function LoadImageService_Factory() { return new LoadImageService(); }, token: LoadImageService, providedIn: "root" });
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(LoadImageService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    LoadImageService.prototype.autoRotateSupported;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWltYWdlLWNyb3BwZXIvZXNtMjAxNS9saWIvc2VydmljZXMvbG9hZC1pbWFnZS5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdVJDLG1JQUdDOzs7OztnREFDNE0iLCJmaWxlIjoibG9hZC1pbWFnZS5zZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBsaWIvc2VydmljZXMvbG9hZC1pbWFnZS5zZXJ2aWNlLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRUcmFuc2Zvcm1hdGlvbnNGcm9tRXhpZkRhdGEsIHN1cHBvcnRzQXV0b21hdGljUm90YXRpb24gfSBmcm9tICcuLi91dGlscy9leGlmLnV0aWxzJztcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZnVuY3Rpb24gTG9hZEltYWdlQmFzZTY0KCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTG9hZEltYWdlQmFzZTY0LnByb3RvdHlwZS5vcmlnaW5hbEltYWdlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBMb2FkSW1hZ2VCYXNlNjQucHJvdG90eXBlLm9yaWdpbmFsQmFzZTY0O1xufVxuZXhwb3J0IGNsYXNzIExvYWRJbWFnZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmF1dG9Sb3RhdGVTdXBwb3J0ZWQgPSBzdXBwb3J0c0F1dG9tYXRpY1JvdGF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VGaWxlKGZpbGUsIGNyb3BwZXJTZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlc29sdmVcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWplY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShldmVudC50YXJnZXQucmVzdWx0LCBmaWxlLnR5cGUsIGNyb3BwZXJTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW1hZ2VCYXNlNjRcbiAgICAgKiBAcGFyYW0gez99IGltYWdlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2UoaW1hZ2VCYXNlNjQsIGltYWdlVHlwZSwgY3JvcHBlclNldHRpbmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkSW1hZ2VUeXBlKGltYWdlVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgaW1hZ2UgdHlwZScpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkQmFzZTY0SW1hZ2UoaW1hZ2VCYXNlNjQsIGNyb3BwZXJTZXR0aW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBpc1ZhbGlkSW1hZ2VUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIC9pbWFnZVxcLyhwbmd8anBnfGpwZWd8Ym1wfGdpZnx0aWZmfHdlYnApLy50ZXN0KHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VGcm9tVVJMKHVybCwgY3JvcHBlclNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVzb2x2ZVxuICAgICAgICAgKiBAcGFyYW0gez99IHJlamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25lcnJvciA9ICgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICgpID0+IHJlamVjdCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEJhc2U2NEltYWdlKGNhbnZhcy50b0RhdGFVUkwoKSwgY3JvcHBlclNldHRpbmdzKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbWFnZUJhc2U2NFxuICAgICAqIEBwYXJhbSB7P30gY3JvcHBlclNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBsb2FkQmFzZTY0SW1hZ2UoaW1hZ2VCYXNlNjQsIGNyb3BwZXJTZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlc29sdmVcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWplY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2Uub25sb2FkID0gKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbWFnZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEJhc2U2NDogaW1hZ2VCYXNlNjRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2Uuc3JjID0gaW1hZ2VCYXNlNjQ7XG4gICAgICAgIH0pKS50aGVuKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZXMpID0+IHRoaXMudHJhbnNmb3JtSW1hZ2VCYXNlNjQocmVzLCBjcm9wcGVyU2V0dGluZ3MpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSByZXNcbiAgICAgKiBAcGFyYW0gez99IGNyb3BwZXJTZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgdHJhbnNmb3JtSW1hZ2VCYXNlNjQocmVzLCBjcm9wcGVyU2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgYXV0b1JvdGF0ZSA9IHlpZWxkIHRoaXMuYXV0b1JvdGF0ZVN1cHBvcnRlZDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGV4aWZUcmFuc2Zvcm0gPSB5aWVsZCBnZXRUcmFuc2Zvcm1hdGlvbnNGcm9tRXhpZkRhdGEoYXV0b1JvdGF0ZSA/IC0xIDogcmVzLm9yaWdpbmFsQmFzZTY0KTtcbiAgICAgICAgICAgIGlmICghcmVzLm9yaWdpbmFsSW1hZ2UgfHwgIXJlcy5vcmlnaW5hbEltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gaW1hZ2UgbG9hZGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgbG9hZGVkSW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiByZXMub3JpZ2luYWxCYXNlNjQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiByZXMub3JpZ2luYWxJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlcy5vcmlnaW5hbEltYWdlLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVzLm9yaWdpbmFsSW1hZ2UubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGlmVHJhbnNmb3JtXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTG9hZGVkSW1hZ2UobG9hZGVkSW1hZ2UsIGNyb3BwZXJTZXR0aW5ncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyU2V0dGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybUxvYWRlZEltYWdlKGxvYWRlZEltYWdlLCBjcm9wcGVyU2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgY2FudmFzUm90YXRpb24gPSBjcm9wcGVyU2V0dGluZ3MuY2FudmFzUm90YXRpb24gKyBsb2FkZWRJbWFnZS5leGlmVHJhbnNmb3JtLnJvdGF0ZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbG9hZGVkSW1hZ2Uub3JpZ2luYWwuaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbG9hZGVkSW1hZ2Uub3JpZ2luYWwuaW1hZ2UubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjYW52YXNSb3RhdGlvbiA9PT0gMCAmJiAhbG9hZGVkSW1hZ2UuZXhpZlRyYW5zZm9ybS5mbGlwICYmICFjcm9wcGVyU2V0dGluZ3MuY29udGFpbldpdGhpbkFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NDogbG9hZGVkSW1hZ2Uub3JpZ2luYWwuYmFzZTY0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGxvYWRlZEltYWdlLm9yaWdpbmFsLmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxTaXplKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiBsb2FkZWRJbWFnZS5vcmlnaW5hbC5iYXNlNjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogbG9hZGVkSW1hZ2Uub3JpZ2luYWwuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbFNpemUpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4aWZUcmFuc2Zvcm06IGxvYWRlZEltYWdlLmV4aWZUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTaXplID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFNpemUob3JpZ2luYWxTaXplLCBsb2FkZWRJbWFnZS5leGlmVHJhbnNmb3JtLCBjcm9wcGVyU2V0dGluZ3MpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB0cmFuc2Zvcm1lZFNpemUud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdHJhbnNmb3JtZWRTaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShsb2FkZWRJbWFnZS5leGlmVHJhbnNmb3JtLmZsaXAgPyAtMSA6IDEsIDAsIDAsIDEsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAqIChjYW52YXNSb3RhdGlvbiAvIDIpKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobG9hZGVkSW1hZ2Uub3JpZ2luYWwuaW1hZ2UsIC1vcmlnaW5hbFNpemUud2lkdGggLyAyLCAtb3JpZ2luYWxTaXplLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRCYXNlNjQgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEltYWdlID0geWllbGQgdGhpcy5sb2FkSW1hZ2VGcm9tQmFzZTY0KHRyYW5zZm9ybWVkQmFzZTY0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiBsb2FkZWRJbWFnZS5vcmlnaW5hbC5iYXNlNjQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBsb2FkZWRJbWFnZS5vcmlnaW5hbC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxTaXplKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiB0cmFuc2Zvcm1lZEJhc2U2NCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHRyYW5zZm9ybWVkSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cmFuc2Zvcm1lZEltYWdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0cmFuc2Zvcm1lZEltYWdlLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGlmVHJhbnNmb3JtOiBsb2FkZWRJbWFnZS5leGlmVHJhbnNmb3JtXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGltYWdlQmFzZTY0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VGcm9tQmFzZTY0KGltYWdlQmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlc29sdmVcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWplY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoKSA9PiByZXNvbHZlKGltYWdlKSk7XG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VCYXNlNjQ7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbFNpemVcbiAgICAgKiBAcGFyYW0gez99IGV4aWZUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gez99IGNyb3BwZXJTZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0VHJhbnNmb3JtZWRTaXplKG9yaWdpbmFsU2l6ZSwgZXhpZlRyYW5zZm9ybSwgY3JvcHBlclNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY2FudmFzUm90YXRpb24gPSBjcm9wcGVyU2V0dGluZ3MuY2FudmFzUm90YXRpb24gKyBleGlmVHJhbnNmb3JtLnJvdGF0ZTtcbiAgICAgICAgaWYgKGNyb3BwZXJTZXR0aW5ncy5jb250YWluV2l0aGluQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChjYW52YXNSb3RhdGlvbiAlIDIpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgbWluV2lkdGhUb0NvbnRhaW4gPSBvcmlnaW5hbFNpemUud2lkdGggKiBjcm9wcGVyU2V0dGluZ3MuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkhlaWdodFRvQ29udGFpbiA9IG9yaWdpbmFsU2l6ZS5oZWlnaHQgLyBjcm9wcGVyU2V0dGluZ3MuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KG9yaWdpbmFsU2l6ZS5oZWlnaHQsIG1pbldpZHRoVG9Db250YWluKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChvcmlnaW5hbFNpemUud2lkdGgsIG1pbkhlaWdodFRvQ29udGFpbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbldpZHRoVG9Db250YWluID0gb3JpZ2luYWxTaXplLmhlaWdodCAqIGNyb3BwZXJTZXR0aW5ncy5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgbWluSGVpZ2h0VG9Db250YWluID0gb3JpZ2luYWxTaXplLndpZHRoIC8gY3JvcHBlclNldHRpbmdzLmFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heChvcmlnaW5hbFNpemUud2lkdGgsIG1pbldpZHRoVG9Db250YWluKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChvcmlnaW5hbFNpemUuaGVpZ2h0LCBtaW5IZWlnaHRUb0NvbnRhaW4pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FudmFzUm90YXRpb24gJSAyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogb3JpZ2luYWxTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBvcmlnaW5hbFNpemUuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogb3JpZ2luYWxTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcmlnaW5hbFNpemUuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxufVxuTG9hZEltYWdlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH0sXSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovIExvYWRJbWFnZVNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gaTAuybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBMb2FkSW1hZ2VTZXJ2aWNlX0ZhY3RvcnkoKSB7IHJldHVybiBuZXcgTG9hZEltYWdlU2VydmljZSgpOyB9LCB0b2tlbjogTG9hZEltYWdlU2VydmljZSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExvYWRJbWFnZVNlcnZpY2UucHJvdG90eXBlLmF1dG9Sb3RhdGVTdXBwb3J0ZWQ7XG59XG4iXX0=