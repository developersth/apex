/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/crop.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { resizeCanvas } from '../utils/resize.utils';
import * as i0 from "@angular/core";
import * as ɵngcc0 from '@angular/core';
export class CropService {
    /**
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    crop(sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        const imagePosition = this.getImagePosition(sourceImage, loadedImage, cropper, settings);
        /** @type {?} */
        const width = imagePosition.x2 - imagePosition.x1;
        /** @type {?} */
        const height = imagePosition.y2 - imagePosition.y1;
        /** @type {?} */
        const cropCanvas = (/** @type {?} */ (document.createElement('canvas')));
        cropCanvas.width = width;
        cropCanvas.height = height;
        /** @type {?} */
        const ctx = cropCanvas.getContext('2d');
        if (!ctx) {
            return;
        }
        if (settings.backgroundColor != null) {
            ctx.fillStyle = settings.backgroundColor;
            ctx.fillRect(0, 0, width, height);
        }
        /** @type {?} */
        const scaleX = (settings.transform.scale || 1) * (settings.transform.flipH ? -1 : 1);
        /** @type {?} */
        const scaleY = (settings.transform.scale || 1) * (settings.transform.flipV ? -1 : 1);
        /** @type {?} */
        const transformedImage = loadedImage.transformed;
        ctx.setTransform(scaleX, 0, 0, scaleY, transformedImage.size.width / 2, transformedImage.size.height / 2);
        ctx.translate(-imagePosition.x1 / scaleX, -imagePosition.y1 / scaleY);
        ctx.rotate((settings.transform.rotate || 0) * Math.PI / 180);
        ctx.drawImage(transformedImage.image, -transformedImage.size.width / 2, -transformedImage.size.height / 2);
        /** @type {?} */
        const output = {
            width, height,
            imagePosition,
            cropperPosition: Object.assign({}, cropper)
        };
        if (settings.containWithinAspectRatio) {
            output.offsetImagePosition = this.getOffsetImagePosition(sourceImage, loadedImage, cropper, settings);
        }
        /** @type {?} */
        const resizeRatio = this.getResizeRatio(width, height, settings);
        if (resizeRatio !== 1) {
            output.width = Math.round(width * resizeRatio);
            output.height = settings.maintainAspectRatio
                ? Math.round(output.width / settings.aspectRatio)
                : Math.round(height * resizeRatio);
            resizeCanvas(cropCanvas, output.width, output.height);
        }
        output.base64 = cropCanvas.toDataURL('image/' + settings.format, this.getQuality(settings));
        return output;
    }
    /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    getImagePosition(sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        const sourceImageElement = sourceImage.nativeElement;
        /** @type {?} */
        const ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;
        /** @type {?} */
        const out = {
            x1: Math.round(cropper.x1 * ratio),
            y1: Math.round(cropper.y1 * ratio),
            x2: Math.round(cropper.x2 * ratio),
            y2: Math.round(cropper.y2 * ratio)
        };
        if (!settings.containWithinAspectRatio) {
            out.x1 = Math.max(out.x1, 0);
            out.y1 = Math.max(out.y1, 0);
            out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);
            out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);
        }
        return out;
    }
    /**
     * @private
     * @param {?} sourceImage
     * @param {?} loadedImage
     * @param {?} cropper
     * @param {?} settings
     * @return {?}
     */
    getOffsetImagePosition(sourceImage, loadedImage, cropper, settings) {
        /** @type {?} */
        const canvasRotation = settings.canvasRotation + loadedImage.exifTransform.rotate;
        /** @type {?} */
        const sourceImageElement = sourceImage.nativeElement;
        /** @type {?} */
        const ratio = loadedImage.transformed.size.width / sourceImageElement.offsetWidth;
        /** @type {?} */
        let offsetX;
        /** @type {?} */
        let offsetY;
        if (canvasRotation % 2) {
            offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.height) / 2;
            offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.width) / 2;
        }
        else {
            offsetX = (loadedImage.transformed.size.width - loadedImage.original.size.width) / 2;
            offsetY = (loadedImage.transformed.size.height - loadedImage.original.size.height) / 2;
        }
        /** @type {?} */
        const out = {
            x1: Math.round(cropper.x1 * ratio) - offsetX,
            y1: Math.round(cropper.y1 * ratio) - offsetY,
            x2: Math.round(cropper.x2 * ratio) - offsetX,
            y2: Math.round(cropper.y2 * ratio) - offsetY
        };
        if (!settings.containWithinAspectRatio) {
            out.x1 = Math.max(out.x1, 0);
            out.y1 = Math.max(out.y1, 0);
            out.x2 = Math.min(out.x2, loadedImage.transformed.size.width);
            out.y2 = Math.min(out.y2, loadedImage.transformed.size.height);
        }
        return out;
    }
    /**
     * @param {?} width
     * @param {?} height
     * @param {?} settings
     * @return {?}
     */
    getResizeRatio(width, height, settings) {
        /** @type {?} */
        const ratioWidth = settings.resizeToWidth / width;
        /** @type {?} */
        const ratioHeight = settings.resizeToHeight / height;
        /** @type {?} */
        const ratios = new Array();
        if (settings.resizeToWidth > 0) {
            ratios.push(ratioWidth);
        }
        if (settings.resizeToHeight > 0) {
            ratios.push(ratioHeight);
        }
        /** @type {?} */
        const result = ratios.length === 0 ? 1 : Math.min(...ratios);
        if (result > 1 && !settings.onlyScaleDown) {
            return result;
        }
        return Math.min(result, 1);
    }
    /**
     * @param {?} settings
     * @return {?}
     */
    getQuality(settings) {
        return Math.min(1, Math.max(0, settings.imageQuality / 100));
    }
}
CropService.ɵfac = function CropService_Factory(t) { return new (t || CropService)(); };
CropService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CropService, factory: CropService.ɵfac, providedIn: 'root' });
/** @nocollapse */ CropService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function CropService_Factory() { return new CropService(); }, token: CropService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CropService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmd4LWltYWdlLWNyb3BwZXIvZXNtMjAxNS9saWIvc2VydmljZXMvY3JvcC5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrS0Msb0hBR0M7Ozs7OzBCQUN3TCIsImZpbGUiOiJjcm9wLnNlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IGxpYi9zZXJ2aWNlcy9jcm9wLnNlcnZpY2UudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgcmVzaXplQ2FudmFzIH0gZnJvbSAnLi4vdXRpbHMvcmVzaXplLnV0aWxzJztcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5leHBvcnQgY2xhc3MgQ3JvcFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgY3JvcChzb3VyY2VJbWFnZSwgbG9hZGVkSW1hZ2UsIGNyb3BwZXIsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgaW1hZ2VQb3NpdGlvbiA9IHRoaXMuZ2V0SW1hZ2VQb3NpdGlvbihzb3VyY2VJbWFnZSwgbG9hZGVkSW1hZ2UsIGNyb3BwZXIsIHNldHRpbmdzKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlUG9zaXRpb24ueDIgLSBpbWFnZVBvc2l0aW9uLngxO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlUG9zaXRpb24ueTIgLSBpbWFnZVBvc2l0aW9uLnkxO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGNyb3BDYW52YXMgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpKTtcbiAgICAgICAgY3JvcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjcm9wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBjdHggPSBjcm9wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmJhY2tncm91bmRDb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2NhbGVYID0gKHNldHRpbmdzLnRyYW5zZm9ybS5zY2FsZSB8fCAxKSAqIChzZXR0aW5ncy50cmFuc2Zvcm0uZmxpcEggPyAtMSA6IDEpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IChzZXR0aW5ncy50cmFuc2Zvcm0uc2NhbGUgfHwgMSkgKiAoc2V0dGluZ3MudHJhbnNmb3JtLmZsaXBWID8gLTEgOiAxKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEltYWdlID0gbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQ7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCBzY2FsZVksIHRyYW5zZm9ybWVkSW1hZ2Uuc2l6ZS53aWR0aCAvIDIsIHRyYW5zZm9ybWVkSW1hZ2Uuc2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtaW1hZ2VQb3NpdGlvbi54MSAvIHNjYWxlWCwgLWltYWdlUG9zaXRpb24ueTEgLyBzY2FsZVkpO1xuICAgICAgICBjdHgucm90YXRlKChzZXR0aW5ncy50cmFuc2Zvcm0ucm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodHJhbnNmb3JtZWRJbWFnZS5pbWFnZSwgLXRyYW5zZm9ybWVkSW1hZ2Uuc2l6ZS53aWR0aCAvIDIsIC10cmFuc2Zvcm1lZEltYWdlLnNpemUuaGVpZ2h0IC8gMik7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgIGltYWdlUG9zaXRpb24sXG4gICAgICAgICAgICBjcm9wcGVyUG9zaXRpb246IE9iamVjdC5hc3NpZ24oe30sIGNyb3BwZXIpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb250YWluV2l0aGluQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIG91dHB1dC5vZmZzZXRJbWFnZVBvc2l0aW9uID0gdGhpcy5nZXRPZmZzZXRJbWFnZVBvc2l0aW9uKHNvdXJjZUltYWdlLCBsb2FkZWRJbWFnZSwgY3JvcHBlciwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcmVzaXplUmF0aW8gPSB0aGlzLmdldFJlc2l6ZVJhdGlvKHdpZHRoLCBoZWlnaHQsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKHJlc2l6ZVJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBvdXRwdXQud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogcmVzaXplUmF0aW8pO1xuICAgICAgICAgICAgb3V0cHV0LmhlaWdodCA9IHNldHRpbmdzLm1haW50YWluQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICA/IE1hdGgucm91bmQob3V0cHV0LndpZHRoIC8gc2V0dGluZ3MuYXNwZWN0UmF0aW8pXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKGhlaWdodCAqIHJlc2l6ZVJhdGlvKTtcbiAgICAgICAgICAgIHJlc2l6ZUNhbnZhcyhjcm9wQ2FudmFzLCBvdXRwdXQud2lkdGgsIG91dHB1dC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5iYXNlNjQgPSBjcm9wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvJyArIHNldHRpbmdzLmZvcm1hdCwgdGhpcy5nZXRRdWFsaXR5KHNldHRpbmdzKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VJbWFnZVxuICAgICAqIEBwYXJhbSB7P30gbG9hZGVkSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGNyb3BwZXJcbiAgICAgKiBAcGFyYW0gez99IHNldHRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRJbWFnZVBvc2l0aW9uKHNvdXJjZUltYWdlLCBsb2FkZWRJbWFnZSwgY3JvcHBlciwgc2V0dGluZ3MpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzb3VyY2VJbWFnZUVsZW1lbnQgPSBzb3VyY2VJbWFnZS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHJhdGlvID0gbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCAvIHNvdXJjZUltYWdlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBvdXQgPSB7XG4gICAgICAgICAgICB4MTogTWF0aC5yb3VuZChjcm9wcGVyLngxICogcmF0aW8pLFxuICAgICAgICAgICAgeTE6IE1hdGgucm91bmQoY3JvcHBlci55MSAqIHJhdGlvKSxcbiAgICAgICAgICAgIHgyOiBNYXRoLnJvdW5kKGNyb3BwZXIueDIgKiByYXRpbyksXG4gICAgICAgICAgICB5MjogTWF0aC5yb3VuZChjcm9wcGVyLnkyICogcmF0aW8pXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc2V0dGluZ3MuY29udGFpbldpdGhpbkFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBvdXQueDEgPSBNYXRoLm1heChvdXQueDEsIDApO1xuICAgICAgICAgICAgb3V0LnkxID0gTWF0aC5tYXgob3V0LnkxLCAwKTtcbiAgICAgICAgICAgIG91dC54MiA9IE1hdGgubWluKG91dC54MiwgbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICBvdXQueTIgPSBNYXRoLm1pbihvdXQueTIsIGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlSW1hZ2VcbiAgICAgKiBAcGFyYW0gez99IGxvYWRlZEltYWdlXG4gICAgICogQHBhcmFtIHs/fSBjcm9wcGVyXG4gICAgICogQHBhcmFtIHs/fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0T2Zmc2V0SW1hZ2VQb3NpdGlvbihzb3VyY2VJbWFnZSwgbG9hZGVkSW1hZ2UsIGNyb3BwZXIsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY2FudmFzUm90YXRpb24gPSBzZXR0aW5ncy5jYW52YXNSb3RhdGlvbiArIGxvYWRlZEltYWdlLmV4aWZUcmFuc2Zvcm0ucm90YXRlO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHNvdXJjZUltYWdlRWxlbWVudCA9IHNvdXJjZUltYWdlLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcmF0aW8gPSBsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLndpZHRoIC8gc291cmNlSW1hZ2VFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBvZmZzZXRYO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBvZmZzZXRZO1xuICAgICAgICBpZiAoY2FudmFzUm90YXRpb24gJSAyKSB7XG4gICAgICAgICAgICBvZmZzZXRYID0gKGxvYWRlZEltYWdlLnRyYW5zZm9ybWVkLnNpemUud2lkdGggLSBsb2FkZWRJbWFnZS5vcmlnaW5hbC5zaXplLmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgb2Zmc2V0WSA9IChsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLmhlaWdodCAtIGxvYWRlZEltYWdlLm9yaWdpbmFsLnNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldFggPSAobG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS53aWR0aCAtIGxvYWRlZEltYWdlLm9yaWdpbmFsLnNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIG9mZnNldFkgPSAobG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS5oZWlnaHQgLSBsb2FkZWRJbWFnZS5vcmlnaW5hbC5zaXplLmhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgICAgeDE6IE1hdGgucm91bmQoY3JvcHBlci54MSAqIHJhdGlvKSAtIG9mZnNldFgsXG4gICAgICAgICAgICB5MTogTWF0aC5yb3VuZChjcm9wcGVyLnkxICogcmF0aW8pIC0gb2Zmc2V0WSxcbiAgICAgICAgICAgIHgyOiBNYXRoLnJvdW5kKGNyb3BwZXIueDIgKiByYXRpbykgLSBvZmZzZXRYLFxuICAgICAgICAgICAgeTI6IE1hdGgucm91bmQoY3JvcHBlci55MiAqIHJhdGlvKSAtIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5jb250YWluV2l0aGluQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIG91dC54MSA9IE1hdGgubWF4KG91dC54MSwgMCk7XG4gICAgICAgICAgICBvdXQueTEgPSBNYXRoLm1heChvdXQueTEsIDApO1xuICAgICAgICAgICAgb3V0LngyID0gTWF0aC5taW4ob3V0LngyLCBsb2FkZWRJbWFnZS50cmFuc2Zvcm1lZC5zaXplLndpZHRoKTtcbiAgICAgICAgICAgIG91dC55MiA9IE1hdGgubWluKG91dC55MiwgbG9hZGVkSW1hZ2UudHJhbnNmb3JtZWQuc2l6ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gd2lkdGhcbiAgICAgKiBAcGFyYW0gez99IGhlaWdodFxuICAgICAqIEBwYXJhbSB7P30gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldFJlc2l6ZVJhdGlvKHdpZHRoLCBoZWlnaHQsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcmF0aW9XaWR0aCA9IHNldHRpbmdzLnJlc2l6ZVRvV2lkdGggLyB3aWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCByYXRpb0hlaWdodCA9IHNldHRpbmdzLnJlc2l6ZVRvSGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHJhdGlvcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBpZiAoc2V0dGluZ3MucmVzaXplVG9XaWR0aCA+IDApIHtcbiAgICAgICAgICAgIHJhdGlvcy5wdXNoKHJhdGlvV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZXNpemVUb0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgIHJhdGlvcy5wdXNoKHJhdGlvSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJhdGlvcy5sZW5ndGggPT09IDAgPyAxIDogTWF0aC5taW4oLi4ucmF0aW9zKTtcbiAgICAgICAgaWYgKHJlc3VsdCA+IDEgJiYgIXNldHRpbmdzLm9ubHlTY2FsZURvd24pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJlc3VsdCwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldFF1YWxpdHkoc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHNldHRpbmdzLmltYWdlUXVhbGl0eSAvIDEwMCkpO1xuICAgIH1cbn1cbkNyb3BTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi8gQ3JvcFNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gaTAuybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBDcm9wU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IENyb3BTZXJ2aWNlKCk7IH0sIHRva2VuOiBDcm9wU2VydmljZSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4iXX0=