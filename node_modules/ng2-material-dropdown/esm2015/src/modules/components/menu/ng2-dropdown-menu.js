import * as tslib_1 from "tslib";
import { Component, ElementRef, Renderer2, ContentChildren, QueryList, Input } from '@angular/core';
import { trigger, style, transition, animate, keyframes, state } from '@angular/animations';
import { ACTIONS, arrowKeysHandler } from './actions';
import { Ng2MenuItem } from '../menu-item/ng2-menu-item';
import { DropdownStateService } from '../../services/dropdown-state.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function Ng2DropdownMenu_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r99 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵlistener("click", function Ng2DropdownMenu_div_3_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r99); const ctx_r98 = ɵngcc0.ɵɵnextContext(); return ctx_r98.hide(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c0 = ["*"];
let Ng2DropdownMenu = class Ng2DropdownMenu {
    constructor(dropdownState, element, renderer) {
        this.dropdownState = dropdownState;
        this.element = element;
        this.renderer = renderer;
        /**
         * @name width
         */
        this.width = 4;
        /**
         * @description if set to true, the first element of the dropdown will be automatically focused
         * @name focusFirstElement
         */
        this.focusFirstElement = true;
        /**
         * @name appendToBody
         */
        this.appendToBody = true;
        /**
         * @name zIndex
         */
        this.zIndex = 1000;
        this.listeners = {
            arrowHandler: undefined,
            handleKeypress: undefined
        };
    }
    /**
     * @name show
     * @shows menu and selects first item
     */
    show(position, dynamic = true) {
        const dc = typeof document !== 'undefined' ? document : undefined;
        const wd = typeof window !== 'undefined' ? window : undefined;
        if (!this.dropdownState.menuState.isVisible) {
            // setting handlers
            this.listeners.handleKeypress = this.renderer.listen(dc.body, 'keydown', this.handleKeypress.bind(this));
            this.listeners.arrowHandler = this.renderer.listen(wd, 'keydown', arrowKeysHandler);
        }
        // update state
        this.dropdownState.menuState.isVisible = true;
        if (position) {
            this.updatePosition(position, dynamic);
        }
    }
    /**
     * @name hide
     * @desc hides menu
     */
    hide() {
        this.dropdownState.menuState.isVisible = false;
        // reset selected item state
        this.dropdownState.dropdownState.unselect();
        // call function to unlisten
        this.listeners.arrowHandler && this.listeners.arrowHandler();
        this.listeners.handleKeypress && this.listeners.handleKeypress();
    }
    /**
     * @name updatePosition
     * @desc updates the menu position every time it is toggled
     * @param position {ClientRect}
     * @param dynamic {boolean}
     */
    updatePosition(position, dynamic) {
        this.position = position;
        this.updateOnChange(dynamic);
    }
    /**
     * @name handleKeypress
     * @desc executes functions on keyPress based on the key pressed
     * @param $event
     */
    handleKeypress($event) {
        const key = $event.keyCode;
        const items = this.items.toArray();
        const index = items.indexOf(this.dropdownState.dropdownState.selectedItem);
        if (!ACTIONS.hasOwnProperty(key)) {
            return;
        }
        ACTIONS[key].call(this, index, items, this.dropdownState.dropdownState);
    }
    /**
     * @name getMenuElement
     */
    getMenuElement() {
        return this.element.nativeElement.children[0];
    }
    /**
     * @name calcPositionOffset
     * @param position
     */
    calcPositionOffset(position) {
        const wd = typeof window !== 'undefined' ? window : undefined;
        const dc = typeof document !== 'undefined' ? document : undefined;
        if (!wd || !dc || !position) {
            return;
        }
        const element = this.getMenuElement();
        const supportPageOffset = wd.pageXOffset !== undefined;
        const isCSS1Compat = (dc.compatMode || '') === 'CSS1Compat';
        const x = supportPageOffset
            ? wd.pageXOffset
            : isCSS1Compat
                ? dc.documentElement.scrollLeft
                : dc.body.scrollLeft;
        const y = supportPageOffset
            ? wd.pageYOffset
            : isCSS1Compat
                ? dc.documentElement.scrollTop
                : dc.body.scrollTop;
        let { top, left } = this.applyOffset(`${position.top + (this.appendToBody ? y - 15 : 0)}px`, `${position.left + x - 5}px`);
        const clientWidth = element.clientWidth;
        const clientHeight = element.clientHeight;
        const marginFromBottom = parseInt(top) + clientHeight + (this.appendToBody ? 0 : y - 15);
        const marginFromRight = parseInt(left) + clientWidth;
        const windowScrollHeight = wd.innerHeight + wd.scrollY;
        const windowScrollWidth = wd.innerWidth + wd.scrollX;
        if (marginFromBottom >= windowScrollHeight) {
            top = `${parseInt(top.replace('px', '')) - clientHeight}px`;
        }
        if (marginFromRight >= windowScrollWidth) {
            const marginRight = marginFromRight - windowScrollWidth + 30;
            left = `${parseInt(left.replace('px', '')) - marginRight}px`;
        }
        return { top, left };
    }
    applyOffset(top, left) {
        if (!this.offset) {
            return { top, left };
        }
        const offset = this.offset.split(' ');
        if (!offset[1]) {
            offset[1] = '0';
        }
        top = `${parseInt(top.replace('px', '')) + parseInt(offset[0])}px`;
        left = `${parseInt(left.replace('px', '')) + parseInt(offset[1])}px`;
        return { top, left };
    }
    ngOnInit() {
        const dc = typeof document !== 'undefined' ? document : undefined;
        if (this.appendToBody) {
            // append menu element to the body
            dc.body.appendChild(this.element.nativeElement);
        }
    }
    updateOnChange(dynamic = true) {
        const element = this.getMenuElement();
        const position = this.calcPositionOffset(this.position);
        if (position) {
            this.renderer.setStyle(element, 'top', position.top.toString());
            this.renderer.setStyle(element, 'left', position.left.toString());
        }
        // select first item unless user disabled this option
        if (this.focusFirstElement &&
            this.items.first &&
            !this.dropdownState.dropdownState.selectedItem) {
            this.dropdownState.dropdownState.select(this.items.first, false);
        }
    }
    ngOnDestroy() {
        const elem = this.element.nativeElement;
        elem.parentNode.removeChild(elem);
        if (this.listeners.handleKeypress) {
            this.listeners.handleKeypress();
        }
    }
};
Ng2DropdownMenu.ɵfac = function Ng2DropdownMenu_Factory(t) { return new (t || Ng2DropdownMenu)(ɵngcc0.ɵɵdirectiveInject(DropdownStateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
Ng2DropdownMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Ng2DropdownMenu, selectors: [["ng2-dropdown-menu"]], contentQueries: function Ng2DropdownMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, Ng2MenuItem, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { width: "width", focusFirstElement: "focusFirstElement", appendToBody: "appendToBody", zIndex: "zIndex", offset: "offset" }, ngContentSelectors: _c0, decls: 4, vars: 12, consts: [[1, "ng2-dropdown-menu__options-container"], ["class", "ng2-dropdown-backdrop", 3, "click", 4, "ngIf"], [1, "ng2-dropdown-backdrop", 3, "click"]], template: function Ng2DropdownMenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, Ng2DropdownMenu_div_3_Template, 1, 0, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("ng2-dropdown-menu ng2-dropdown-menu---width--", ctx.width, "");
        ɵngcc0.ɵɵstyleProp("z-index", ctx.zIndex);
        ɵngcc0.ɵɵclassProp("ng2-dropdown-menu--inside-element", !ctx.appendToBody)("ng2-dropdown-menu--open", ctx.dropdownState.menuState.isVisible);
        ɵngcc0.ɵɵproperty("@fade", ctx.dropdownState.menuState.toString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@opacity", ctx.dropdownState.menuState.toString());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dropdownState.menuState.isVisible);
    } }, directives: [ɵngcc1.NgIf], styles: ["[_nghost-%COMP%]{display:block}.ng2-dropdown-menu[_ngcontent-%COMP%]{overflow-y:auto;box-shadow:0 1px 2px 0 rgba(0,0,0,.3);position:absolute;padding:.5em 0;background:#fff;border-radius:1px;max-height:400px;width:260px;min-height:0;display:block}.ng2-dropdown-menu.ng2-dropdown-menu--inside-element[_ngcontent-%COMP%]{position:fixed}.ng2-dropdown-menu.ng2-dropdown-menu--width--2[_ngcontent-%COMP%]{width:200px}.ng2-dropdown-menu.ng2-dropdown-menu--width--4[_ngcontent-%COMP%]{width:260px}.ng2-dropdown-menu.ng2-dropdown-menu--width--6[_ngcontent-%COMP%]{width:320px}.ng2-dropdown-backdrop[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1;overflow:hidden}[_nghost-%COMP%]     .ng2-menu-divider{height:1px;min-height:1px;max-height:1px;width:100%;display:block;background:#f9f9f9}"], data: { animation: [
            trigger('fade', [
                state('visible', style({ opacity: 1, height: '*', width: '*' })),
                state('hidden', style({ opacity: 0, overflow: 'hidden', height: 0, width: 0 })),
                transition('hidden => visible', [
                    animate('250ms ease-in', style({ opacity: 1, height: '*', width: '*' }))
                ]),
                transition('visible => hidden', [
                    animate('350ms ease-out', style({ opacity: 0, width: 0, height: 0 }))
                ])
            ]),
            trigger('opacity', [
                transition('hidden => visible', [
                    animate('450ms ease-in', keyframes([
                        style({ opacity: 0, offset: 0 }),
                        style({ opacity: 1, offset: 1 })
                    ]))
                ]),
                transition('visible => hidden', [
                    animate('250ms ease-out', keyframes([
                        style({ opacity: 1, offset: 0 }),
                        style({ opacity: 0.5, offset: 0.3 }),
                        style({ opacity: 0, offset: 1 })
                    ]))
                ])
            ])
        ] } });
Ng2DropdownMenu.ctorParameters = () => [
    { type: DropdownStateService },
    { type: ElementRef },
    { type: Renderer2 }
];
tslib_1.__decorate([
    Input()
], Ng2DropdownMenu.prototype, "width", void 0);
tslib_1.__decorate([
    Input()
], Ng2DropdownMenu.prototype, "focusFirstElement", void 0);
tslib_1.__decorate([
    Input()
], Ng2DropdownMenu.prototype, "offset", void 0);
tslib_1.__decorate([
    Input()
], Ng2DropdownMenu.prototype, "appendToBody", void 0);
tslib_1.__decorate([
    Input()
], Ng2DropdownMenu.prototype, "zIndex", void 0);
tslib_1.__decorate([
    ContentChildren(Ng2MenuItem, { descendants: true })
], Ng2DropdownMenu.prototype, "items", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Ng2DropdownMenu, [{
        type: Component,
        args: [{
                selector: 'ng2-dropdown-menu',
                template: `
        <!-- MENU -->
        <div
            class="ng2-dropdown-menu ng2-dropdown-menu---width--{{ width }}"
            [class.ng2-dropdown-menu--inside-element]="!appendToBody"
            [class.ng2-dropdown-menu--open]="dropdownState.menuState.isVisible"
            [style.z-index]="zIndex"
            [@fade]="dropdownState.menuState.toString()"
        >
            <div
                class="ng2-dropdown-menu__options-container"
                [@opacity]="dropdownState.menuState.toString()"
            >
                <ng-content></ng-content>
            </div>
        </div>

        <!-- BACKDROP -->
        <div
            class="ng2-dropdown-backdrop"
            *ngIf="dropdownState.menuState.isVisible"
            (click)="hide()"
        ></div>
    `,
                animations: [
                    trigger('fade', [
                        state('visible', style({ opacity: 1, height: '*', width: '*' })),
                        state('hidden', style({ opacity: 0, overflow: 'hidden', height: 0, width: 0 })),
                        transition('hidden => visible', [
                            animate('250ms ease-in', style({ opacity: 1, height: '*', width: '*' }))
                        ]),
                        transition('visible => hidden', [
                            animate('350ms ease-out', style({ opacity: 0, width: 0, height: 0 }))
                        ])
                    ]),
                    trigger('opacity', [
                        transition('hidden => visible', [
                            animate('450ms ease-in', keyframes([
                                style({ opacity: 0, offset: 0 }),
                                style({ opacity: 1, offset: 1 })
                            ]))
                        ]),
                        transition('visible => hidden', [
                            animate('250ms ease-out', keyframes([
                                style({ opacity: 1, offset: 0 }),
                                style({ opacity: 0.5, offset: 0.3 }),
                                style({ opacity: 0, offset: 1 })
                            ]))
                        ])
                    ])
                ],
                styles: [":host{display:block}.ng2-dropdown-menu{overflow-y:auto;box-shadow:0 1px 2px 0 rgba(0,0,0,.3);position:absolute;padding:.5em 0;background:#fff;border-radius:1px;max-height:400px;width:260px;min-height:0;display:block}.ng2-dropdown-menu.ng2-dropdown-menu--inside-element{position:fixed}.ng2-dropdown-menu.ng2-dropdown-menu--width--2{width:200px}.ng2-dropdown-menu.ng2-dropdown-menu--width--4{width:260px}.ng2-dropdown-menu.ng2-dropdown-menu--width--6{width:320px}.ng2-dropdown-backdrop{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1;overflow:hidden}:host ::ng-deep .ng2-menu-divider{height:1px;min-height:1px;max-height:1px;width:100%;display:block;background:#f9f9f9}"]
            }]
    }], function () { return [{ type: DropdownStateService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { width: [{
            type: Input
        }], focusFirstElement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], offset: [{
            type: Input
        }], items: [{
            type: ContentChildren,
            args: [Ng2MenuItem, { descendants: true }]
        }] }); })();
export { Ng2DropdownMenu };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvbmcyLW1hdGVyaWFsLWRyb3Bkb3duL2VzbTIwMTUvc3JjL21vZHVsZXMvY29tcG9uZW50cy9tZW51L25nMi1kcm9wZG93bi1tZW51LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQXNLRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0NBdUI2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBeUQzQiIsImZpbGUiOiJuZzItZHJvcGRvd24tbWVudS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3QsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdHlsZSwgdHJhbnNpdGlvbiwgYW5pbWF0ZSwga2V5ZnJhbWVzLCBzdGF0ZSB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQUNUSU9OUywgYXJyb3dLZXlzSGFuZGxlciB9IGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgeyBOZzJNZW51SXRlbSB9IGZyb20gJy4uL21lbnUtaXRlbS9uZzItbWVudS1pdGVtJztcbmltcG9ydCB7IERyb3Bkb3duU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZHJvcGRvd24tc3RhdGUuc2VydmljZSc7XG5sZXQgTmcyRHJvcGRvd25NZW51ID0gY2xhc3MgTmcyRHJvcGRvd25NZW51IHtcbiAgICBjb25zdHJ1Y3Rvcihkcm9wZG93blN0YXRlLCBlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmRyb3Bkb3duU3RhdGUgPSBkcm9wZG93blN0YXRlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IDQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBkcm9wZG93biB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZm9jdXNlZFxuICAgICAgICAgKiBAbmFtZSBmb2N1c0ZpcnN0RWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c0ZpcnN0RWxlbWVudCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBhcHBlbmRUb0JvZHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwZW5kVG9Cb2R5ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHpJbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56SW5kZXggPSAxMDAwO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGFycm93SGFuZGxlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGFuZGxlS2V5cHJlc3M6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzaG93XG4gICAgICogQHNob3dzIG1lbnUgYW5kIHNlbGVjdHMgZmlyc3QgaXRlbVxuICAgICAqL1xuICAgIHNob3cocG9zaXRpb24sIGR5bmFtaWMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGRjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB3ZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXRoaXMuZHJvcGRvd25TdGF0ZS5tZW51U3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5oYW5kbGVLZXlwcmVzcyA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGRjLmJvZHksICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlwcmVzcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmFycm93SGFuZGxlciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHdkLCAna2V5ZG93bicsIGFycm93S2V5c0hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgICAgICB0aGlzLmRyb3Bkb3duU3RhdGUubWVudVN0YXRlLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihwb3NpdGlvbiwgZHluYW1pYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgaGlkZVxuICAgICAqIEBkZXNjIGhpZGVzIG1lbnVcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmRyb3Bkb3duU3RhdGUubWVudVN0YXRlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyByZXNldCBzZWxlY3RlZCBpdGVtIHN0YXRlXG4gICAgICAgIHRoaXMuZHJvcGRvd25TdGF0ZS5kcm9wZG93blN0YXRlLnVuc2VsZWN0KCk7XG4gICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gdG8gdW5saXN0ZW5cbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuYXJyb3dIYW5kbGVyICYmIHRoaXMubGlzdGVuZXJzLmFycm93SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5oYW5kbGVLZXlwcmVzcyAmJiB0aGlzLmxpc3RlbmVycy5oYW5kbGVLZXlwcmVzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSB1cGRhdGVQb3NpdGlvblxuICAgICAqIEBkZXNjIHVwZGF0ZXMgdGhlIG1lbnUgcG9zaXRpb24gZXZlcnkgdGltZSBpdCBpcyB0b2dnbGVkXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHtDbGllbnRSZWN0fVxuICAgICAqIEBwYXJhbSBkeW5hbWljIHtib29sZWFufVxuICAgICAqL1xuICAgIHVwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uLCBkeW5hbWljKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGVPbkNoYW5nZShkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgaGFuZGxlS2V5cHJlc3NcbiAgICAgKiBAZGVzYyBleGVjdXRlcyBmdW5jdGlvbnMgb24ga2V5UHJlc3MgYmFzZWQgb24gdGhlIGtleSBwcmVzc2VkXG4gICAgICogQHBhcmFtICRldmVudFxuICAgICAqL1xuICAgIGhhbmRsZUtleXByZXNzKCRldmVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSAkZXZlbnQua2V5Q29kZTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtcy5pbmRleE9mKHRoaXMuZHJvcGRvd25TdGF0ZS5kcm9wZG93blN0YXRlLnNlbGVjdGVkSXRlbSk7XG4gICAgICAgIGlmICghQUNUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQUNUSU9OU1trZXldLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCB0aGlzLmRyb3Bkb3duU3RhdGUuZHJvcGRvd25TdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIGdldE1lbnVFbGVtZW50XG4gICAgICovXG4gICAgZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgY2FsY1Bvc2l0aW9uT2Zmc2V0XG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICovXG4gICAgY2FsY1Bvc2l0aW9uT2Zmc2V0KHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHdkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXdkIHx8ICFkYyB8fCAhcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRNZW51RWxlbWVudCgpO1xuICAgICAgICBjb25zdCBzdXBwb3J0UGFnZU9mZnNldCA9IHdkLnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzQ1NTMUNvbXBhdCA9IChkYy5jb21wYXRNb2RlIHx8ICcnKSA9PT0gJ0NTUzFDb21wYXQnO1xuICAgICAgICBjb25zdCB4ID0gc3VwcG9ydFBhZ2VPZmZzZXRcbiAgICAgICAgICAgID8gd2QucGFnZVhPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgICAgIDogZGMuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCB5ID0gc3VwcG9ydFBhZ2VPZmZzZXRcbiAgICAgICAgICAgID8gd2QucGFnZVlPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgOiBkYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHsgdG9wLCBsZWZ0IH0gPSB0aGlzLmFwcGx5T2Zmc2V0KGAke3Bvc2l0aW9uLnRvcCArICh0aGlzLmFwcGVuZFRvQm9keSA/IHkgLSAxNSA6IDApfXB4YCwgYCR7cG9zaXRpb24ubGVmdCArIHggLSA1fXB4YCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG1hcmdpbkZyb21Cb3R0b20gPSBwYXJzZUludCh0b3ApICsgY2xpZW50SGVpZ2h0ICsgKHRoaXMuYXBwZW5kVG9Cb2R5ID8gMCA6IHkgLSAxNSk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkZyb21SaWdodCA9IHBhcnNlSW50KGxlZnQpICsgY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHdpbmRvd1Njcm9sbEhlaWdodCA9IHdkLmlubmVySGVpZ2h0ICsgd2Quc2Nyb2xsWTtcbiAgICAgICAgY29uc3Qgd2luZG93U2Nyb2xsV2lkdGggPSB3ZC5pbm5lcldpZHRoICsgd2Quc2Nyb2xsWDtcbiAgICAgICAgaWYgKG1hcmdpbkZyb21Cb3R0b20gPj0gd2luZG93U2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSBgJHtwYXJzZUludCh0b3AucmVwbGFjZSgncHgnLCAnJykpIC0gY2xpZW50SGVpZ2h0fXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFyZ2luRnJvbVJpZ2h0ID49IHdpbmRvd1Njcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9IG1hcmdpbkZyb21SaWdodCAtIHdpbmRvd1Njcm9sbFdpZHRoICsgMzA7XG4gICAgICAgICAgICBsZWZ0ID0gYCR7cGFyc2VJbnQobGVmdC5yZXBsYWNlKCdweCcsICcnKSkgLSBtYXJnaW5SaWdodH1weGA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wLCBsZWZ0IH07XG4gICAgfVxuICAgIGFwcGx5T2Zmc2V0KHRvcCwgbGVmdCkge1xuICAgICAgICBpZiAoIXRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b3AsIGxlZnQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldC5zcGxpdCgnICcpO1xuICAgICAgICBpZiAoIW9mZnNldFsxXSkge1xuICAgICAgICAgICAgb2Zmc2V0WzFdID0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHRvcCA9IGAke3BhcnNlSW50KHRvcC5yZXBsYWNlKCdweCcsICcnKSkgKyBwYXJzZUludChvZmZzZXRbMF0pfXB4YDtcbiAgICAgICAgbGVmdCA9IGAke3BhcnNlSW50KGxlZnQucmVwbGFjZSgncHgnLCAnJykpICsgcGFyc2VJbnQob2Zmc2V0WzFdKX1weGA7XG4gICAgICAgIHJldHVybiB7IHRvcCwgbGVmdCB9O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgZGMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgLy8gYXBwZW5kIG1lbnUgZWxlbWVudCB0byB0aGUgYm9keVxuICAgICAgICAgICAgZGMuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT25DaGFuZ2UoZHluYW1pYyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0TWVudUVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNhbGNQb3NpdGlvbk9mZnNldCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICd0b3AnLCBwb3NpdGlvbi50b3AudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdsZWZ0JywgcG9zaXRpb24ubGVmdC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWxlY3QgZmlyc3QgaXRlbSB1bmxlc3MgdXNlciBkaXNhYmxlZCB0aGlzIG9wdGlvblxuICAgICAgICBpZiAodGhpcy5mb2N1c0ZpcnN0RWxlbWVudCAmJlxuICAgICAgICAgICAgdGhpcy5pdGVtcy5maXJzdCAmJlxuICAgICAgICAgICAgIXRoaXMuZHJvcGRvd25TdGF0ZS5kcm9wZG93blN0YXRlLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93blN0YXRlLmRyb3Bkb3duU3RhdGUuc2VsZWN0KHRoaXMuaXRlbXMuZmlyc3QsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYW5kbGVLZXlwcmVzcykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuaGFuZGxlS2V5cHJlc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5OZzJEcm9wZG93bk1lbnUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBEcm9wZG93blN0YXRlU2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH1cbl07XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIE5nMkRyb3Bkb3duTWVudS5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgTmcyRHJvcGRvd25NZW51LnByb3RvdHlwZSwgXCJmb2N1c0ZpcnN0RWxlbWVudFwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBOZzJEcm9wZG93bk1lbnUucHJvdG90eXBlLCBcIm9mZnNldFwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBOZzJEcm9wZG93bk1lbnUucHJvdG90eXBlLCBcImFwcGVuZFRvQm9keVwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBOZzJEcm9wZG93bk1lbnUucHJvdG90eXBlLCBcInpJbmRleFwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmcyTWVudUl0ZW0sIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbl0sIE5nMkRyb3Bkb3duTWVudS5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcbk5nMkRyb3Bkb3duTWVudSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduZzItZHJvcGRvd24tbWVudScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDwhLS0gTUVOVSAtLT5cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJuZzItZHJvcGRvd24tbWVudSBuZzItZHJvcGRvd24tbWVudS0tLXdpZHRoLS17eyB3aWR0aCB9fVwiXG4gICAgICAgICAgICBbY2xhc3MubmcyLWRyb3Bkb3duLW1lbnUtLWluc2lkZS1lbGVtZW50XT1cIiFhcHBlbmRUb0JvZHlcIlxuICAgICAgICAgICAgW2NsYXNzLm5nMi1kcm9wZG93bi1tZW51LS1vcGVuXT1cImRyb3Bkb3duU3RhdGUubWVudVN0YXRlLmlzVmlzaWJsZVwiXG4gICAgICAgICAgICBbc3R5bGUuei1pbmRleF09XCJ6SW5kZXhcIlxuICAgICAgICAgICAgW0BmYWRlXT1cImRyb3Bkb3duU3RhdGUubWVudVN0YXRlLnRvU3RyaW5nKClcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJuZzItZHJvcGRvd24tbWVudV9fb3B0aW9ucy1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIFtAb3BhY2l0eV09XCJkcm9wZG93blN0YXRlLm1lbnVTdGF0ZS50b1N0cmluZygpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPCEtLSBCQUNLRFJPUCAtLT5cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJuZzItZHJvcGRvd24tYmFja2Ryb3BcIlxuICAgICAgICAgICAgKm5nSWY9XCJkcm9wZG93blN0YXRlLm1lbnVTdGF0ZS5pc1Zpc2libGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImhpZGUoKVwiXG4gICAgICAgID48L2Rpdj5cbiAgICBgLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICB0cmlnZ2VyKCdmYWRlJywgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCd2aXNpYmxlJywgc3R5bGUoeyBvcGFjaXR5OiAxLCBoZWlnaHQ6ICcqJywgd2lkdGg6ICcqJyB9KSksXG4gICAgICAgICAgICAgICAgc3RhdGUoJ2hpZGRlbicsIHN0eWxlKHsgb3BhY2l0eTogMCwgb3ZlcmZsb3c6ICdoaWRkZW4nLCBoZWlnaHQ6IDAsIHdpZHRoOiAwIH0pKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdoaWRkZW4gPT4gdmlzaWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMjUwbXMgZWFzZS1pbicsIHN0eWxlKHsgb3BhY2l0eTogMSwgaGVpZ2h0OiAnKicsIHdpZHRoOiAnKicgfSkpXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbigndmlzaWJsZSA9PiBoaWRkZW4nLCBbXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzM1MG1zIGVhc2Utb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyaWdnZXIoJ29wYWNpdHknLCBbXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzQ1MG1zIGVhc2UtaW4nLCBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwLCBvZmZzZXQ6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDEsIG9mZnNldDogMSB9KVxuICAgICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2aXNpYmxlID0+IGhpZGRlbicsIFtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMjUwbXMgZWFzZS1vdXQnLCBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAxLCBvZmZzZXQ6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAuNSwgb2Zmc2V0OiAwLjMgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAsIG9mZnNldDogMSB9KVxuICAgICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrfS5uZzItZHJvcGRvd24tbWVudXtvdmVyZmxvdy15OmF1dG87Ym94LXNoYWRvdzowIDFweCAycHggMCByZ2JhKDAsMCwwLC4zKTtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOi41ZW0gMDtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLXJhZGl1czoxcHg7bWF4LWhlaWdodDo0MDBweDt3aWR0aDoyNjBweDttaW4taGVpZ2h0OjA7ZGlzcGxheTpibG9ja30ubmcyLWRyb3Bkb3duLW1lbnUubmcyLWRyb3Bkb3duLW1lbnUtLWluc2lkZS1lbGVtZW50e3Bvc2l0aW9uOmZpeGVkfS5uZzItZHJvcGRvd24tbWVudS5uZzItZHJvcGRvd24tbWVudS0td2lkdGgtLTJ7d2lkdGg6MjAwcHh9Lm5nMi1kcm9wZG93bi1tZW51Lm5nMi1kcm9wZG93bi1tZW51LS13aWR0aC0tNHt3aWR0aDoyNjBweH0ubmcyLWRyb3Bkb3duLW1lbnUubmcyLWRyb3Bkb3duLW1lbnUtLXdpZHRoLS02e3dpZHRoOjMyMHB4fS5uZzItZHJvcGRvd24tYmFja2Ryb3B7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ei1pbmRleDoxO292ZXJmbG93OmhpZGRlbn06aG9zdCA6Om5nLWRlZXAgLm5nMi1tZW51LWRpdmlkZXJ7aGVpZ2h0OjFweDttaW4taGVpZ2h0OjFweDttYXgtaGVpZ2h0OjFweDt3aWR0aDoxMDAlO2Rpc3BsYXk6YmxvY2s7YmFja2dyb3VuZDojZjlmOWY5fVwiXVxuICAgIH0pXG5dLCBOZzJEcm9wZG93bk1lbnUpO1xuZXhwb3J0IHsgTmcyRHJvcGRvd25NZW51IH07XG4iXX0=