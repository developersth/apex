/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function ItemsRangeResult() { }
if (false) {
    /** @type {?} */
    ItemsRangeResult.prototype.scrollHeight;
    /** @type {?} */
    ItemsRangeResult.prototype.topPadding;
    /** @type {?} */
    ItemsRangeResult.prototype.start;
    /** @type {?} */
    ItemsRangeResult.prototype.end;
}
/**
 * @record
 */
export function PanelDimensions() { }
if (false) {
    /** @type {?} */
    PanelDimensions.prototype.itemHeight;
    /** @type {?} */
    PanelDimensions.prototype.panelHeight;
    /** @type {?} */
    PanelDimensions.prototype.itemsPerViewport;
}
export class NgDropdownPanelService {
    constructor() {
        this._dimensions = {
            itemHeight: 0,
            panelHeight: 0,
            itemsPerViewport: 0
        };
    }
    /**
     * @return {?}
     */
    get dimensions() {
        return this._dimensions;
    }
    /**
     * @param {?} scrollPos
     * @param {?} itemsLength
     * @param {?} buffer
     * @return {?}
     */
    calculateItems(scrollPos, itemsLength, buffer) {
        /** @type {?} */
        const d = this._dimensions;
        /** @type {?} */
        const scrollHeight = d.itemHeight * itemsLength;
        /** @type {?} */
        const scrollTop = Math.max(0, scrollPos);
        /** @type {?} */
        const indexByScrollTop = scrollTop / scrollHeight * itemsLength;
        /** @type {?} */
        let end = Math.min(itemsLength, Math.ceil(indexByScrollTop) + (d.itemsPerViewport + 1));
        /** @type {?} */
        const maxStartEnd = end;
        /** @type {?} */
        const maxStart = Math.max(0, maxStartEnd - d.itemsPerViewport);
        /** @type {?} */
        let start = Math.min(maxStart, Math.floor(indexByScrollTop));
        /** @type {?} */
        let topPadding = d.itemHeight * Math.ceil(start) - (d.itemHeight * Math.min(start, buffer));
        topPadding = !isNaN(topPadding) ? topPadding : 0;
        start = !isNaN(start) ? start : -1;
        end = !isNaN(end) ? end : -1;
        start -= buffer;
        start = Math.max(0, start);
        end += buffer;
        end = Math.min(itemsLength, end);
        return {
            topPadding,
            scrollHeight,
            start,
            end
        };
    }
    /**
     * @param {?} itemHeight
     * @param {?} panelHeight
     * @return {?}
     */
    setDimensions(itemHeight, panelHeight) {
        /** @type {?} */
        const itemsPerViewport = Math.max(1, Math.floor(panelHeight / itemHeight));
        this._dimensions = {
            itemHeight,
            panelHeight,
            itemsPerViewport
        };
    }
    /**
     * @param {?} itemTop
     * @param {?} itemHeight
     * @param {?} lastScroll
     * @return {?}
     */
    getScrollTo(itemTop, itemHeight, lastScroll) {
        const { panelHeight } = this.dimensions;
        /** @type {?} */
        const itemBottom = itemTop + itemHeight;
        /** @type {?} */
        const top = lastScroll;
        /** @type {?} */
        const bottom = top + panelHeight;
        if (panelHeight >= itemBottom && lastScroll === itemTop) {
            return null;
        }
        if (itemBottom > bottom) {
            return top + itemBottom - bottom;
        }
        else if (itemTop <= top) {
            return itemTop;
        }
        return null;
    }
}
NgDropdownPanelService.ɵfac = function NgDropdownPanelService_Factory(t) { return new (t || NgDropdownPanelService)(); };
NgDropdownPanelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgDropdownPanelService, factory: NgDropdownPanelService.ɵfac });

if (false) {
    /**
     * @type {?}
     * @private
     */
    NgDropdownPanelService.prototype._dimensions;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQG5nLXNlbGVjdC9uZy1zZWxlY3QvZXNtMjAxNS9saWIvbmctZHJvcGRvd24tcGFuZWwuc2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1IQyIsImZpbGUiOiJuZy1kcm9wZG93bi1wYW5lbC5zZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gSXRlbXNSYW5nZVJlc3VsdCgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEl0ZW1zUmFuZ2VSZXN1bHQucHJvdG90eXBlLnNjcm9sbEhlaWdodDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgSXRlbXNSYW5nZVJlc3VsdC5wcm90b3R5cGUudG9wUGFkZGluZztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgSXRlbXNSYW5nZVJlc3VsdC5wcm90b3R5cGUuc3RhcnQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEl0ZW1zUmFuZ2VSZXN1bHQucHJvdG90eXBlLmVuZDtcbn1cbi8qKlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFuZWxEaW1lbnNpb25zKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUGFuZWxEaW1lbnNpb25zLnByb3RvdHlwZS5pdGVtSGVpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQYW5lbERpbWVuc2lvbnMucHJvdG90eXBlLnBhbmVsSGVpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBQYW5lbERpbWVuc2lvbnMucHJvdG90eXBlLml0ZW1zUGVyVmlld3BvcnQ7XG59XG5leHBvcnQgY2xhc3MgTmdEcm9wZG93blBhbmVsU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0OiAwLFxuICAgICAgICAgICAgcGFuZWxIZWlnaHQ6IDAsXG4gICAgICAgICAgICBpdGVtc1BlclZpZXdwb3J0OiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1lbnNpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNjcm9sbFBvc1xuICAgICAqIEBwYXJhbSB7P30gaXRlbXNMZW5ndGhcbiAgICAgKiBAcGFyYW0gez99IGJ1ZmZlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgY2FsY3VsYXRlSXRlbXMoc2Nyb2xsUG9zLCBpdGVtc0xlbmd0aCwgYnVmZmVyKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2RpbWVuc2lvbnM7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gZC5pdGVtSGVpZ2h0ICogaXRlbXNMZW5ndGg7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsUG9zKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBpbmRleEJ5U2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC8gc2Nyb2xsSGVpZ2h0ICogaXRlbXNMZW5ndGg7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKGl0ZW1zTGVuZ3RoLCBNYXRoLmNlaWwoaW5kZXhCeVNjcm9sbFRvcCkgKyAoZC5pdGVtc1BlclZpZXdwb3J0ICsgMSkpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IG1heFN0YXJ0RW5kID0gZW5kO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gTWF0aC5tYXgoMCwgbWF4U3RhcnRFbmQgLSBkLml0ZW1zUGVyVmlld3BvcnQpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWluKG1heFN0YXJ0LCBNYXRoLmZsb29yKGluZGV4QnlTY3JvbGxUb3ApKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBsZXQgdG9wUGFkZGluZyA9IGQuaXRlbUhlaWdodCAqIE1hdGguY2VpbChzdGFydCkgLSAoZC5pdGVtSGVpZ2h0ICogTWF0aC5taW4oc3RhcnQsIGJ1ZmZlcikpO1xuICAgICAgICB0b3BQYWRkaW5nID0gIWlzTmFOKHRvcFBhZGRpbmcpID8gdG9wUGFkZGluZyA6IDA7XG4gICAgICAgIHN0YXJ0ID0gIWlzTmFOKHN0YXJ0KSA/IHN0YXJ0IDogLTE7XG4gICAgICAgIGVuZCA9ICFpc05hTihlbmQpID8gZW5kIDogLTE7XG4gICAgICAgIHN0YXJ0IC09IGJ1ZmZlcjtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCk7XG4gICAgICAgIGVuZCArPSBidWZmZXI7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGl0ZW1zTGVuZ3RoLCBlbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wUGFkZGluZyxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXRlbUhlaWdodFxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxIZWlnaHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldERpbWVuc2lvbnMoaXRlbUhlaWdodCwgcGFuZWxIZWlnaHQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBpdGVtc1BlclZpZXdwb3J0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihwYW5lbEhlaWdodCAvIGl0ZW1IZWlnaHQpKTtcbiAgICAgICAgdGhpcy5fZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIGl0ZW1IZWlnaHQsXG4gICAgICAgICAgICBwYW5lbEhlaWdodCxcbiAgICAgICAgICAgIGl0ZW1zUGVyVmlld3BvcnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpdGVtVG9wXG4gICAgICogQHBhcmFtIHs/fSBpdGVtSGVpZ2h0XG4gICAgICogQHBhcmFtIHs/fSBsYXN0U2Nyb2xsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxUbyhpdGVtVG9wLCBpdGVtSGVpZ2h0LCBsYXN0U2Nyb2xsKSB7XG4gICAgICAgIGNvbnN0IHsgcGFuZWxIZWlnaHQgfSA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBpdGVtQm90dG9tID0gaXRlbVRvcCArIGl0ZW1IZWlnaHQ7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgdG9wID0gbGFzdFNjcm9sbDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBib3R0b20gPSB0b3AgKyBwYW5lbEhlaWdodDtcbiAgICAgICAgaWYgKHBhbmVsSGVpZ2h0ID49IGl0ZW1Cb3R0b20gJiYgbGFzdFNjcm9sbCA9PT0gaXRlbVRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1Cb3R0b20gPiBib3R0b20pIHtcbiAgICAgICAgICAgIHJldHVybiB0b3AgKyBpdGVtQm90dG9tIC0gYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW1Ub3AgPD0gdG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5nRHJvcGRvd25QYW5lbFNlcnZpY2UucHJvdG90eXBlLl9kaW1lbnNpb25zO1xufVxuIl19