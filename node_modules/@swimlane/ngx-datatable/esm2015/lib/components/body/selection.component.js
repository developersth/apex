/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { SelectionType } from '../../types/selection.type';
import { selectRowsBetween, selectRows } from '../../utils/selection';
import { Keys } from '../../utils/keys';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export function Model() { }
if (false) {
    /** @type {?} */
    Model.prototype.type;
    /** @type {?} */
    Model.prototype.event;
    /** @type {?} */
    Model.prototype.row;
    /** @type {?} */
    Model.prototype.rowElement;
    /** @type {?} */
    Model.prototype.cellElement;
    /** @type {?} */
    Model.prototype.cellIndex;
}
export class DataTableSelectionComponent {
    constructor() {
        this.activate = new EventEmitter();
        this.select = new EventEmitter();
    }
    /**
     * @param {?} event
     * @param {?} index
     * @param {?} row
     * @return {?}
     */
    selectRow(event, index, row) {
        if (!this.selectEnabled)
            return;
        /** @type {?} */
        const chkbox = this.selectionType === SelectionType.checkbox;
        /** @type {?} */
        const multi = this.selectionType === SelectionType.multi;
        /** @type {?} */
        const multiClick = this.selectionType === SelectionType.multiClick;
        /** @type {?} */
        let selected = [];
        if (multi || chkbox || multiClick) {
            if (event.shiftKey) {
                selected = selectRowsBetween([], this.rows, index, this.prevIndex, this.getRowSelectedIdx.bind(this));
            }
            else if (event.ctrlKey || event.metaKey || multiClick || chkbox) {
                selected = selectRows([...this.selected], row, this.getRowSelectedIdx.bind(this));
            }
            else {
                selected = selectRows([], row, this.getRowSelectedIdx.bind(this));
            }
        }
        else {
            selected = selectRows([], row, this.getRowSelectedIdx.bind(this));
        }
        if (typeof this.selectCheck === 'function') {
            selected = selected.filter(this.selectCheck.bind(this));
        }
        this.selected.splice(0, this.selected.length);
        this.selected.push(...selected);
        this.prevIndex = index;
        this.select.emit({
            selected
        });
    }
    /**
     * @param {?} model
     * @param {?} index
     * @return {?}
     */
    onActivate(model, index) {
        const { type, event, row } = model;
        /** @type {?} */
        const chkbox = this.selectionType === SelectionType.checkbox;
        /** @type {?} */
        const select = (!chkbox && (type === 'click' || type === 'dblclick')) || (chkbox && type === 'checkbox');
        if (select) {
            this.selectRow(event, index, row);
        }
        else if (type === 'keydown') {
            if (((/** @type {?} */ (event))).keyCode === Keys.return) {
                this.selectRow(event, index, row);
            }
            else {
                this.onKeyboardFocus(model);
            }
        }
        this.activate.emit(model);
    }
    /**
     * @param {?} model
     * @return {?}
     */
    onKeyboardFocus(model) {
        const { keyCode } = (/** @type {?} */ (model.event));
        /** @type {?} */
        const shouldFocus = keyCode === Keys.up || keyCode === Keys.down || keyCode === Keys.right || keyCode === Keys.left;
        if (shouldFocus) {
            /** @type {?} */
            const isCellSelection = this.selectionType === SelectionType.cell;
            if (!model.cellElement || !isCellSelection) {
                this.focusRow(model.rowElement, keyCode);
            }
            else if (isCellSelection) {
                this.focusCell(model.cellElement, model.rowElement, keyCode, model.cellIndex);
            }
        }
    }
    /**
     * @param {?} rowElement
     * @param {?} keyCode
     * @return {?}
     */
    focusRow(rowElement, keyCode) {
        /** @type {?} */
        const nextRowElement = this.getPrevNextRow(rowElement, keyCode);
        if (nextRowElement)
            nextRowElement.focus();
    }
    /**
     * @param {?} rowElement
     * @param {?} keyCode
     * @return {?}
     */
    getPrevNextRow(rowElement, keyCode) {
        /** @type {?} */
        const parentElement = rowElement.parentElement;
        if (parentElement) {
            /** @type {?} */
            let focusElement;
            if (keyCode === Keys.up) {
                focusElement = parentElement.previousElementSibling;
            }
            else if (keyCode === Keys.down) {
                focusElement = parentElement.nextElementSibling;
            }
            if (focusElement && focusElement.children.length) {
                return focusElement.children[0];
            }
        }
    }
    /**
     * @param {?} cellElement
     * @param {?} rowElement
     * @param {?} keyCode
     * @param {?} cellIndex
     * @return {?}
     */
    focusCell(cellElement, rowElement, keyCode, cellIndex) {
        /** @type {?} */
        let nextCellElement;
        if (keyCode === Keys.left) {
            nextCellElement = cellElement.previousElementSibling;
        }
        else if (keyCode === Keys.right) {
            nextCellElement = cellElement.nextElementSibling;
        }
        else if (keyCode === Keys.up || keyCode === Keys.down) {
            /** @type {?} */
            const nextRowElement = this.getPrevNextRow(rowElement, keyCode);
            if (nextRowElement) {
                /** @type {?} */
                const children = nextRowElement.getElementsByClassName('datatable-body-cell');
                if (children.length)
                    nextCellElement = children[cellIndex];
            }
        }
        if (nextCellElement)
            nextCellElement.focus();
    }
    /**
     * @param {?} row
     * @return {?}
     */
    getRowSelected(row) {
        return this.getRowSelectedIdx(row, this.selected) > -1;
    }
    /**
     * @param {?} row
     * @param {?} selected
     * @return {?}
     */
    getRowSelectedIdx(row, selected) {
        if (!selected || !selected.length)
            return -1;
        /** @type {?} */
        const rowId = this.rowIdentity(row);
        return selected.findIndex((/**
         * @param {?} r
         * @return {?}
         */
        r => {
            /** @type {?} */
            const id = this.rowIdentity(r);
            return id === rowId;
        }));
    }
}
DataTableSelectionComponent.ɵfac = function DataTableSelectionComponent_Factory(t) { return new (t || DataTableSelectionComponent)(); };
DataTableSelectionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DataTableSelectionComponent, selectors: [["datatable-selection"]], inputs: { rows: "rows", selected: "selected", selectEnabled: "selectEnabled", selectionType: "selectionType", rowIdentity: "rowIdentity", selectCheck: "selectCheck" }, outputs: { activate: "activate", select: "select" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function DataTableSelectionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DataTableSelectionComponent.propDecorators = {
    rows: [{ type: Input }],
    selected: [{ type: Input }],
    selectEnabled: [{ type: Input }],
    selectionType: [{ type: Input }],
    rowIdentity: [{ type: Input }],
    selectCheck: [{ type: Input }],
    activate: [{ type: Output }],
    select: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DataTableSelectionComponent, [{
        type: Component,
        args: [{
                selector: 'datatable-selection',
                template: `
    <ng-content></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { activate: [{
            type: Output
        }], select: [{
            type: Output
        }], rows: [{
            type: Input
        }], selected: [{
            type: Input
        }], selectEnabled: [{
            type: Input
        }], selectionType: [{
            type: Input
        }], rowIdentity: [{
            type: Input
        }], selectCheck: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    DataTableSelectionComponent.prototype.rows;
    /** @type {?} */
    DataTableSelectionComponent.prototype.selected;
    /** @type {?} */
    DataTableSelectionComponent.prototype.selectEnabled;
    /** @type {?} */
    DataTableSelectionComponent.prototype.selectionType;
    /** @type {?} */
    DataTableSelectionComponent.prototype.rowIdentity;
    /** @type {?} */
    DataTableSelectionComponent.prototype.selectCheck;
    /** @type {?} */
    DataTableSelectionComponent.prototype.activate;
    /** @type {?} */
    DataTableSelectionComponent.prototype.select;
    /** @type {?} */
    DataTableSelectionComponent.prototype.prevIndex;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1kYXRhdGFibGUvZXNtMjAxNS9saWIvY29tcG9uZW50cy9ib2R5L3NlbGVjdGlvbi5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlNQyxnREFTQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVVBIiwiZmlsZSI6InNlbGVjdGlvbi5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlbGVjdGlvblR5cGUgfSBmcm9tICcuLi8uLi90eXBlcy9zZWxlY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBzZWxlY3RSb3dzQmV0d2Vlbiwgc2VsZWN0Um93cyB9IGZyb20gJy4uLy4uL3V0aWxzL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBLZXlzIH0gZnJvbSAnLi4vLi4vdXRpbHMva2V5cyc7XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vZGVsKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTW9kZWwucHJvdG90eXBlLnR5cGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5ldmVudDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTW9kZWwucHJvdG90eXBlLnJvdztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTW9kZWwucHJvdG90eXBlLnJvd0VsZW1lbnQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5jZWxsRWxlbWVudDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTW9kZWwucHJvdG90eXBlLmNlbGxJbmRleDtcbn1cbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVTZWxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2VsZWN0Um93KGV2ZW50LCBpbmRleCwgcm93KSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RFbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGNoa2JveCA9IHRoaXMuc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5jaGVja2JveDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBtdWx0aSA9IHRoaXMuc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5tdWx0aTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBtdWx0aUNsaWNrID0gdGhpcy5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLm11bHRpQ2xpY2s7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gW107XG4gICAgICAgIGlmIChtdWx0aSB8fCBjaGtib3ggfHwgbXVsdGlDbGljaykge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RSb3dzQmV0d2VlbihbXSwgdGhpcy5yb3dzLCBpbmRleCwgdGhpcy5wcmV2SW5kZXgsIHRoaXMuZ2V0Um93U2VsZWN0ZWRJZHguYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgbXVsdGlDbGljayB8fCBjaGtib3gpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdFJvd3MoWy4uLnRoaXMuc2VsZWN0ZWRdLCByb3csIHRoaXMuZ2V0Um93U2VsZWN0ZWRJZHguYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdFJvd3MoW10sIHJvdywgdGhpcy5nZXRSb3dTZWxlY3RlZElkeC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0Um93cyhbXSwgcm93LCB0aGlzLmdldFJvd1NlbGVjdGVkSWR4LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3RDaGVjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZC5maWx0ZXIodGhpcy5zZWxlY3RDaGVjay5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkLnNwbGljZSgwLCB0aGlzLnNlbGVjdGVkLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaCguLi5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoe1xuICAgICAgICAgICAgc2VsZWN0ZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kZWxcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBvbkFjdGl2YXRlKG1vZGVsLCBpbmRleCkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIGV2ZW50LCByb3cgfSA9IG1vZGVsO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGNoa2JveCA9IHRoaXMuc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5jaGVja2JveDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzZWxlY3QgPSAoIWNoa2JveCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnZGJsY2xpY2snKSkgfHwgKGNoa2JveCAmJiB0eXBlID09PSAnY2hlY2tib3gnKTtcbiAgICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSb3coZXZlbnQsIGluZGV4LCByb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAoZXZlbnQpKSkua2V5Q29kZSA9PT0gS2V5cy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhldmVudCwgaW5kZXgsIHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5Ym9hcmRGb2N1cyhtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KG1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2RlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgb25LZXlib2FyZEZvY3VzKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHsga2V5Q29kZSB9ID0gKC8qKiBAdHlwZSB7P30gKi8gKG1vZGVsLmV2ZW50KSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2hvdWxkRm9jdXMgPSBrZXlDb2RlID09PSBLZXlzLnVwIHx8IGtleUNvZGUgPT09IEtleXMuZG93biB8fCBrZXlDb2RlID09PSBLZXlzLnJpZ2h0IHx8IGtleUNvZGUgPT09IEtleXMubGVmdDtcbiAgICAgICAgaWYgKHNob3VsZEZvY3VzKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBpc0NlbGxTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuY2VsbDtcbiAgICAgICAgICAgIGlmICghbW9kZWwuY2VsbEVsZW1lbnQgfHwgIWlzQ2VsbFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNSb3cobW9kZWwucm93RWxlbWVudCwga2V5Q29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NlbGxTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQ2VsbChtb2RlbC5jZWxsRWxlbWVudCwgbW9kZWwucm93RWxlbWVudCwga2V5Q29kZSwgbW9kZWwuY2VsbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd0VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleUNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZvY3VzUm93KHJvd0VsZW1lbnQsIGtleUNvZGUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBuZXh0Um93RWxlbWVudCA9IHRoaXMuZ2V0UHJldk5leHRSb3cocm93RWxlbWVudCwga2V5Q29kZSk7XG4gICAgICAgIGlmIChuZXh0Um93RWxlbWVudClcbiAgICAgICAgICAgIG5leHRSb3dFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm93RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5Q29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0UHJldk5leHRSb3cocm93RWxlbWVudCwga2V5Q29kZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSByb3dFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBsZXQgZm9jdXNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMudXApIHtcbiAgICAgICAgICAgICAgICBmb2N1c0VsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBLZXlzLmRvd24pIHtcbiAgICAgICAgICAgICAgICBmb2N1c0VsZW1lbnQgPSBwYXJlbnRFbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb2N1c0VsZW1lbnQgJiYgZm9jdXNFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2N1c0VsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjZWxsRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcm93RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5Q29kZVxuICAgICAqIEBwYXJhbSB7P30gY2VsbEluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmb2N1c0NlbGwoY2VsbEVsZW1lbnQsIHJvd0VsZW1lbnQsIGtleUNvZGUsIGNlbGxJbmRleCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBuZXh0Q2VsbEVsZW1lbnQ7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLmxlZnQpIHtcbiAgICAgICAgICAgIG5leHRDZWxsRWxlbWVudCA9IGNlbGxFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5yaWdodCkge1xuICAgICAgICAgICAgbmV4dENlbGxFbGVtZW50ID0gY2VsbEVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEtleXMudXAgfHwga2V5Q29kZSA9PT0gS2V5cy5kb3duKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBuZXh0Um93RWxlbWVudCA9IHRoaXMuZ2V0UHJldk5leHRSb3cocm93RWxlbWVudCwga2V5Q29kZSk7XG4gICAgICAgICAgICBpZiAobmV4dFJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBuZXh0Um93RWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkYXRhdGFibGUtYm9keS1jZWxsJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbmV4dENlbGxFbGVtZW50ID0gY2hpbGRyZW5bY2VsbEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENlbGxFbGVtZW50KVxuICAgICAgICAgICAgbmV4dENlbGxFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRSb3dTZWxlY3RlZChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um93U2VsZWN0ZWRJZHgocm93LCB0aGlzLnNlbGVjdGVkKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldFJvd1NlbGVjdGVkSWR4KHJvdywgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCB8fCAhc2VsZWN0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHJvd0lkID0gdGhpcy5yb3dJZGVudGl0eShyb3cpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQuZmluZEluZGV4KCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICByID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5yb3dJZGVudGl0eShyKTtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gcm93SWQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5EYXRhVGFibGVTZWxlY3Rpb25Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2RhdGF0YWJsZS1zZWxlY3Rpb24nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9XSB9XG5dO1xuRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHJvd3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RFbmFibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Rpb25UeXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByb3dJZGVudGl0eTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0Q2hlY2s6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFjdGl2YXRlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc2VsZWN0OiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5yb3dzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVTZWxlY3Rpb25Db21wb25lbnQucHJvdG90eXBlLnNlbGVjdGVkO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVTZWxlY3Rpb25Db21wb25lbnQucHJvdG90eXBlLnNlbGVjdEVuYWJsZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZVNlbGVjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0aW9uVHlwZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5yb3dJZGVudGl0eTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3RDaGVjaztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlU2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3Q7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZVNlbGVjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUucHJldkluZGV4O1xufVxuIl19