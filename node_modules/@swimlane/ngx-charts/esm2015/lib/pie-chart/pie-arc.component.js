import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ElementRef, SimpleChanges, OnChanges, ChangeDetectionStrategy } from '@angular/core';
import { interpolate } from 'd3-interpolate';
import { select } from 'd3-selection';
import { arc } from 'd3-shape';
import { id } from '../utils/id';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/svg-radial-gradient.component';

const _c0 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r351 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", ctx_r351.fill)("name", ctx_r351.radialGradientId)("startOpacity", ctx_r351.startOpacity);
} }
let PieArcComponent = class PieArcComponent {
    constructor(element) {
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.cornerRadius = 0;
        this.explodeSlices = false;
        this.gradient = false;
        this.animate = true;
        this.pointerEvents = true;
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    ngOnChanges(changes) {
        this.update();
    }
    getGradient() {
        return this.gradient ? this.gradientFill : this.fill;
    }
    getPointerEvents() {
        return this.pointerEvents ? 'auto' : 'none';
    }
    update() {
        const calc = this.calculateArc();
        this.startOpacity = 0.5;
        this.radialGradientId = 'linearGrad' + id().toString();
        this.gradientFill = `url(#${this.radialGradientId})`;
        if (this.animate) {
            if (this.initialized) {
                this.updateAnimation();
            }
            else {
                this.loadAnimation();
                this.initialized = true;
            }
        }
        else {
            this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
        }
    }
    calculateArc() {
        let outerRadius = this.outerRadius;
        if (this.explodeSlices && this.innerRadius === 0) {
            outerRadius = (this.outerRadius * this.value) / this.max;
        }
        return arc()
            .innerRadius(this.innerRadius)
            .outerRadius(outerRadius)
            .cornerRadius(this.cornerRadius);
    }
    loadAnimation() {
        const node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        const calc = this.calculateArc();
        node
            .transition()
            .attrTween('d', function (d) {
            this._current = this._current || d;
            const copyOfD = Object.assign({}, d);
            copyOfD.endAngle = copyOfD.startAngle;
            const interpolater = interpolate(copyOfD, copyOfD);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        })
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            const interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    }
    updateAnimation() {
        const node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        const calc = this.calculateArc();
        node
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            const interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    }
    onClick() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this.select.emit(this.data), 200);
    }
    onDblClick(event) {
        event.preventDefault();
        event.stopPropagation();
        clearTimeout(this._timeout);
        this.dblclick.emit({
            data: this.data,
            nativeEvent: event
        });
    }
};
PieArcComponent.ɵfac = function PieArcComponent_Factory(t) { return new (t || PieArcComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PieArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieArcComponent, selectors: [["g", "ngx-charts-pie-arc", ""]], inputs: { startAngle: "startAngle", endAngle: "endAngle", cornerRadius: "cornerRadius", explodeSlices: "explodeSlices", gradient: "gradient", animate: "animate", pointerEvents: "pointerEvents", isActive: "isActive", fill: "fill", innerRadius: "innerRadius", outerRadius: "outerRadius", value: "value", max: "max", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 3, vars: 7, consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity"]], template: function PieArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "path", 2);
        ɵngcc0.ɵɵlistener("click", function PieArcComponent_Template__svg_path_click_2_listener($event) { return ctx.onClick(); })("dblclick", function PieArcComponent_Template__svg_path_dblclick_2_listener($event) { return ctx.onDblClick($event); })("mouseenter", function PieArcComponent_Template__svg_path_mouseenter_2_listener($event) { return ctx.activate.emit(ctx.data); })("mouseleave", function PieArcComponent_Template__svg_path_mouseleave_2_listener($event) { return ctx.deactivate.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("pointer-events", ctx.getPointerEvents());
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵattribute("d", ctx.path)("fill", ctx.getGradient());
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SvgRadialGradientComponent], encapsulation: 2, changeDetection: 0 });
PieArcComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], PieArcComponent.prototype, "fill", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "startAngle", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "endAngle", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "innerRadius", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "outerRadius", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "cornerRadius", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "value", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "max", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "data", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "explodeSlices", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "gradient", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "animate", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "pointerEvents", void 0);
__decorate([
    Input()
], PieArcComponent.prototype, "isActive", void 0);
__decorate([
    Output()
], PieArcComponent.prototype, "select", void 0);
__decorate([
    Output()
], PieArcComponent.prototype, "activate", void 0);
__decorate([
    Output()
], PieArcComponent.prototype, "deactivate", void 0);
__decorate([
    Output()
], PieArcComponent.prototype, "dblclick", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-arc]',
                template: `
    <svg:g class="arc-group">
      <svg:defs *ngIf="gradient">
        <svg:g
          ngx-charts-svg-radial-gradient
          [color]="fill"
          orientation="vertical"
          [name]="radialGradientId"
          [startOpacity]="startOpacity"
        />
      </svg:defs>
      <svg:path
        [attr.d]="path"
        class="arc"
        [class.active]="isActive"
        [attr.fill]="getGradient()"
        (click)="onClick()"
        (dblclick)="onDblClick($event)"
        (mouseenter)="activate.emit(data)"
        (mouseleave)="deactivate.emit(data)"
        [style.pointer-events]="getPointerEvents()"
      />
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animate: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }], isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], fill: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], value: [{
            type: Input
        }], max: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
export { PieArcComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvcGllLWNoYXJ0L3BpZS1hcmMuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytHQWdIRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tEQXlEZ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBOEI5QiIsImZpbGUiOiJwaWUtYXJjLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBTaW1wbGVDaGFuZ2VzLCBPbkNoYW5nZXMsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBhcmMgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4uL3V0aWxzL2lkJztcbmxldCBQaWVBcmNDb21wb25lbnQgPSBjbGFzcyBQaWVBcmNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICAgICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgICAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgICAgIHRoaXMuZXhwbG9kZVNsaWNlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucG9pbnRlckV2ZW50cyA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYmxjbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0R3JhZGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYWRpZW50ID8gdGhpcy5ncmFkaWVudEZpbGwgOiB0aGlzLmZpbGw7XG4gICAgfVxuICAgIGdldFBvaW50ZXJFdmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXJFdmVudHMgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2FsYyA9IHRoaXMuY2FsY3VsYXRlQXJjKCk7XG4gICAgICAgIHRoaXMuc3RhcnRPcGFjaXR5ID0gMC41O1xuICAgICAgICB0aGlzLnJhZGlhbEdyYWRpZW50SWQgPSAnbGluZWFyR3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRGaWxsID0gYHVybCgjJHt0aGlzLnJhZGlhbEdyYWRpZW50SWR9KWA7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gY2FsYy5zdGFydEFuZ2xlKHRoaXMuc3RhcnRBbmdsZSkuZW5kQW5nbGUodGhpcy5lbmRBbmdsZSkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjdWxhdGVBcmMoKSB7XG4gICAgICAgIGxldCBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgICAgIGlmICh0aGlzLmV4cGxvZGVTbGljZXMgJiYgdGhpcy5pbm5lclJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSAodGhpcy5vdXRlclJhZGl1cyAqIHRoaXMudmFsdWUpIC8gdGhpcy5tYXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyYygpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5pbm5lclJhZGl1cylcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhvdXRlclJhZGl1cylcbiAgICAgICAgICAgIC5jb3JuZXJSYWRpdXModGhpcy5jb3JuZXJSYWRpdXMpO1xuICAgIH1cbiAgICBsb2FkQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5hcmMnKVxuICAgICAgICAgICAgLmRhdGEoW3sgc3RhcnRBbmdsZTogdGhpcy5zdGFydEFuZ2xlLCBlbmRBbmdsZTogdGhpcy5lbmRBbmdsZSB9XSk7XG4gICAgICAgIGNvbnN0IGNhbGMgPSB0aGlzLmNhbGN1bGF0ZUFyYygpO1xuICAgICAgICBub2RlXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7XG4gICAgICAgICAgICBjb25zdCBjb3B5T2ZEID0gT2JqZWN0LmFzc2lnbih7fSwgZCk7XG4gICAgICAgICAgICBjb3B5T2ZELmVuZEFuZ2xlID0gY29weU9mRC5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUoY29weU9mRCwgY29weU9mRCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgICAgICAgLmF0dHJUd2VlbignZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVBbmltYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnLmFyYycpXG4gICAgICAgICAgICAuZGF0YShbeyBzdGFydEFuZ2xlOiB0aGlzLnN0YXJ0QW5nbGUsIGVuZEFuZ2xlOiB0aGlzLmVuZEFuZ2xlIH1dKTtcbiAgICAgICAgY29uc3QgY2FsYyA9IHRoaXMuY2FsY3VsYXRlQXJjKCk7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZXIgPSBpbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZXIoMCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsYyhpbnRlcnBvbGF0ZXIodCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGEpLCAyMDApO1xuICAgIH1cbiAgICBvbkRibENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHRoaXMuZGJsY2xpY2suZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblBpZUFyY0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwicG9pbnRlckV2ZW50c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcblBpZUFyY0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1hcmNdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOmcgY2xhc3M9XCJhcmMtZ3JvdXBcIj5cbiAgICAgIDxzdmc6ZGVmcyAqbmdJZj1cImdyYWRpZW50XCI+XG4gICAgICAgIDxzdmc6Z1xuICAgICAgICAgIG5neC1jaGFydHMtc3ZnLXJhZGlhbC1ncmFkaWVudFxuICAgICAgICAgIFtjb2xvcl09XCJmaWxsXCJcbiAgICAgICAgICBvcmllbnRhdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICBbbmFtZV09XCJyYWRpYWxHcmFkaWVudElkXCJcbiAgICAgICAgICBbc3RhcnRPcGFjaXR5XT1cInN0YXJ0T3BhY2l0eVwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2ZzpkZWZzPlxuICAgICAgPHN2ZzpwYXRoXG4gICAgICAgIFthdHRyLmRdPVwicGF0aFwiXG4gICAgICAgIGNsYXNzPVwiYXJjXCJcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJpc0FjdGl2ZVwiXG4gICAgICAgIFthdHRyLmZpbGxdPVwiZ2V0R3JhZGllbnQoKVwiXG4gICAgICAgIChjbGljayk9XCJvbkNsaWNrKClcIlxuICAgICAgICAoZGJsY2xpY2spPVwib25EYmxDbGljaygkZXZlbnQpXCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwiYWN0aXZhdGUuZW1pdChkYXRhKVwiXG4gICAgICAgIChtb3VzZWxlYXZlKT1cImRlYWN0aXZhdGUuZW1pdChkYXRhKVwiXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XCJnZXRQb2ludGVyRXZlbnRzKClcIlxuICAgICAgLz5cbiAgICA8L3N2ZzpnPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBQaWVBcmNDb21wb25lbnQpO1xuZXhwb3J0IHsgUGllQXJjQ29tcG9uZW50IH07XG4iXX0=