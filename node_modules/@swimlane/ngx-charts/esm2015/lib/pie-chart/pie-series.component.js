import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { max } from 'd3-array';
import { arc, pie } from 'd3-shape';
import { formatLabel, escapeLabel } from '../common/label.helper';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './pie-arc.component';
import * as ɵngcc3 from '../common/tooltip/tooltip.directive';
import * as ɵngcc4 from './pie-label.component';

const _c0 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    const arc_r373 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r374 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", arc_r373)("radius", ctx_r374.outerRadius)("color", ctx_r374.color(arc_r373))("label", ctx_r374.labelText(arc_r373))("labelTrim", ctx_r374.trimLabels)("labelTrimSize", ctx_r374.maxLabelLength)("max", ctx_r374.max)("value", arc_r373.value)("explodeSlices", ctx_r374.explodeSlices)("animations", ctx_r374.animations);
} }
function PieSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    const _r377 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    ɵngcc0.ɵɵelementStart(2, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r377); const ctx_r376 = ɵngcc0.ɵɵnextContext(); return ctx_r376.onClick($event); })("activate", function PieSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r377); const ctx_r378 = ɵngcc0.ɵɵnextContext(); return ctx_r378.activate.emit($event); })("deactivate", function PieSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r377); const ctx_r379 = ɵngcc0.ɵɵnextContext(); return ctx_r379.deactivate.emit($event); })("dblclick", function PieSeriesComponent__svg_g_0_Template__svg_g_dblclick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r377); const ctx_r380 = ɵngcc0.ɵɵnextContext(); return ctx_r380.dblclick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const arc_r373 = ctx.$implicit;
    const ctx_r372 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r372.labelVisible(arc_r373));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("startAngle", arc_r373.startAngle)("endAngle", arc_r373.endAngle)("innerRadius", ctx_r372.innerRadius)("outerRadius", ctx_r372.outerRadius)("fill", ctx_r372.color(arc_r373))("value", arc_r373.data.value)("gradient", ctx_r372.gradient)("data", arc_r373.data)("max", ctx_r372.max)("explodeSlices", ctx_r372.explodeSlices)("isActive", ctx_r372.isActive(arc_r373.data))("animate", ctx_r372.animations)("tooltipDisabled", ctx_r372.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r372.getTooltipTitle(arc_r373))("tooltipTemplate", ctx_r372.tooltipTemplate)("tooltipContext", arc_r373.data);
} }
let PieSeriesComponent = class PieSeriesComponent {
    constructor() {
        this.series = [];
        this.innerRadius = 60;
        this.outerRadius = 80;
        this.trimLabels = true;
        this.maxLabelLength = 10;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        const pieGenerator = pie()
            .value(d => d.value)
            .sort(null);
        const arcData = pieGenerator(this.series);
        this.max = max(arcData, d => {
            return d.value;
        });
        this.data = this.calculateLabelPositions(arcData);
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    }
    midAngle(d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    }
    outerArc() {
        const factor = 1.5;
        return arc()
            .innerRadius(this.outerRadius * factor)
            .outerRadius(this.outerRadius * factor);
    }
    calculateLabelPositions(pieData) {
        const factor = 1.5;
        const minDistance = 10;
        const labelPositions = pieData;
        labelPositions.forEach(d => {
            d.pos = this.outerArc().centroid(d);
            d.pos[0] = factor * this.outerRadius * (this.midAngle(d) < Math.PI ? 1 : -1);
        });
        for (let i = 0; i < labelPositions.length - 1; i++) {
            const a = labelPositions[i];
            if (!this.labelVisible(a)) {
                continue;
            }
            for (let j = i + 1; j < labelPositions.length; j++) {
                const b = labelPositions[j];
                if (!this.labelVisible(b)) {
                    continue;
                }
                // if they're on the same side
                if (b.pos[0] * a.pos[0] > 0) {
                    // if they're overlapping
                    const o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        // push the second up or down
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        return labelPositions;
    }
    labelVisible(myArc) {
        return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
    }
    getTooltipTitle(a) {
        return this.tooltipTemplate ? undefined : this.tooltipText(a);
    }
    labelText(myArc) {
        if (this.labelFormatting) {
            return this.labelFormatting(myArc.data.name);
        }
        return this.label(myArc);
    }
    label(myArc) {
        return formatLabel(myArc.data.name);
    }
    defaultTooltipText(myArc) {
        const label = this.label(myArc);
        const val = formatLabel(myArc.data.value);
        return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${val}</span>
    `;
    }
    color(myArc) {
        return this.colors.getColor(this.label(myArc));
    }
    trackBy(index, item) {
        return item.data.name;
    }
    onClick(data) {
        this.select.emit(data);
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find(d => {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    }
};
PieSeriesComponent.ɵfac = function PieSeriesComponent_Factory(t) { return new (t || PieSeriesComponent)(); };
PieSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieSeriesComponent, selectors: [["g", "ngx-charts-pie-series", ""]], inputs: { series: "series", innerRadius: "innerRadius", outerRadius: "outerRadius", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", colors: "colors", dims: "dims", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", "dblclick"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]], template: function PieSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc2.PieArcComponent, ɵngcc3.TooltipDirective, ɵngcc4.PieLabelComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], PieSeriesComponent.prototype, "colors", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "series", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "dims", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "innerRadius", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "outerRadius", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "explodeSlices", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "showLabels", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "gradient", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "activeEntries", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "labelFormatting", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "trimLabels", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "maxLabelLength", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "tooltipText", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "tooltipDisabled", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "tooltipTemplate", void 0);
__decorate([
    Input()
], PieSeriesComponent.prototype, "animations", void 0);
__decorate([
    Output()
], PieSeriesComponent.prototype, "select", void 0);
__decorate([
    Output()
], PieSeriesComponent.prototype, "activate", void 0);
__decorate([
    Output()
], PieSeriesComponent.prototype, "deactivate", void 0);
__decorate([
    Output()
], PieSeriesComponent.prototype, "dblclick", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-series]',
                template: `
    <svg:g *ngFor="let arc of data; trackBy: trackBy">
      <svg:g
        ngx-charts-pie-label
        *ngIf="labelVisible(arc)"
        [data]="arc"
        [radius]="outerRadius"
        [color]="color(arc)"
        [label]="labelText(arc)"
        [labelTrim]="trimLabels"
        [labelTrimSize]="maxLabelLength"
        [max]="max"
        [value]="arc.value"
        [explodeSlices]="explodeSlices"
        [animations]="animations"
      ></svg:g>
      <svg:g
        ngx-charts-pie-arc
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [gradient]="gradient"
        [data]="arc.data"
        [max]="max"
        [explodeSlices]="explodeSlices"
        [isActive]="isActive(arc.data)"
        [animate]="animations"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        (dblclick)="dblclick.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="'top'"
        [tooltipType]="'tooltip'"
        [tooltipTitle]="getTooltipTitle(arc)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="arc.data"
      ></svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { series: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], colors: [{
            type: Input
        }], dims: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], showLabels: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
export { PieSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvcGllLWNoYXJ0L3BpZS1zZXJpZXMuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1S0E0R0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREE0RG1EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWtEOUIiLCJmaWxlIjoicGllLXNlcmllcy5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IGFyYywgcGllIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgZm9ybWF0TGFiZWwsIGVzY2FwZUxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsLmhlbHBlcic7XG5sZXQgUGllU2VyaWVzQ29tcG9uZW50ID0gY2xhc3MgUGllU2VyaWVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IDYwO1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gODA7XG4gICAgICAgIHRoaXMudHJpbUxhYmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMubWF4TGFiZWxMZW5ndGggPSAxMDtcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYmxjbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHBpZUdlbmVyYXRvciA9IHBpZSgpXG4gICAgICAgICAgICAudmFsdWUoZCA9PiBkLnZhbHVlKVxuICAgICAgICAgICAgLnNvcnQobnVsbCk7XG4gICAgICAgIGNvbnN0IGFyY0RhdGEgPSBwaWVHZW5lcmF0b3IodGhpcy5zZXJpZXMpO1xuICAgICAgICB0aGlzLm1heCA9IG1heChhcmNEYXRhLCBkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5jYWxjdWxhdGVMYWJlbFBvc2l0aW9ucyhhcmNEYXRhKTtcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IHRoaXMudG9vbHRpcFRleHQgfHwgdGhpcy5kZWZhdWx0VG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIG1pZEFuZ2xlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDI7XG4gICAgfVxuICAgIG91dGVyQXJjKCkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSAxLjU7XG4gICAgICAgIHJldHVybiBhcmMoKVxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHRoaXMub3V0ZXJSYWRpdXMgKiBmYWN0b3IpXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXModGhpcy5vdXRlclJhZGl1cyAqIGZhY3Rvcik7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUxhYmVsUG9zaXRpb25zKHBpZURhdGEpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gMS41O1xuICAgICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IDEwO1xuICAgICAgICBjb25zdCBsYWJlbFBvc2l0aW9ucyA9IHBpZURhdGE7XG4gICAgICAgIGxhYmVsUG9zaXRpb25zLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBkLnBvcyA9IHRoaXMub3V0ZXJBcmMoKS5jZW50cm9pZChkKTtcbiAgICAgICAgICAgIGQucG9zWzBdID0gZmFjdG9yICogdGhpcy5vdXRlclJhZGl1cyAqICh0aGlzLm1pZEFuZ2xlKGQpIDwgTWF0aC5QSSA/IDEgOiAtMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVsUG9zaXRpb25zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYSA9IGxhYmVsUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhYmVsVmlzaWJsZShhKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGFiZWxQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gbGFiZWxQb3NpdGlvbnNbal07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhYmVsVmlzaWJsZShiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSdyZSBvbiB0aGUgc2FtZSBzaWRlXG4gICAgICAgICAgICAgICAgaWYgKGIucG9zWzBdICogYS5wb3NbMF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkncmUgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG1pbkRpc3RhbmNlIC0gTWF0aC5hYnMoYi5wb3NbMV0gLSBhLnBvc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgc2Vjb25kIHVwIG9yIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGIucG9zWzFdICs9IE1hdGguc2lnbihiLnBvc1swXSkgKiBvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9ucztcbiAgICB9XG4gICAgbGFiZWxWaXNpYmxlKG15QXJjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dMYWJlbHMgJiYgbXlBcmMuZW5kQW5nbGUgLSBteUFyYy5zdGFydEFuZ2xlID4gTWF0aC5QSSAvIDMwO1xuICAgIH1cbiAgICBnZXRUb29sdGlwVGl0bGUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiB0aGlzLnRvb2x0aXBUZXh0KGEpO1xuICAgIH1cbiAgICBsYWJlbFRleHQobXlBcmMpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvcm1hdHRpbmcobXlBcmMuZGF0YS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbChteUFyYyk7XG4gICAgfVxuICAgIGxhYmVsKG15QXJjKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRMYWJlbChteUFyYy5kYXRhLm5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VG9vbHRpcFRleHQobXlBcmMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsKG15QXJjKTtcbiAgICAgICAgY29uc3QgdmFsID0gZm9ybWF0TGFiZWwobXlBcmMuZGF0YS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBgXG4gICAgICA8c3BhbiBjbGFzcz1cInRvb2x0aXAtbGFiZWxcIj4ke2VzY2FwZUxhYmVsKGxhYmVsKX08L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInRvb2x0aXAtdmFsXCI+JHt2YWx9PC9zcGFuPlxuICAgIGA7XG4gICAgfVxuICAgIGNvbG9yKG15QXJjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9ycy5nZXRDb2xvcih0aGlzLmxhYmVsKG15QXJjKSk7XG4gICAgfVxuICAgIHRyYWNrQnkoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5uYW1lO1xuICAgIH1cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9XG4gICAgaXNBY3RpdmUoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0xhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltTGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heExhYmVsTGVuZ3RoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcblBpZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1zZXJpZXNdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOmcgKm5nRm9yPVwibGV0IGFyYyBvZiBkYXRhOyB0cmFja0J5OiB0cmFja0J5XCI+XG4gICAgICA8c3ZnOmdcbiAgICAgICAgbmd4LWNoYXJ0cy1waWUtbGFiZWxcbiAgICAgICAgKm5nSWY9XCJsYWJlbFZpc2libGUoYXJjKVwiXG4gICAgICAgIFtkYXRhXT1cImFyY1wiXG4gICAgICAgIFtyYWRpdXNdPVwib3V0ZXJSYWRpdXNcIlxuICAgICAgICBbY29sb3JdPVwiY29sb3IoYXJjKVwiXG4gICAgICAgIFtsYWJlbF09XCJsYWJlbFRleHQoYXJjKVwiXG4gICAgICAgIFtsYWJlbFRyaW1dPVwidHJpbUxhYmVsc1wiXG4gICAgICAgIFtsYWJlbFRyaW1TaXplXT1cIm1heExhYmVsTGVuZ3RoXCJcbiAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICBbdmFsdWVdPVwiYXJjLnZhbHVlXCJcbiAgICAgICAgW2V4cGxvZGVTbGljZXNdPVwiZXhwbG9kZVNsaWNlc1wiXG4gICAgICAgIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIlxuICAgICAgPjwvc3ZnOmc+XG4gICAgICA8c3ZnOmdcbiAgICAgICAgbmd4LWNoYXJ0cy1waWUtYXJjXG4gICAgICAgIFtzdGFydEFuZ2xlXT1cImFyYy5zdGFydEFuZ2xlXCJcbiAgICAgICAgW2VuZEFuZ2xlXT1cImFyYy5lbmRBbmdsZVwiXG4gICAgICAgIFtpbm5lclJhZGl1c109XCJpbm5lclJhZGl1c1wiXG4gICAgICAgIFtvdXRlclJhZGl1c109XCJvdXRlclJhZGl1c1wiXG4gICAgICAgIFtmaWxsXT1cImNvbG9yKGFyYylcIlxuICAgICAgICBbdmFsdWVdPVwiYXJjLmRhdGEudmFsdWVcIlxuICAgICAgICBbZ3JhZGllbnRdPVwiZ3JhZGllbnRcIlxuICAgICAgICBbZGF0YV09XCJhcmMuZGF0YVwiXG4gICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgW2V4cGxvZGVTbGljZXNdPVwiZXhwbG9kZVNsaWNlc1wiXG4gICAgICAgIFtpc0FjdGl2ZV09XCJpc0FjdGl2ZShhcmMuZGF0YSlcIlxuICAgICAgICBbYW5pbWF0ZV09XCJhbmltYXRpb25zXCJcbiAgICAgICAgKHNlbGVjdCk9XCJvbkNsaWNrKCRldmVudClcIlxuICAgICAgICAoYWN0aXZhdGUpPVwiYWN0aXZhdGUuZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgKGRlYWN0aXZhdGUpPVwiZGVhY3RpdmF0ZS5lbWl0KCRldmVudClcIlxuICAgICAgICAoZGJsY2xpY2spPVwiZGJsY2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgbmd4LXRvb2x0aXBcbiAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XCJ0b29sdGlwRGlzYWJsZWRcIlxuICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XCIndG9wJ1wiXG4gICAgICAgIFt0b29sdGlwVHlwZV09XCIndG9vbHRpcCdcIlxuICAgICAgICBbdG9vbHRpcFRpdGxlXT1cImdldFRvb2x0aXBUaXRsZShhcmMpXCJcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XCJ0b29sdGlwVGVtcGxhdGVcIlxuICAgICAgICBbdG9vbHRpcENvbnRleHRdPVwiYXJjLmRhdGFcIlxuICAgICAgPjwvc3ZnOmc+XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KVxuXSwgUGllU2VyaWVzQ29tcG9uZW50KTtcbmV4cG9ydCB7IFBpZVNlcmllc0NvbXBvbmVudCB9O1xuIl19