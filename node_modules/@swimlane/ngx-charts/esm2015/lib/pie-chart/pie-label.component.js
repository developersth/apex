import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { arc } from 'd3-shape';
import { trimLabel } from '../common/trim-label.helper';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["ngx-charts-pie-label", ""];
let PieLabelComponent = class PieLabelComponent {
    constructor() {
        this.animations = true;
        this.labelTrim = true;
        this.labelTrimSize = 10;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.trimLabel = trimLabel;
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        let startRadius = this.radius;
        if (this.explodeSlices) {
            startRadius = (this.radius * this.value) / this.max;
        }
        const innerArc = arc()
            .innerRadius(startRadius)
            .outerRadius(startRadius);
        // Calculate innerPos then scale outer position to match label position
        const innerPos = innerArc.centroid(this.data);
        let scale = this.data.pos[1] / innerPos[1];
        if (this.data.pos[1] === 0 || innerPos[1] === 0) {
            scale = 1;
        }
        const outerPos = [scale * innerPos[0], scale * innerPos[1]];
        this.line = `M${innerPos}L${outerPos}L${this.data.pos}`;
    }
    get textX() {
        return this.data.pos[0];
    }
    get textY() {
        return this.data.pos[1];
    }
    get styleTransform() {
        return this.isIE ? null : `translate3d(${this.textX}px,${this.textY}px, 0)`;
    }
    get attrTransform() {
        return !this.isIE ? null : `translate(${this.textX},${this.textY})`;
    }
    get textTransition() {
        return this.isIE || !this.animations ? null : 'transform 0.75s';
    }
    textAnchor() {
        return this.midAngle(this.data) < Math.PI ? 'start' : 'end';
    }
    midAngle(d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    }
};
PieLabelComponent.ɵfac = function PieLabelComponent_Factory(t) { return new (t || PieLabelComponent)(); };
PieLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieLabelComponent, selectors: [["g", "ngx-charts-pie-label", ""]], inputs: { animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", data: "data", radius: "radius", label: "label", color: "color", max: "max", value: "value", explodeSlices: "explodeSlices" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 6, vars: 17, consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]], template: function PieLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "title");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelementStart(3, "text", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
        ɵngcc0.ɵɵattribute("transform", ctx.attrTransform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵattribute("d", ctx.line)("stroke", ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], PieLabelComponent.prototype, "data", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "radius", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "label", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "color", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "max", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "value", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "explodeSlices", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "animations", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "labelTrim", void 0);
__decorate([
    Input()
], PieLabelComponent.prototype, "labelTrimSize", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-label]',
                template: `
    <title>{{ label }}</title>
    <svg:g [attr.transform]="attrTransform" [style.transform]="styleTransform" [style.transition]="textTransition">
      <svg:text
        class="pie-label"
        [class.animation]="animations"
        dy=".35em"
        [style.textAnchor]="textAnchor()"
        [style.shapeRendering]="'crispEdges'"
      >
        {{ labelTrim ? trimLabel(label, labelTrimSize) : label }}
      </svg:text>
    </svg:g>
    <svg:path
      [attr.d]="line"
      [attr.stroke]="color"
      fill="none"
      class="pie-label-line line"
      [class.animation]="animations"
    ></svg:path>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], data: [{
            type: Input
        }], radius: [{
            type: Input
        }], label: [{
            type: Input
        }], color: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }] }); })();
export { PieLabelComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvcGllLWNoYXJ0L3BpZS1sYWJlbC5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFpREU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5REE4QnVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBMkJuQyIsImZpbGUiOiJwaWUtbGFiZWwuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFyYyB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IHRyaW1MYWJlbCB9IGZyb20gJy4uL2NvbW1vbi90cmltLWxhYmVsLmhlbHBlcic7XG5sZXQgUGllTGFiZWxDb21wb25lbnQgPSBjbGFzcyBQaWVMYWJlbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWxUcmltID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYWJlbFRyaW1TaXplID0gMTA7XG4gICAgICAgIHRoaXMuaXNJRSA9IC8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgdGhpcy50cmltTGFiZWwgPSB0cmltTGFiZWw7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgc3RhcnRSYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgaWYgKHRoaXMuZXhwbG9kZVNsaWNlcykge1xuICAgICAgICAgICAgc3RhcnRSYWRpdXMgPSAodGhpcy5yYWRpdXMgKiB0aGlzLnZhbHVlKSAvIHRoaXMubWF4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlubmVyQXJjID0gYXJjKClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyhzdGFydFJhZGl1cylcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhzdGFydFJhZGl1cyk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbm5lclBvcyB0aGVuIHNjYWxlIG91dGVyIHBvc2l0aW9uIHRvIG1hdGNoIGxhYmVsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGlubmVyUG9zID0gaW5uZXJBcmMuY2VudHJvaWQodGhpcy5kYXRhKTtcbiAgICAgICAgbGV0IHNjYWxlID0gdGhpcy5kYXRhLnBvc1sxXSAvIGlubmVyUG9zWzFdO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnBvc1sxXSA9PT0gMCB8fCBpbm5lclBvc1sxXSA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dGVyUG9zID0gW3NjYWxlICogaW5uZXJQb3NbMF0sIHNjYWxlICogaW5uZXJQb3NbMV1dO1xuICAgICAgICB0aGlzLmxpbmUgPSBgTSR7aW5uZXJQb3N9TCR7b3V0ZXJQb3N9TCR7dGhpcy5kYXRhLnBvc31gO1xuICAgIH1cbiAgICBnZXQgdGV4dFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEucG9zWzBdO1xuICAgIH1cbiAgICBnZXQgdGV4dFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEucG9zWzFdO1xuICAgIH1cbiAgICBnZXQgc3R5bGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSUUgPyBudWxsIDogYHRyYW5zbGF0ZTNkKCR7dGhpcy50ZXh0WH1weCwke3RoaXMudGV4dFl9cHgsIDApYDtcbiAgICB9XG4gICAgZ2V0IGF0dHJUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0lFID8gbnVsbCA6IGB0cmFuc2xhdGUoJHt0aGlzLnRleHRYfSwke3RoaXMudGV4dFl9KWA7XG4gICAgfVxuICAgIGdldCB0ZXh0VHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJRSB8fCAhdGhpcy5hbmltYXRpb25zID8gbnVsbCA6ICd0cmFuc2Zvcm0gMC43NXMnO1xuICAgIH1cbiAgICB0ZXh0QW5jaG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWRBbmdsZSh0aGlzLmRhdGEpIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJztcbiAgICB9XG4gICAgbWlkQW5nbGUoZCkge1xuICAgICAgICByZXR1cm4gZC5zdGFydEFuZ2xlICsgKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gMjtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVNpemVcIiwgdm9pZCAwKTtcblBpZUxhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcGllLWxhYmVsXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHRpdGxlPnt7IGxhYmVsIH19PC90aXRsZT5cbiAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cImF0dHJUcmFuc2Zvcm1cIiBbc3R5bGUudHJhbnNmb3JtXT1cInN0eWxlVHJhbnNmb3JtXCIgW3N0eWxlLnRyYW5zaXRpb25dPVwidGV4dFRyYW5zaXRpb25cIj5cbiAgICAgIDxzdmc6dGV4dFxuICAgICAgICBjbGFzcz1cInBpZS1sYWJlbFwiXG4gICAgICAgIFtjbGFzcy5hbmltYXRpb25dPVwiYW5pbWF0aW9uc1wiXG4gICAgICAgIGR5PVwiLjM1ZW1cIlxuICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XCJ0ZXh0QW5jaG9yKClcIlxuICAgICAgICBbc3R5bGUuc2hhcGVSZW5kZXJpbmddPVwiJ2NyaXNwRWRnZXMnXCJcbiAgICAgID5cbiAgICAgICAge3sgbGFiZWxUcmltID8gdHJpbUxhYmVsKGxhYmVsLCBsYWJlbFRyaW1TaXplKSA6IGxhYmVsIH19XG4gICAgICA8L3N2Zzp0ZXh0PlxuICAgIDwvc3ZnOmc+XG4gICAgPHN2ZzpwYXRoXG4gICAgICBbYXR0ci5kXT1cImxpbmVcIlxuICAgICAgW2F0dHIuc3Ryb2tlXT1cImNvbG9yXCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIGNsYXNzPVwicGllLWxhYmVsLWxpbmUgbGluZVwiXG4gICAgICBbY2xhc3MuYW5pbWF0aW9uXT1cImFuaW1hdGlvbnNcIlxuICAgID48L3N2ZzpwYXRoPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBQaWVMYWJlbENvbXBvbmVudCk7XG5leHBvcnQgeyBQaWVMYWJlbENvbXBvbmVudCB9O1xuIl19