import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ElementRef, OnChanges, ChangeDetectionStrategy } from '@angular/core';
import { select } from 'd3-selection';
import { invertColor } from '../utils/color-utils';
import { trimLabel } from '../common/trim-label.helper';
import { escapeLabel } from '../common/label.helper';
import { id } from '../utils/id';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/svg-linear-gradient.component';
import * as ɵngcc3 from '../common/count/count.directive';

const _c0 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r389 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r389.gradientId)("stops", ctx_r389.gradientStops);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    const ctx_r391 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("countTo", ctx_r391.value)("valueFormatting", ctx_r391.valueFormatting);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r392 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r392.formattedValue, " ");
} }
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "foreignObject", 4);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵelement(2, "span", 5);
    ɵngcc0.ɵɵelement(3, "br");
    ɵngcc0.ɵɵtemplate(4, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template, 1, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(5, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r390 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("pointer-events", "none");
    ɵngcc0.ɵɵattribute("x", ctx_r390.x)("y", ctx_r390.y)("width", ctx_r390.width)("height", ctx_r390.height);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("color", ctx_r390.getTextColor())("height", ctx_r390.height + "px")("width", ctx_r390.width + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r390.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r390.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r390.animations);
} }
let TreeMapCellComponent = class TreeMapCellComponent {
    constructor(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    ngOnChanges() {
        this.update();
        this.valueFormatting = this.valueFormatting || (value => value.toLocaleString());
        const labelFormatting = this.labelFormatting || (cell => escapeLabel(trimLabel(cell.label, 55)));
        const cellData = {
            data: this.data,
            label: this.label,
            value: this.value
        };
        this.formattedValue = this.valueFormatting(cellData.value);
        this.formattedLabel = labelFormatting(cellData);
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = `url(#${this.gradientId})`;
        this.gradientStops = this.getGradientStops();
    }
    update() {
        if (this.initialized) {
            this.animateToCurrentForm();
        }
        else {
            if (this.animations) {
                this.loadAnimation();
            }
            this.initialized = true;
        }
    }
    loadAnimation() {
        const node = select(this.element).select('.cell');
        node
            .attr('opacity', 0)
            .attr('x', this.x)
            .attr('y', this.y);
        this.animateToCurrentForm();
    }
    getTextColor() {
        return invertColor(this.fill);
    }
    animateToCurrentForm() {
        const node = select(this.element).select('.cell');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
        else {
            node
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
    }
    onClick() {
        this.select.emit(this.data);
    }
    getGradientStops() {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: 0.3
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    }
};
TreeMapCellComponent.ɵfac = function TreeMapCellComponent_Factory(t) { return new (t || TreeMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TreeMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellComponent, selectors: [["g", "ngx-charts-tree-map-cell", ""]], inputs: { gradient: "gradient", animations: "animations", valueFormatting: "valueFormatting", data: "data", fill: "fill", x: "x", y: "y", width: "width", height: "height", label: "label", value: "value", valueType: "valueType", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 4, vars: 9, consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]], template: function TreeMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, TreeMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵelementStart(2, "rect", 1);
        ɵngcc0.ɵɵlistener("click", function TreeMapCellComponent_Template__svg_rect_click_2_listener($event) { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("cursor", "pointer");
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.width >= 70 && ctx.height >= 35);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SvgLinearGradientComponent, ɵngcc3.CountUpDirective], encapsulation: 2, changeDetection: 0 });
TreeMapCellComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], TreeMapCellComponent.prototype, "data", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "fill", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "x", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "y", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "width", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "height", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "label", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "value", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "valueType", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "valueFormatting", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "labelFormatting", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "gradient", void 0);
__decorate([
    Input()
], TreeMapCellComponent.prototype, "animations", void 0);
__decorate([
    Output()
], TreeMapCellComponent.prototype, "select", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell]',
                template: `
    <svg:g>
      <defs *ngIf="gradient">
        <svg:g ngx-charts-svg-linear-gradient orientation="vertical" [name]="gradientId" [stops]="gradientStops" />
      </defs>
      <svg:rect
        [attr.fill]="gradient ? gradientUrl : fill"
        [attr.width]="width"
        [attr.height]="height"
        [attr.x]="x"
        [attr.y]="y"
        [style.cursor]="'pointer'"
        class="cell"
        (click)="onClick()"
      />
      <svg:foreignObject
        *ngIf="width >= 70 && height >= 35"
        [attr.x]="x"
        [attr.y]="y"
        [attr.width]="width"
        [attr.height]="height"
        class="treemap-label"
        [style.pointer-events]="'none'"
      >
        <xhtml:p [style.color]="getTextColor()" [style.height]="height + 'px'" [style.width]="width + 'px'">
          <xhtml:span class="treemap-label" [innerHTML]="formattedLabel"> </xhtml:span>
          <xhtml:br />
          <xhtml:span
            *ngIf="animations"
            class="treemap-val"
            ngx-charts-count-up
            [countTo]="value"
            [valueFormatting]="valueFormatting"
          >
          </xhtml:span>
          <xhtml:span *ngIf="!animations" class="treemap-val">
            {{ formattedValue }}
          </xhtml:span>
        </xhtml:p>
      </svg:foreignObject>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], valueFormatting: [{
            type: Input
        }], data: [{
            type: Input
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], valueType: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
export { TreeMapCellComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvdHJlZS1tYXAvdHJlZS1tYXAtY2VsbC5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3SUFtRkU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREE2Q21EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFnRDVCIiwiZmlsZSI6InRyZWUtbWFwLWNlbGwuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBpbnZlcnRDb2xvciB9IGZyb20gJy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcbmltcG9ydCB7IHRyaW1MYWJlbCB9IGZyb20gJy4uL2NvbW1vbi90cmltLWxhYmVsLmhlbHBlcic7XG5pbXBvcnQgeyBlc2NhcGVMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbC5oZWxwZXInO1xuaW1wb3J0IHsgaWQgfSBmcm9tICcuLi91dGlscy9pZCc7XG5sZXQgVHJlZU1hcENlbGxDb21wb25lbnQgPSBjbGFzcyBUcmVlTWFwQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMudmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKHZhbHVlID0+IHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRpbmcgPSB0aGlzLmxhYmVsRm9ybWF0dGluZyB8fCAoY2VsbCA9PiBlc2NhcGVMYWJlbCh0cmltTGFiZWwoY2VsbC5sYWJlbCwgNTUpKSk7XG4gICAgICAgIGNvbnN0IGNlbGxEYXRhID0ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvcm1hdHRlZFZhbHVlID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcoY2VsbERhdGEudmFsdWUpO1xuICAgICAgICB0aGlzLmZvcm1hdHRlZExhYmVsID0gbGFiZWxGb3JtYXR0aW5nKGNlbGxEYXRhKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmdyYWRpZW50VXJsID0gYHVybCgjJHt0aGlzLmdyYWRpZW50SWR9KWA7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnRTdG9wcygpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUb0N1cnJlbnRGb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuY2VsbCcpO1xuICAgICAgICBub2RlXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy55KTtcbiAgICAgICAgdGhpcy5hbmltYXRlVG9DdXJyZW50Rm9ybSgpO1xuICAgIH1cbiAgICBnZXRUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiBpbnZlcnRDb2xvcih0aGlzLmZpbGwpO1xuICAgIH1cbiAgICBhbmltYXRlVG9DdXJyZW50Rm9ybSgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmNlbGwnKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHRoaXMueSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgdGhpcy54KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy55KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIGdldEdyYWRpZW50U3RvcHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC4zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9mZnNldDogMTAwLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn07XG5UcmVlTWFwQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuVHJlZU1hcENlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy10cmVlLW1hcC1jZWxsXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnPlxuICAgICAgPGRlZnMgKm5nSWY9XCJncmFkaWVudFwiPlxuICAgICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1zdmctbGluZWFyLWdyYWRpZW50IG9yaWVudGF0aW9uPVwidmVydGljYWxcIiBbbmFtZV09XCJncmFkaWVudElkXCIgW3N0b3BzXT1cImdyYWRpZW50U3RvcHNcIiAvPlxuICAgICAgPC9kZWZzPlxuICAgICAgPHN2ZzpyZWN0XG4gICAgICAgIFthdHRyLmZpbGxdPVwiZ3JhZGllbnQgPyBncmFkaWVudFVybCA6IGZpbGxcIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmhlaWdodF09XCJoZWlnaHRcIlxuICAgICAgICBbYXR0ci54XT1cInhcIlxuICAgICAgICBbYXR0ci55XT1cInlcIlxuICAgICAgICBbc3R5bGUuY3Vyc29yXT1cIidwb2ludGVyJ1wiXG4gICAgICAgIGNsYXNzPVwiY2VsbFwiXG4gICAgICAgIChjbGljayk9XCJvbkNsaWNrKClcIlxuICAgICAgLz5cbiAgICAgIDxzdmc6Zm9yZWlnbk9iamVjdFxuICAgICAgICAqbmdJZj1cIndpZHRoID49IDcwICYmIGhlaWdodCA+PSAzNVwiXG4gICAgICAgIFthdHRyLnhdPVwieFwiXG4gICAgICAgIFthdHRyLnldPVwieVwiXG4gICAgICAgIFthdHRyLndpZHRoXT1cIndpZHRoXCJcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgICAgIGNsYXNzPVwidHJlZW1hcC1sYWJlbFwiXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XCInbm9uZSdcIlxuICAgICAgPlxuICAgICAgICA8eGh0bWw6cCBbc3R5bGUuY29sb3JdPVwiZ2V0VGV4dENvbG9yKClcIiBbc3R5bGUuaGVpZ2h0XT1cImhlaWdodCArICdweCdcIiBbc3R5bGUud2lkdGhdPVwid2lkdGggKyAncHgnXCI+XG4gICAgICAgICAgPHhodG1sOnNwYW4gY2xhc3M9XCJ0cmVlbWFwLWxhYmVsXCIgW2lubmVySFRNTF09XCJmb3JtYXR0ZWRMYWJlbFwiPiA8L3hodG1sOnNwYW4+XG4gICAgICAgICAgPHhodG1sOmJyIC8+XG4gICAgICAgICAgPHhodG1sOnNwYW5cbiAgICAgICAgICAgICpuZ0lmPVwiYW5pbWF0aW9uc1wiXG4gICAgICAgICAgICBjbGFzcz1cInRyZWVtYXAtdmFsXCJcbiAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcbiAgICAgICAgICAgIFtjb3VudFRvXT1cInZhbHVlXCJcbiAgICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVwidmFsdWVGb3JtYXR0aW5nXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPC94aHRtbDpzcGFuPlxuICAgICAgICAgIDx4aHRtbDpzcGFuICpuZ0lmPVwiIWFuaW1hdGlvbnNcIiBjbGFzcz1cInRyZWVtYXAtdmFsXCI+XG4gICAgICAgICAgICB7eyBmb3JtYXR0ZWRWYWx1ZSB9fVxuICAgICAgICAgIDwveGh0bWw6c3Bhbj5cbiAgICAgICAgPC94aHRtbDpwPlxuICAgICAgPC9zdmc6Zm9yZWlnbk9iamVjdD5cbiAgICA8L3N2ZzpnPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBUcmVlTWFwQ2VsbENvbXBvbmVudCk7XG5leHBvcnQgeyBUcmVlTWFwQ2VsbENvbXBvbmVudCB9O1xuIl19