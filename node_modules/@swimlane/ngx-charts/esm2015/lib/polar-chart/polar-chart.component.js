import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewEncapsulation, ChangeDetectionStrategy, ContentChild } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { scaleLinear, scaleTime, scalePoint } from 'd3-scale';
import { curveCardinalClosed } from 'd3-shape';
import { calculateViewDimensions } from '../common/view-dimensions.helper';
import { ColorHelper } from '../common/color.helper';
import { BaseChartComponent } from '../common/base-chart.component';
import { getScaleType } from '../common/domain.helper';
import { isDate } from '../utils/types';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../common/charts/chart.component';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '../pie-chart/pie-label.component';
import * as ɵngcc4 from '../common/axes/y-axis.component';
import * as ɵngcc5 from '../common/axes/axis-label.component';
import * as ɵngcc6 from './polar-series.component';

const _c0 = ["tooltipTemplate"];
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 8);
} if (rf & 2) {
    const r_r334 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("r", r_r334);
} }
function PolarChartComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r328 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r328.radiusTicks);
} }
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 10);
} if (rf & 2) {
    const tick_r336 = ctx.$implicit;
    const ctx_r335 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("data", tick_r336)("radius", ctx_r335.outerRadius)("label", tick_r336.label)("max", ctx_r335.outerRadius)("value", ctx_r335.showGridLines ? 1 : ctx_r335.outerRadius)("explodeSlices", true)("animations", ctx_r335.animations)("labelTrim", ctx_r335.labelTrim)("labelTrimSize", ctx_r335.labelTrimSize);
} }
function PolarChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r329 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r329.thetaTicks);
} }
function PolarChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    const _r338 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 11);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r338); const ctx_r337 = ɵngcc0.ɵɵnextContext(); return ctx_r337.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r330 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r330.yAxisScale)("dims", ctx_r330.yAxisDims)("showGridLines", ctx_r330.showGridLines)("showLabel", ctx_r330.showYAxisLabel)("labelText", ctx_r330.yAxisLabel)("trimTicks", ctx_r330.trimYAxisTicks)("maxTickLength", ctx_r330.maxYAxisTickLength)("tickFormatting", ctx_r330.yAxisTickFormatting);
    ɵngcc0.ɵɵattribute("transform", ctx_r330.transformYAxis);
} }
function PolarChartComponent__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 12);
} if (rf & 2) {
    const ctx_r331 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r331.xAxisLabel)("offset", ctx_r331.labelOffset)("orient", "bottom")("height", ctx_r331.dims.height)("width", ctx_r331.dims.width);
} }
function PolarChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    const _r341 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function PolarChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r341); const ctx_r340 = ɵngcc0.ɵɵnextContext(); return ctx_r340.onClick($event); })("activate", function PolarChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r341); const ctx_r342 = ɵngcc0.ɵɵnextContext(); return ctx_r342.onActivate($event); })("deactivate", function PolarChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r341); const ctx_r343 = ɵngcc0.ɵɵnextContext(); return ctx_r343.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const series_r339 = ctx.$implicit;
    const ctx_r332 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("gradient", ctx_r332.gradient)("xScale", ctx_r332.xScale)("yScale", ctx_r332.yScale)("colors", ctx_r332.colors)("data", series_r339)("activeEntries", ctx_r332.activeEntries)("scaleType", ctx_r332.scaleType)("curve", ctx_r332.curve)("rangeFillOpacity", ctx_r332.rangeFillOpacity)("animations", ctx_r332.animations)("tooltipDisabled", ctx_r332.tooltipDisabled)("tooltipTemplate", ctx_r332.tooltipTemplate);
} }
const _c1 = function (a0, a1) { return [a0, a1]; };
const twoPI = 2 * Math.PI;
let PolarChartComponent = class PolarChartComponent extends BaseChartComponent {
    constructor() {
        super(...arguments);
        this.legendTitle = 'Legend';
        this.legendPosition = 'right';
        this.showGridLines = true;
        this.curve = curveCardinalClosed;
        this.activeEntries = [];
        this.rangeFillOpacity = 0.15;
        this.trimYAxisTicks = true;
        this.maxYAxisTickLength = 16;
        this.roundDomains = false;
        this.tooltipDisabled = false;
        this.showSeriesOnHover = true;
        this.gradient = false;
        this.yAxisMinScale = 0;
        this.labelTrim = true;
        this.labelTrimSize = 10;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.margin = [10, 20, 10, 20];
        this.xAxisHeight = 0;
        this.yAxisWidth = 0;
    }
    update() {
        super.update();
        this.setDims();
        this.setScales();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.setTicks();
    }
    setDims() {
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        const halfWidth = Math.floor(this.dims.width / 2);
        const halfHeight = Math.floor(this.dims.height / 2);
        const outerRadius = (this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5));
        const yOffset = Math.max(0, halfHeight - outerRadius);
        this.yAxisDims = Object.assign(Object.assign({}, this.dims), { width: halfWidth });
        this.transform = `translate(${this.dims.xOffset}, ${this.margin[0]})`;
        this.transformYAxis = `translate(0, ${yOffset})`;
        this.labelOffset = this.dims.height + 40;
        this.transformPlot = `translate(${halfWidth}, ${halfHeight})`;
    }
    setScales() {
        const xValues = this.getXValues();
        this.scaleType = getScaleType(xValues);
        this.xDomain = this.filteredDomain || this.getXDomain(xValues);
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, twoPI);
        this.yScale = this.getYScale(this.yDomain, this.outerRadius);
        this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
    }
    setTicks() {
        let tickFormat;
        if (this.xAxisTickFormatting) {
            tickFormat = this.xAxisTickFormatting;
        }
        else if (this.xScale.tickFormat) {
            tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
        }
        else {
            tickFormat = d => {
                if (isDate(d)) {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        const outerRadius = this.outerRadius;
        const s = 1.1;
        this.thetaTicks = this.xDomain.map(d => {
            const startAngle = this.xScale(d);
            const dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
            const label = tickFormat(d);
            const startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
            const pos = [dd, s * startPos[1]];
            return {
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle: startAngle,
                value: outerRadius,
                label,
                startPos,
                pos
            };
        });
        const minDistance = 10;
        /* from pie chart, abstract out -*/
        for (let i = 0; i < this.thetaTicks.length - 1; i++) {
            const a = this.thetaTicks[i];
            for (let j = i + 1; j < this.thetaTicks.length; j++) {
                const b = this.thetaTicks[j];
                // if they're on the same side
                if (b.pos[0] * a.pos[0] > 0) {
                    // if they're overlapping
                    const o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        // push the second up or down
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map(d => this.yScale(d));
    }
    getXValues() {
        const values = [];
        for (const results of this.results) {
            for (const d of results.series) {
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        return values;
    }
    getXDomain(values = this.getXValues()) {
        if (this.scaleType === 'time') {
            const min = Math.min(...values);
            const max = Math.max(...values);
            return [min, max];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(v => Number(v));
            const min = Math.min(...values);
            const max = Math.max(...values);
            return [min, max];
        }
        return values;
    }
    getYValues() {
        const domain = [];
        for (const results of this.results) {
            for (const d of results.series) {
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        return domain;
    }
    getYDomain(domain = this.getYValues()) {
        let min = Math.min(...domain);
        const max = Math.max(this.yAxisMinScale, ...domain);
        min = Math.max(0, min);
        if (!this.autoScale) {
            min = Math.min(0, min);
        }
        return [min, max];
    }
    getSeriesDomain() {
        return this.results.map(d => d.name);
    }
    getXScale(domain, width) {
        switch (this.scaleType) {
            case 'time':
                return scaleTime()
                    .range([0, width])
                    .domain(domain);
            case 'linear':
                const scale = scaleLinear()
                    .range([0, width])
                    .domain(domain);
                return this.roundDomains ? scale.nice() : scale;
            default:
                return scalePoint()
                    .range([0, width - twoPI / domain.length])
                    .padding(0)
                    .domain(domain);
        }
    }
    getYScale(domain, height) {
        const scale = scaleLinear()
            .range([0, height])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    }
    onClick(data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    }
    setColors() {
        const domain = this.schemeType === 'ordinal' ? this.seriesDomain : this.yDomain.reverse();
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    }
    getLegendOptions() {
        if (this.schemeType === 'ordinal') {
            return {
                scaleType: this.schemeType,
                colors: this.colors,
                domain: this.seriesDomain,
                title: this.legendTitle,
                position: this.legendPosition
            };
        }
        return {
            scaleType: this.schemeType,
            colors: this.colors.scale,
            domain: this.yDomain,
            title: undefined,
            position: this.legendPosition
        };
    }
    updateYAxisWidth({ width }) {
        this.yAxisWidth = width;
        this.update();
    }
    updateXAxisHeight({ height }) {
        this.xAxisHeight = height;
        this.update();
    }
    onActivate(item) {
        const idx = this.activeEntries.findIndex(d => {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = this.showSeriesOnHover ? [item, ...this.activeEntries] : this.activeEntries;
        this.activate.emit({ value: item, entries: this.activeEntries });
    }
    onDeactivate(item) {
        const idx = this.activeEntries.findIndex(d => {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = [...this.activeEntries];
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    }
    deactivateAll() {
        this.activeEntries = [...this.activeEntries];
        for (const entry of this.activeEntries) {
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    }
    trackBy(index, item) {
        return item.name;
    }
};
PolarChartComponent.ɵfac = function PolarChartComponent_Factory(t) { return ɵPolarChartComponent_BaseFactory(t || PolarChartComponent); };
PolarChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarChartComponent, selectors: [["ngx-charts-polar-chart"]], contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { legendTitle: "legendTitle", legendPosition: "legendPosition", showGridLines: "showGridLines", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", trimYAxisTicks: "trimYAxisTicks", maxYAxisTickLength: "maxYAxisTickLength", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showSeriesOnHover: "showSeriesOnHover", gradient: "gradient", yAxisMinScale: "yAxisMinScale", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", legend: "legend", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", schemeType: "schemeType", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 18, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], ["ngx-charts-polar-series", "", 3, "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function PolarChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵtemplate(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵtemplate(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, PolarChartComponent__svg_g_6_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5);
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, PolarChartComponent__svg_g_9_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(15, _c1, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("r", ctx.outerRadius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGridLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis && ctx.showXAxisLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.ChartComponent, ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc3.PieLabelComponent, ɵngcc4.YAxisComponent, ɵngcc5.AxisLabelComponent, ɵngcc6.PolarSeriesComponent], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{-webkit-animation:750ms ease-in fadeIn;animation:750ms ease-in fadeIn}@-webkit-keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{-webkit-animation:3s linear drawOut;animation:3s linear drawOut;-webkit-transition:d 750ms;transition:d 750ms}@-webkit-keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
__decorate([
    Input()
], PolarChartComponent.prototype, "legend", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "legendTitle", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "legendPosition", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "xAxis", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "yAxis", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "showXAxisLabel", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "showYAxisLabel", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "xAxisLabel", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "yAxisLabel", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "autoScale", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "showGridLines", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "curve", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "activeEntries", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "schemeType", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "rangeFillOpacity", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "trimYAxisTicks", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "maxYAxisTickLength", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "xAxisTickFormatting", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "yAxisTickFormatting", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "roundDomains", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "tooltipDisabled", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "showSeriesOnHover", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "gradient", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "yAxisMinScale", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "labelTrim", void 0);
__decorate([
    Input()
], PolarChartComponent.prototype, "labelTrimSize", void 0);
__decorate([
    Output()
], PolarChartComponent.prototype, "activate", void 0);
__decorate([
    Output()
], PolarChartComponent.prototype, "deactivate", void 0);
__decorate([
    ContentChild('tooltipTemplate')
], PolarChartComponent.prototype, "tooltipTemplate", void 0);
const ɵPolarChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PolarChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-polar-chart',
                template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g class="polar-chart chart" [attr.transform]="transform">
        <svg:g [attr.transform]="transformPlot">
          <svg:circle class="polar-chart-background" cx="0" cy="0" [attr.r]="this.outerRadius" />
          <svg:g *ngIf="showGridLines">
            <svg:circle
              *ngFor="let r of radiusTicks"
              class="gridline-path radial-gridline-path"
              cx="0"
              cy="0"
              [attr.r]="r"
            />
          </svg:g>
          <svg:g *ngIf="xAxis">
            <svg:g
              ngx-charts-pie-label
              *ngFor="let tick of thetaTicks"
              [data]="tick"
              [radius]="outerRadius"
              [label]="tick.label"
              [max]="outerRadius"
              [value]="showGridLines ? 1 : outerRadius"
              [explodeSlices]="true"
              [animations]="animations"
              [labelTrim]="labelTrim"
              [labelTrimSize]="labelTrimSize"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g
          ngx-charts-y-axis
          [attr.transform]="transformYAxis"
          *ngIf="yAxis"
          [yScale]="yAxisScale"
          [dims]="yAxisDims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-axis-label
          *ngIf="xAxis && showXAxisLabel"
          [label]="xAxisLabel"
          [offset]="labelOffset"
          [orient]="'bottom'"
          [height]="dims.height"
          [width]="dims.width"
        ></svg:g>
        <svg:g [attr.transform]="transformPlot">
          <svg:g *ngFor="let series of results; trackBy: trackBy" [@animationState]="'active'">
            <svg:g
              ngx-charts-polar-series
              [gradient]="gradient"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [curve]="curve"
              [rangeFillOpacity]="rangeFillOpacity"
              [animations]="animations"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{-webkit-animation:750ms ease-in fadeIn;animation:750ms ease-in fadeIn}@-webkit-keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{-webkit-animation:3s linear drawOut;animation:3s linear drawOut;-webkit-transition:d 750ms;transition:d 750ms}@-webkit-keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}"]
            }]
    }], null, { legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showSeriesOnHover: [{
            type: Input
        }], gradient: [{
            type: Input
        }], yAxisMinScale: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], legend: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
export { PolarChartComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvcG9sYXItY2hhcnQvcG9sYXItY2hhcnQuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQTRRRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZEQXVGMkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkEyR3JDIiwiZmlsZSI6InBvbGFyLWNoYXJ0LmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBWaWV3RW5jYXBzdWxhdGlvbiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbnRlbnRDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3R5bGUsIGFuaW1hdGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IHNjYWxlTGluZWFyLCBzY2FsZVRpbWUsIHNjYWxlUG9pbnQgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBjdXJ2ZUNhcmRpbmFsQ2xvc2VkIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMgfSBmcm9tICcuLi9jb21tb24vdmlldy1kaW1lbnNpb25zLmhlbHBlcic7XG5pbXBvcnQgeyBDb2xvckhlbHBlciB9IGZyb20gJy4uL2NvbW1vbi9jb2xvci5oZWxwZXInO1xuaW1wb3J0IHsgQmFzZUNoYXJ0Q29tcG9uZW50IH0gZnJvbSAnLi4vY29tbW9uL2Jhc2UtY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IGdldFNjYWxlVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9kb21haW4uaGVscGVyJztcbmltcG9ydCB7IGlzRGF0ZSB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbmNvbnN0IHR3b1BJID0gMiAqIE1hdGguUEk7XG5sZXQgUG9sYXJDaGFydENvbXBvbmVudCA9IGNsYXNzIFBvbGFyQ2hhcnRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ2hhcnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIHRoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmVDYXJkaW5hbENsb3NlZDtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIHRoaXMucmFuZ2VGaWxsT3BhY2l0eSA9IDAuMTU7XG4gICAgICAgIHRoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICB0aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dTZXJpZXNPbkhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlBeGlzTWluU2NhbGUgPSAwO1xuICAgICAgICB0aGlzLmxhYmVsVHJpbSA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWxUcmltU2l6ZSA9IDEwO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuc2V0RGltcygpO1xuICAgICAgICB0aGlzLnNldFNjYWxlcygpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrcygpO1xuICAgIH1cbiAgICBzZXREaW1zKCkge1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuZGltcy53aWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmRpbXMuaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gKHRoaXMub3V0ZXJSYWRpdXMgPSBNYXRoLm1pbihoYWxmSGVpZ2h0IC8gMS41LCBoYWxmV2lkdGggLyAxLjUpKTtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IE1hdGgubWF4KDAsIGhhbGZIZWlnaHQgLSBvdXRlclJhZGl1cyk7XG4gICAgICAgIHRoaXMueUF4aXNEaW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRpbXMpLCB7IHdpZHRoOiBoYWxmV2lkdGggfSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3RoaXMuZGltcy54T2Zmc2V0fSwgJHt0aGlzLm1hcmdpblswXX0pYDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1ZQXhpcyA9IGB0cmFuc2xhdGUoMCwgJHt5T2Zmc2V0fSlgO1xuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gdGhpcy5kaW1zLmhlaWdodCArIDQwO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVBsb3QgPSBgdHJhbnNsYXRlKCR7aGFsZldpZHRofSwgJHtoYWxmSGVpZ2h0fSlgO1xuICAgIH1cbiAgICBzZXRTY2FsZXMoKSB7XG4gICAgICAgIGNvbnN0IHhWYWx1ZXMgPSB0aGlzLmdldFhWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUoeFZhbHVlcyk7XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW4gfHwgdGhpcy5nZXRYRG9tYWluKHhWYWx1ZXMpO1xuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdHdvUEkpO1xuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5vdXRlclJhZGl1cyk7XG4gICAgICAgIHRoaXMueUF4aXNTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbi5yZXZlcnNlKCksIHRoaXMub3V0ZXJSYWRpdXMpO1xuICAgIH1cbiAgICBzZXRUaWNrcygpIHtcbiAgICAgICAgbGV0IHRpY2tGb3JtYXQ7XG4gICAgICAgIGlmICh0aGlzLnhBeGlzVGlja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgIHRpY2tGb3JtYXQgPSB0aGlzLnhBeGlzVGlja0Zvcm1hdHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54U2NhbGUudGlja0Zvcm1hdCkge1xuICAgICAgICAgICAgdGlja0Zvcm1hdCA9IHRoaXMueFNjYWxlLnRpY2tGb3JtYXQuYXBwbHkodGhpcy54U2NhbGUsIFs1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aWNrRm9ybWF0ID0gZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZShkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCBzID0gMS4xO1xuICAgICAgICB0aGlzLnRoZXRhVGlja3MgPSB0aGlzLnhEb21haW4ubWFwKGQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMueFNjYWxlKGQpO1xuICAgICAgICAgICAgY29uc3QgZGQgPSBzICogb3V0ZXJSYWRpdXMgKiAoc3RhcnRBbmdsZSA+IE1hdGguUEkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB0aWNrRm9ybWF0KGQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBbb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSwgLW91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSldO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gW2RkLCBzICogc3RhcnRQb3NbMV1dO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyxcbiAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IDEwO1xuICAgICAgICAvKiBmcm9tIHBpZSBjaGFydCwgYWJzdHJhY3Qgb3V0IC0qL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGhldGFUaWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLnRoZXRhVGlja3NbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB0aGlzLnRoZXRhVGlja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy50aGV0YVRpY2tzW2pdO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkncmUgb24gdGhlIHNhbWUgc2lkZVxuICAgICAgICAgICAgICAgIGlmIChiLnBvc1swXSAqIGEucG9zWzBdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGV5J3JlIG92ZXJsYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBtaW5EaXN0YW5jZSAtIE1hdGguYWJzKGIucG9zWzFdIC0gYS5wb3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIHNlY29uZCB1cCBvciBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBvc1sxXSArPSBNYXRoLnNpZ24oYi5wb3NbMF0pICogbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhZGl1c1RpY2tzID0gdGhpcy55QXhpc1NjYWxlLnRpY2tzKE1hdGguZmxvb3IodGhpcy5kaW1zLmhlaWdodCAvIDUwKSkubWFwKGQgPT4gdGhpcy55U2NhbGUoZCkpO1xuICAgIH1cbiAgICBnZXRYVmFsdWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHRzIG9mIHRoaXMucmVzdWx0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIHJlc3VsdHMuc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXMoZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChkLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBnZXRYRG9tYWluKHZhbHVlcyA9IHRoaXMuZ2V0WFZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4udmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCh2ID0+IE51bWJlcih2KSk7XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4udmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIGdldFlWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdHMgb2YgdGhpcy5yZXN1bHRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcmVzdWx0cy5zZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC52YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZC5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC5taW4pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5taW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1heCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLm1heCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG4gICAgZ2V0WURvbWFpbihkb21haW4gPSB0aGlzLmdldFlWYWx1ZXMoKSkge1xuICAgICAgICBsZXQgbWluID0gTWF0aC5taW4oLi4uZG9tYWluKTtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgodGhpcy55QXhpc01pblNjYWxlLCAuLi5kb21haW4pO1xuICAgICAgICBtaW4gPSBNYXRoLm1heCgwLCBtaW4pO1xuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbigwLCBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgICBnZXRTZXJpZXNEb21haW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGQgPT4gZC5uYW1lKTtcbiAgICB9XG4gICAgZ2V0WFNjYWxlKGRvbWFpbiwgd2lkdGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNjYWxlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlVGltZSgpXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGVQb2ludCgpXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGggLSB0d29QSSAvIGRvbWFpbi5sZW5ndGhdKVxuICAgICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0WVNjYWxlKGRvbWFpbiwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKVxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9XG4gICAgb25DbGljayhkYXRhLCBzZXJpZXMpIHtcbiAgICAgICAgaWYgKHNlcmllcykge1xuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBzZXJpZXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH1cbiAgICBzZXRDb2xvcnMoKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5zZXJpZXNEb21haW4gOiB0aGlzLnlEb21haW4ucmV2ZXJzZSgpO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgICB9XG4gICAgZ2V0TGVnZW5kT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMsXG4gICAgICAgICAgICAgICAgZG9tYWluOiB0aGlzLnNlcmllc0RvbWFpbixcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5sZWdlbmRUaXRsZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLnNjYWxlLFxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnlEb21haW4sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlWUF4aXNXaWR0aCh7IHdpZHRoIH0pIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVhBeGlzSGVpZ2h0KHsgaGVpZ2h0IH0pIHtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgb25BY3RpdmF0ZShpdGVtKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuc2hvd1Nlcmllc09uSG92ZXIgPyBbaXRlbSwgLi4udGhpcy5hY3RpdmVFbnRyaWVzXSA6IHRoaXMuYWN0aXZlRW50cmllcztcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9XG4gICAgb25EZWFjdGl2YXRlKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbLi4udGhpcy5hY3RpdmVFbnRyaWVzXTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH1cbiAgICBkZWFjdGl2YXRlQWxsKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbLi4udGhpcy5hY3RpdmVFbnRyaWVzXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmFjdGl2ZUVudHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICB9XG4gICAgdHJhY2tCeShpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93U2VyaWVzT25Ib3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTWluU2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUcmltU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnKVxuXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Qb2xhckNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXBvbGFyLWNoYXJ0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxuICAgICAgW3ZpZXddPVwiW3dpZHRoLCBoZWlnaHRdXCJcbiAgICAgIFtzaG93TGVnZW5kXT1cImxlZ2VuZFwiXG4gICAgICBbbGVnZW5kT3B0aW9uc109XCJsZWdlbmRPcHRpb25zXCJcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cImFjdGl2ZUVudHJpZXNcIlxuICAgICAgW2FuaW1hdGlvbnNdPVwiYW5pbWF0aW9uc1wiXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XCJvbkNsaWNrKCRldmVudClcIlxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVwib25BY3RpdmF0ZSgkZXZlbnQpXCJcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVwib25EZWFjdGl2YXRlKCRldmVudClcIlxuICAgID5cbiAgICAgIDxzdmc6ZyBjbGFzcz1cInBvbGFyLWNoYXJ0IGNoYXJ0XCIgW2F0dHIudHJhbnNmb3JtXT1cInRyYW5zZm9ybVwiPlxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cInRyYW5zZm9ybVBsb3RcIj5cbiAgICAgICAgICA8c3ZnOmNpcmNsZSBjbGFzcz1cInBvbGFyLWNoYXJ0LWJhY2tncm91bmRcIiBjeD1cIjBcIiBjeT1cIjBcIiBbYXR0ci5yXT1cInRoaXMub3V0ZXJSYWRpdXNcIiAvPlxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cInNob3dHcmlkTGluZXNcIj5cbiAgICAgICAgICAgIDxzdmc6Y2lyY2xlXG4gICAgICAgICAgICAgICpuZ0Zvcj1cImxldCByIG9mIHJhZGl1c1RpY2tzXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJncmlkbGluZS1wYXRoIHJhZGlhbC1ncmlkbGluZS1wYXRoXCJcbiAgICAgICAgICAgICAgY3g9XCIwXCJcbiAgICAgICAgICAgICAgY3k9XCIwXCJcbiAgICAgICAgICAgICAgW2F0dHIucl09XCJyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XCJ4QXhpc1wiPlxuICAgICAgICAgICAgPHN2ZzpnXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtcGllLWxhYmVsXG4gICAgICAgICAgICAgICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRoZXRhVGlja3NcIlxuICAgICAgICAgICAgICBbZGF0YV09XCJ0aWNrXCJcbiAgICAgICAgICAgICAgW3JhZGl1c109XCJvdXRlclJhZGl1c1wiXG4gICAgICAgICAgICAgIFtsYWJlbF09XCJ0aWNrLmxhYmVsXCJcbiAgICAgICAgICAgICAgW21heF09XCJvdXRlclJhZGl1c1wiXG4gICAgICAgICAgICAgIFt2YWx1ZV09XCJzaG93R3JpZExpbmVzID8gMSA6IG91dGVyUmFkaXVzXCJcbiAgICAgICAgICAgICAgW2V4cGxvZGVTbGljZXNdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIlxuICAgICAgICAgICAgICBbbGFiZWxUcmltXT1cImxhYmVsVHJpbVwiXG4gICAgICAgICAgICAgIFtsYWJlbFRyaW1TaXplXT1cImxhYmVsVHJpbVNpemVcIlxuICAgICAgICAgICAgPjwvc3ZnOmc+XG4gICAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgPHN2ZzpnXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVwidHJhbnNmb3JtWUF4aXNcIlxuICAgICAgICAgICpuZ0lmPVwieUF4aXNcIlxuICAgICAgICAgIFt5U2NhbGVdPVwieUF4aXNTY2FsZVwiXG4gICAgICAgICAgW2RpbXNdPVwieUF4aXNEaW1zXCJcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XCJzaG93R3JpZExpbmVzXCJcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cInNob3dZQXhpc0xhYmVsXCJcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cInlBeGlzTGFiZWxcIlxuICAgICAgICAgIFt0cmltVGlja3NdPVwidHJpbVlBeGlzVGlja3NcIlxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cIm1heFlBeGlzVGlja0xlbmd0aFwiXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cInlBeGlzVGlja0Zvcm1hdHRpbmdcIlxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcIlxuICAgICAgICA+PC9zdmc6Zz5cbiAgICAgICAgPHN2ZzpnXG4gICAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXG4gICAgICAgICAgKm5nSWY9XCJ4QXhpcyAmJiBzaG93WEF4aXNMYWJlbFwiXG4gICAgICAgICAgW2xhYmVsXT1cInhBeGlzTGFiZWxcIlxuICAgICAgICAgIFtvZmZzZXRdPVwibGFiZWxPZmZzZXRcIlxuICAgICAgICAgIFtvcmllbnRdPVwiJ2JvdHRvbSdcIlxuICAgICAgICAgIFtoZWlnaHRdPVwiZGltcy5oZWlnaHRcIlxuICAgICAgICAgIFt3aWR0aF09XCJkaW1zLndpZHRoXCJcbiAgICAgICAgPjwvc3ZnOmc+XG4gICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwidHJhbnNmb3JtUGxvdFwiPlxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcIiBbQGFuaW1hdGlvblN0YXRlXT1cIidhY3RpdmUnXCI+XG4gICAgICAgICAgICA8c3ZnOmdcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1wb2xhci1zZXJpZXNcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cImdyYWRpZW50XCJcbiAgICAgICAgICAgICAgW3hTY2FsZV09XCJ4U2NhbGVcIlxuICAgICAgICAgICAgICBbeVNjYWxlXT1cInlTY2FsZVwiXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVwiY29sb3JzXCJcbiAgICAgICAgICAgICAgW2RhdGFdPVwic2VyaWVzXCJcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVwiYWN0aXZlRW50cmllc1wiXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVwic2NhbGVUeXBlXCJcbiAgICAgICAgICAgICAgW2N1cnZlXT1cImN1cnZlXCJcbiAgICAgICAgICAgICAgW3JhbmdlRmlsbE9wYWNpdHldPVwicmFuZ2VGaWxsT3BhY2l0eVwiXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIlxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cInRvb2x0aXBEaXNhYmxlZFwiXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVwidG9vbHRpcFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XCJvbkNsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgICAoYWN0aXZhdGUpPVwib25BY3RpdmF0ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVwib25EZWFjdGl2YXRlKCRldmVudClcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L3N2ZzpnPlxuICAgICAgICA8L3N2ZzpnPlxuICAgICAgPC9zdmc6Zz5cbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XG4gIGAsXG4gICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIucGllLWxhYmVse2ZvbnQtc2l6ZToxMXB4fS5waWUtbGFiZWwuYW5pbWF0aW9uey13ZWJraXQtYW5pbWF0aW9uOjc1MG1zIGVhc2UtaW4gZmFkZUluO2FuaW1hdGlvbjo3NTBtcyBlYXNlLWluIGZhZGVJbn1ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUlue2Zyb217b3BhY2l0eTowfXRve29wYWNpdHk6MX19QGtleWZyYW1lcyBmYWRlSW57ZnJvbXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0ucGllLWxhYmVsLWxpbmV7c3Ryb2tlLWRhc2hhcnJheToxMDAlfS5waWUtbGFiZWwtbGluZS5hbmltYXRpb257LXdlYmtpdC1hbmltYXRpb246M3MgbGluZWFyIGRyYXdPdXQ7YW5pbWF0aW9uOjNzIGxpbmVhciBkcmF3T3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpkIDc1MG1zO3RyYW5zaXRpb246ZCA3NTBtc31ALXdlYmtpdC1rZXlmcmFtZXMgZHJhd091dHtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjEwMCV9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MH19QGtleWZyYW1lcyBkcmF3T3V0e2Zyb217c3Ryb2tlLWRhc2hvZmZzZXQ6MTAwJX10b3tzdHJva2UtZGFzaG9mZnNldDowfX1cIiwgXCIucG9sYXItY2hhcnQgLnBvbGFyLWNoYXJ0LWJhY2tncm91bmR7ZmlsbDpub25lfS5wb2xhci1jaGFydCAucmFkaWFsLWdyaWRsaW5lLXBhdGh7c3Ryb2tlLWRhc2hhcnJheToxMCAxMDtmaWxsOm5vbmV9LnBvbGFyLWNoYXJ0IC5waWUtbGFiZWwtbGluZXtzdHJva2U6IzJmMzY0Nn0ucG9sYXItY2hhcnRzLXNlcmllcyAucG9sYXItc2VyaWVzLWFyZWEsLnBvbGFyLXNlcmllcy1wYXRoe3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdXG4gICAgfSlcbl0sIFBvbGFyQ2hhcnRDb21wb25lbnQpO1xuZXhwb3J0IHsgUG9sYXJDaGFydENvbXBvbmVudCB9O1xuIl19