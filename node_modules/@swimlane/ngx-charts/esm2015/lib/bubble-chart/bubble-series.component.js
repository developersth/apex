import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { formatLabel, escapeLabel } from '../common/label.helper';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/circle.component';
import * as ɵngcc3 from '../common/tooltip/tooltip.directive';

const _c0 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    const _r285 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g");
    ɵngcc0.ɵɵelementStart(2, "g", 1);
    ɵngcc0.ɵɵlistener("select", function BubbleSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r285); const circle_r283 = ctx.$implicit; const ctx_r284 = ɵngcc0.ɵɵnextContext(); return ctx_r284.onClick(circle_r283.data); })("activate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r285); const circle_r283 = ctx.$implicit; const ctx_r286 = ɵngcc0.ɵɵnextContext(); return ctx_r286.activateCircle(circle_r283); })("deactivate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r285); const circle_r283 = ctx.$implicit; const ctx_r287 = ɵngcc0.ɵɵnextContext(); return ctx_r287.deactivateCircle(circle_r283); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const circle_r283 = ctx.$implicit;
    const ctx_r282 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("transform", circle_r283.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("opacity", circle_r283.opacity);
    ɵngcc0.ɵɵclassProp("active", circle_r283.isActive);
    ɵngcc0.ɵɵproperty("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r283.radius)("fill", circle_r283.color)("pointerEvents", "all")("data", circle_r283.value)("classNames", circle_r283.classNames)("tooltipDisabled", ctx_r282.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r282.tooltipTemplate ? undefined : ctx_r282.getTooltipText(circle_r283))("tooltipTemplate", ctx_r282.tooltipTemplate)("tooltipContext", circle_r283.data);
} }
let BubbleSeriesComponent = class BubbleSeriesComponent {
    constructor() {
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.circles = this.getCircles();
    }
    getCircles() {
        const seriesName = this.data.name;
        return this.data.series
            .map((d, i) => {
            if (typeof d.y !== 'undefined' && typeof d.x !== 'undefined') {
                const y = d.y;
                const x = d.x;
                const r = d.r;
                const radius = this.rScale(r || 1);
                const tooltipLabel = formatLabel(d.name);
                const cx = this.xScaleType === 'linear' ? this.xScale(Number(x)) : this.xScale(x);
                const cy = this.yScaleType === 'linear' ? this.yScale(Number(y)) : this.yScale(y);
                const color = this.colors.scaleType === 'linear' ? this.colors.getColor(r) : this.colors.getColor(seriesName);
                const isActive = !this.activeEntries.length ? true : this.isActive({ name: seriesName });
                const opacity = isActive ? 1 : 0.3;
                const data = Object.assign({}, d, {
                    series: seriesName,
                    name: d.name,
                    value: d.y,
                    x: d.x,
                    radius: d.r
                });
                return {
                    data,
                    x,
                    y,
                    r,
                    classNames: [`circle-data-${i}`],
                    value: y,
                    label: x,
                    cx,
                    cy,
                    radius,
                    tooltipLabel,
                    color,
                    opacity,
                    seriesName,
                    isActive,
                    transform: `translate(${cx},${cy})`
                };
            }
        })
            .filter(circle => circle !== undefined);
    }
    getTooltipText(circle) {
        const hasRadius = typeof circle.r !== 'undefined';
        const hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
        const hasSeriesName = circle.seriesName && circle.seriesName.length;
        const radiusValue = hasRadius ? formatLabel(circle.r) : '';
        const xAxisLabel = this.xAxisLabel && this.xAxisLabel !== '' ? `${this.xAxisLabel}:` : '';
        const yAxisLabel = this.yAxisLabel && this.yAxisLabel !== '' ? `${this.yAxisLabel}:` : '';
        const x = formatLabel(circle.x);
        const y = formatLabel(circle.y);
        const name = hasSeriesName && hasTooltipLabel
            ? `${circle.seriesName} • ${circle.tooltipLabel}`
            : circle.seriesName + circle.tooltipLabel;
        const tooltipTitle = hasSeriesName || hasTooltipLabel ? `<span class="tooltip-label">${escapeLabel(name)}</span>` : '';
        return `
      ${tooltipTitle}
      <span class="tooltip-label">
        <label>${escapeLabel(xAxisLabel)}</label> ${escapeLabel(x)}<br />
        <label>${escapeLabel(yAxisLabel)}</label> ${escapeLabel(y)}
      </span>
      <span class="tooltip-val">
        ${escapeLabel(radiusValue)}
      </span>
    `;
    }
    onClick(data) {
        this.select.emit(data);
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find(d => {
            return entry.name === d.name;
        });
        return item !== undefined;
    }
    isVisible(circle) {
        if (this.activeEntries.length > 0) {
            return this.isActive({ name: circle.seriesName });
        }
        return circle.opacity !== 0;
    }
    activateCircle(circle) {
        circle.barVisible = true;
        this.activate.emit({ name: this.data.name });
    }
    deactivateCircle(circle) {
        circle.barVisible = false;
        this.deactivate.emit({ name: this.data.name });
    }
    trackBy(index, circle) {
        return `${circle.data.series} ${circle.data.name}`;
    }
};
BubbleSeriesComponent.ɵfac = function BubbleSeriesComponent_Factory(t) { return new (t || BubbleSeriesComponent)(); };
BubbleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleSeriesComponent, selectors: [["g", "ngx-charts-bubble-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", rScale: "rScale", xScaleType: "xScaleType", yScaleType: "yScaleType", colors: "colors", visibleValue: "visibleValue", activeEntries: "activeEntries", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function BubbleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BubbleSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc2.CircleComponent, ɵngcc3.TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0,
                        transform: 'scale(0)'
                    }),
                    animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                ])
            ])
        ] }, changeDetection: 0 });
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "data", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "xScale", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "yScale", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "rScale", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "xScaleType", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "yScaleType", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "colors", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "visibleValue", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "activeEntries", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "xAxisLabel", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "yAxisLabel", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "tooltipDisabled", void 0);
__decorate([
    Input()
], BubbleSeriesComponent.prototype, "tooltipTemplate", void 0);
__decorate([
    Output()
], BubbleSeriesComponent.prototype, "select", void 0);
__decorate([
    Output()
], BubbleSeriesComponent.prototype, "activate", void 0);
__decorate([
    Output()
], BubbleSeriesComponent.prototype, "deactivate", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bubble-series]',
                template: `
    <svg:g *ngFor="let circle of circles; trackBy: trackBy">
      <svg:g [attr.transform]="circle.transform">
        <svg:g
          ngx-charts-circle
          [@animationState]="'active'"
          class="circle"
          [cx]="0"
          [cy]="0"
          [r]="circle.radius"
          [fill]="circle.color"
          [style.opacity]="circle.opacity"
          [class.active]="circle.isActive"
          [pointerEvents]="'all'"
          [data]="circle.value"
          [classNames]="circle.classNames"
          (select)="onClick(circle.data)"
          (activate)="activateCircle(circle)"
          (deactivate)="deactivateCircle(circle)"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipPlacement]="'top'"
          [tooltipType]="'tooltip'"
          [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="circle.data"
        />
      </svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0,
                                transform: 'scale(0)'
                            }),
                            animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], rScale: [{
            type: Input
        }], xScaleType: [{
            type: Input
        }], yScaleType: [{
            type: Input
        }], colors: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
export { BubbleSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvYnViYmxlLWNoYXJ0L2J1YmJsZS1zZXJpZXMuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBNkdFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MERBZ0R3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBK0NoQyIsImZpbGUiOiJidWJibGUtc2VyaWVzLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3R5bGUsIGFuaW1hdGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IGZvcm1hdExhYmVsLCBlc2NhcGVMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbC5oZWxwZXInO1xubGV0IEJ1YmJsZVNlcmllc0NvbXBvbmVudCA9IGNsYXNzIEJ1YmJsZVNlcmllc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmNpcmNsZXMgPSB0aGlzLmdldENpcmNsZXMoKTtcbiAgICB9XG4gICAgZ2V0Q2lyY2xlcygpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNlcmllc1xuICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLnkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkLnggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGQueTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZC54O1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBkLnI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5yU2NhbGUociB8fCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwTGFiZWwgPSBmb3JtYXRMYWJlbChkLm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN4ID0gdGhpcy54U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IHRoaXMueFNjYWxlKE51bWJlcih4KSkgOiB0aGlzLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjeSA9IHRoaXMueVNjYWxlVHlwZSA9PT0gJ2xpbmVhcicgPyB0aGlzLnlTY2FsZShOdW1iZXIoeSkpIDogdGhpcy55U2NhbGUoeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInID8gdGhpcy5jb2xvcnMuZ2V0Q29sb3IocikgOiB0aGlzLmNvbG9ycy5nZXRDb2xvcihzZXJpZXNOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9ICF0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID8gdHJ1ZSA6IHRoaXMuaXNBY3RpdmUoeyBuYW1lOiBzZXJpZXNOYW1lIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSBpc0FjdGl2ZSA/IDEgOiAwLjM7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnksXG4gICAgICAgICAgICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBkLnJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbYGNpcmNsZS1kYXRhLSR7aX1gXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgICAgICAgICBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3ksXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcExhYmVsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2N4fSwke2N5fSlgXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoY2lyY2xlID0+IGNpcmNsZSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcFRleHQoY2lyY2xlKSB7XG4gICAgICAgIGNvbnN0IGhhc1JhZGl1cyA9IHR5cGVvZiBjaXJjbGUuciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IGhhc1Rvb2x0aXBMYWJlbCA9IGNpcmNsZS50b29sdGlwTGFiZWwgJiYgY2lyY2xlLnRvb2x0aXBMYWJlbC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhhc1Nlcmllc05hbWUgPSBjaXJjbGUuc2VyaWVzTmFtZSAmJiBjaXJjbGUuc2VyaWVzTmFtZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gaGFzUmFkaXVzID8gZm9ybWF0TGFiZWwoY2lyY2xlLnIpIDogJyc7XG4gICAgICAgIGNvbnN0IHhBeGlzTGFiZWwgPSB0aGlzLnhBeGlzTGFiZWwgJiYgdGhpcy54QXhpc0xhYmVsICE9PSAnJyA/IGAke3RoaXMueEF4aXNMYWJlbH06YCA6ICcnO1xuICAgICAgICBjb25zdCB5QXhpc0xhYmVsID0gdGhpcy55QXhpc0xhYmVsICYmIHRoaXMueUF4aXNMYWJlbCAhPT0gJycgPyBgJHt0aGlzLnlBeGlzTGFiZWx9OmAgOiAnJztcbiAgICAgICAgY29uc3QgeCA9IGZvcm1hdExhYmVsKGNpcmNsZS54KTtcbiAgICAgICAgY29uc3QgeSA9IGZvcm1hdExhYmVsKGNpcmNsZS55KTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhhc1Nlcmllc05hbWUgJiYgaGFzVG9vbHRpcExhYmVsXG4gICAgICAgICAgICA/IGAke2NpcmNsZS5zZXJpZXNOYW1lfSDigKIgJHtjaXJjbGUudG9vbHRpcExhYmVsfWBcbiAgICAgICAgICAgIDogY2lyY2xlLnNlcmllc05hbWUgKyBjaXJjbGUudG9vbHRpcExhYmVsO1xuICAgICAgICBjb25zdCB0b29sdGlwVGl0bGUgPSBoYXNTZXJpZXNOYW1lIHx8IGhhc1Rvb2x0aXBMYWJlbCA/IGA8c3BhbiBjbGFzcz1cInRvb2x0aXAtbGFiZWxcIj4ke2VzY2FwZUxhYmVsKG5hbWUpfTwvc3Bhbj5gIDogJyc7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAke3Rvb2x0aXBUaXRsZX1cbiAgICAgIDxzcGFuIGNsYXNzPVwidG9vbHRpcC1sYWJlbFwiPlxuICAgICAgICA8bGFiZWw+JHtlc2NhcGVMYWJlbCh4QXhpc0xhYmVsKX08L2xhYmVsPiAke2VzY2FwZUxhYmVsKHgpfTxiciAvPlxuICAgICAgICA8bGFiZWw+JHtlc2NhcGVMYWJlbCh5QXhpc0xhYmVsKX08L2xhYmVsPiAke2VzY2FwZUxhYmVsKHkpfVxuICAgICAgPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0b29sdGlwLXZhbFwiPlxuICAgICAgICAke2VzY2FwZUxhYmVsKHJhZGl1c1ZhbHVlKX1cbiAgICAgIDwvc3Bhbj5cbiAgICBgO1xuICAgIH1cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9XG4gICAgaXNBY3RpdmUoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1Zpc2libGUoY2lyY2xlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUoeyBuYW1lOiBjaXJjbGUuc2VyaWVzTmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lyY2xlLm9wYWNpdHkgIT09IDA7XG4gICAgfVxuICAgIGFjdGl2YXRlQ2lyY2xlKGNpcmNsZSkge1xuICAgICAgICBjaXJjbGUuYmFyVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMuZGF0YS5uYW1lIH0pO1xuICAgIH1cbiAgICBkZWFjdGl2YXRlQ2lyY2xlKGNpcmNsZSkge1xuICAgICAgICBjaXJjbGUuYmFyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMuZGF0YS5uYW1lIH0pO1xuICAgIH1cbiAgICB0cmFja0J5KGluZGV4LCBjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIGAke2NpcmNsZS5kYXRhLnNlcmllc30gJHtjaXJjbGUuZGF0YS5uYW1lfWA7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInJTY2FsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpXG5dLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKVxuXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG5CdWJibGVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1idWJibGUtc2VyaWVzXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnICpuZ0Zvcj1cImxldCBjaXJjbGUgb2YgY2lyY2xlczsgdHJhY2tCeTogdHJhY2tCeVwiPlxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XCJjaXJjbGUudHJhbnNmb3JtXCI+XG4gICAgICAgIDxzdmc6Z1xuICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlXG4gICAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XCInYWN0aXZlJ1wiXG4gICAgICAgICAgY2xhc3M9XCJjaXJjbGVcIlxuICAgICAgICAgIFtjeF09XCIwXCJcbiAgICAgICAgICBbY3ldPVwiMFwiXG4gICAgICAgICAgW3JdPVwiY2lyY2xlLnJhZGl1c1wiXG4gICAgICAgICAgW2ZpbGxdPVwiY2lyY2xlLmNvbG9yXCJcbiAgICAgICAgICBbc3R5bGUub3BhY2l0eV09XCJjaXJjbGUub3BhY2l0eVwiXG4gICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJjaXJjbGUuaXNBY3RpdmVcIlxuICAgICAgICAgIFtwb2ludGVyRXZlbnRzXT1cIidhbGwnXCJcbiAgICAgICAgICBbZGF0YV09XCJjaXJjbGUudmFsdWVcIlxuICAgICAgICAgIFtjbGFzc05hbWVzXT1cImNpcmNsZS5jbGFzc05hbWVzXCJcbiAgICAgICAgICAoc2VsZWN0KT1cIm9uQ2xpY2soY2lyY2xlLmRhdGEpXCJcbiAgICAgICAgICAoYWN0aXZhdGUpPVwiYWN0aXZhdGVDaXJjbGUoY2lyY2xlKVwiXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVwiZGVhY3RpdmF0ZUNpcmNsZShjaXJjbGUpXCJcbiAgICAgICAgICBuZ3gtdG9vbHRpcFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVwidG9vbHRpcERpc2FibGVkXCJcbiAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XCIndG9wJ1wiXG4gICAgICAgICAgW3Rvb2x0aXBUeXBlXT1cIid0b29sdGlwJ1wiXG4gICAgICAgICAgW3Rvb2x0aXBUaXRsZV09XCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXCJcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cInRvb2x0aXBUZW1wbGF0ZVwiXG4gICAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cImNpcmNsZS5kYXRhXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnOmc+XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJ1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiAnc2NhbGUoMSknIH0pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSlcbl0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudCk7XG5leHBvcnQgeyBCdWJibGVTZXJpZXNDb21wb25lbnQgfTtcbiJdfQ==