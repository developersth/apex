import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, OnChanges, ElementRef, ChangeDetectionStrategy, SimpleChanges } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { select } from 'd3-selection';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["ngx-charts-line", ""];
let LineComponent = class LineComponent {
    constructor(element) {
        this.element = element;
        this.fill = 'none';
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            this.initialized = true;
            this.initialPath = this.path;
        }
        else {
            this.updatePathEl();
        }
    }
    updatePathEl() {
        const node = select(this.element.nativeElement).select('.line');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    }
};
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
LineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animate(1000, style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
LineComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], LineComponent.prototype, "path", void 0);
__decorate([
    Input()
], LineComponent.prototype, "stroke", void 0);
__decorate([
    Input()
], LineComponent.prototype, "data", void 0);
__decorate([
    Input()
], LineComponent.prototype, "fill", void 0);
__decorate([
    Input()
], LineComponent.prototype, "animations", void 0);
__decorate([
    Output()
], LineComponent.prototype, "select", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: `
    <svg:path
      [@animationState]="'active'"
      class="line"
      [attr.d]="initialPath"
      [attr.fill]="fill"
      [attr.stroke]="stroke"
      stroke-width="1.5px"
    />
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animate(1000, style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { fill: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], path: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
export { LineComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvbGluZS1jaGFydC9saW5lLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQTZCRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQXFCNEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkE2QjVCIiwiZmlsZSI6ImxpbmUuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xubGV0IExpbmVDb21wb25lbnQgPSBjbGFzcyBMaW5lQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdub25lJztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsUGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aEVsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUGF0aEVsKCkge1xuICAgICAgICBjb25zdCBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KS5zZWxlY3QoJy5saW5lJyk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDc1MClcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHRoaXMucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkxpbmVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpXG5dLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbkxpbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1saW5lXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpwYXRoXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cIidhY3RpdmUnXCJcbiAgICAgIGNsYXNzPVwibGluZVwiXG4gICAgICBbYXR0ci5kXT1cImluaXRpYWxQYXRoXCJcbiAgICAgIFthdHRyLmZpbGxdPVwiZmlsbFwiXG4gICAgICBbYXR0ci5zdHJva2VdPVwic3Ryb2tlXCJcbiAgICAgIHN0cm9rZS13aWR0aD1cIjEuNXB4XCJcbiAgICAvPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IDIwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAyMDAwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDEwMDAsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF1cbiAgICB9KVxuXSwgTGluZUNvbXBvbmVudCk7XG5leHBvcnQgeyBMaW5lQ29tcG9uZW50IH07XG4iXX0=