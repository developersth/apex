import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const stop_r53 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r53.color)("stop-opacity", stop_r53.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r53.offset + "%");
} }
let SvgRadialGradientComponent = class SvgRadialGradientComponent {
    constructor() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    get stops() {
        return this.stopsInput || this.stopsDefault;
    }
    set stops(value) {
        this.stopsInput = value;
    }
    ngOnChanges(changes) {
        this.r = '30%';
        if ('color' in changes || 'startOpacity' in changes || 'endOpacity' in changes) {
            this.stopsDefault = [
                {
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }
            ];
        }
    }
};
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "color", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "name", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "startOpacity", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "endOpacity", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "cx", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "cy", void 0);
__decorate([
    Input()
], SvgRadialGradientComponent.prototype, "stops", null);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: `
    <svg:radialGradient [id]="name" [attr.cx]="cx" [attr.cy]="cy" [attr.r]="r" gradientUnits="userSpaceOnUse">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:radialGradient>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();
export { SvgRadialGradientComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvY29tbW9uL3N2Zy1yYWRpYWwtZ3JhZGllbnQuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrRUE2QkU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFxQnNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWdCekIiLCJmaWxlIjoic3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xubGV0IFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50ID0gY2xhc3MgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuZE9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLmN4ID0gMDtcbiAgICAgICAgdGhpcy5jeSA9IDA7XG4gICAgfVxuICAgIGdldCBzdG9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHNJbnB1dCB8fCB0aGlzLnN0b3BzRGVmYXVsdDtcbiAgICB9XG4gICAgc2V0IHN0b3BzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcHNJbnB1dCA9IHZhbHVlO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuciA9ICczMCUnO1xuICAgICAgICBpZiAoJ2NvbG9yJyBpbiBjaGFuZ2VzIHx8ICdzdGFydE9wYWNpdHknIGluIGNoYW5nZXMgfHwgJ2VuZE9wYWNpdHknIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcHNEZWZhdWx0ID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGFydE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmVuZE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydE9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRPcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3hcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIG51bGwpO1xuU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1zdmctcmFkaWFsLWdyYWRpZW50XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpyYWRpYWxHcmFkaWVudCBbaWRdPVwibmFtZVwiIFthdHRyLmN4XT1cImN4XCIgW2F0dHIuY3ldPVwiY3lcIiBbYXR0ci5yXT1cInJcIiBncmFkaWVudFVuaXRzPVwidXNlclNwYWNlT25Vc2VcIj5cbiAgICAgIDxzdmc6c3RvcFxuICAgICAgICAqbmdGb3I9XCJsZXQgc3RvcCBvZiBzdG9wc1wiXG4gICAgICAgIFthdHRyLm9mZnNldF09XCJzdG9wLm9mZnNldCArICclJ1wiXG4gICAgICAgIFtzdHlsZS5zdG9wLWNvbG9yXT1cInN0b3AuY29sb3JcIlxuICAgICAgICBbc3R5bGUuc3RvcC1vcGFjaXR5XT1cInN0b3Aub3BhY2l0eVwiXG4gICAgICAvPlxuICAgIDwvc3ZnOnJhZGlhbEdyYWRpZW50PlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCk7XG5leHBvcnQgeyBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCB9O1xuIl19