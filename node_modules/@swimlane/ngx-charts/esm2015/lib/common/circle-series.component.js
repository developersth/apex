import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { formatLabel, escapeLabel } from '../common/label.helper';
import { id } from '../utils/id';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './svg-linear-gradient.component';
import * as ɵngcc3 from './circle.component';
import * as ɵngcc4 from './tooltip/tooltip.directive';

const _c0 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    const ctx_r43 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r43.circle.cx - ctx_r43.circle.radius)("y", ctx_r43.circle.cy)("width", ctx_r43.circle.radius * 2)("height", ctx_r43.circle.height)("fill", ctx_r43.gradientFill);
} }
const _c1 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    const _r45 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); const ctx_r44 = ɵngcc0.ɵɵnextContext(); return ctx_r44.onClick(ctx_r44.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); const ctx_r46 = ɵngcc0.ɵɵnextContext(); return ctx_r46.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); const ctx_r47 = ɵngcc0.ɵɵnextContext(); return ctx_r47.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r42 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r42.gradientId)("stops", ctx_r42.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r42.barVisible && ctx_r42.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r42.isActive(ɵngcc0.ɵɵpureFunction1(18, _c1, ctx_r42.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r42.circle.cx)("cy", ctx_r42.circle.cy)("r", ctx_r42.circle.radius)("fill", ctx_r42.circle.color)("pointerEvents", ctx_r42.circle.value === 0 ? "none" : "all")("data", ctx_r42.circle.value)("classNames", ctx_r42.circle.classNames)("tooltipDisabled", ctx_r42.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r42.tooltipTemplate ? undefined : ctx_r42.getTooltipText(ctx_r42.circle))("tooltipTemplate", ctx_r42.tooltipTemplate)("tooltipContext", ctx_r42.circle.data);
} }
let CircleSeriesComponent = class CircleSeriesComponent {
    constructor() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.barVisible = false;
    }
    ngOnInit() {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = `url(#${this.gradientId})`;
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.circle = this.getActiveCircle();
    }
    getActiveCircle() {
        const indexActiveDataPoint = this.data.series.findIndex(d => {
            const label = d.name;
            return label && this.visibleValue && label.toString() === this.visibleValue.toString() && d.value !== undefined;
        });
        if (indexActiveDataPoint === -1) {
            // No valid point is 'active/hovered over' at this moment.
            return undefined;
        }
        return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
    }
    mapDataPointToCircle(d, i) {
        const seriesName = this.data.name;
        const value = d.value;
        const label = d.name;
        const tooltipLabel = formatLabel(label);
        let cx;
        if (this.scaleType === 'time') {
            cx = this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            cx = this.xScale(Number(label));
        }
        else {
            cx = this.xScale(label);
        }
        const cy = this.yScale(this.type === 'standard' ? value : d.d1);
        const radius = 5;
        const height = this.yScale.range()[0] - cy;
        const opacity = 1;
        let color;
        if (this.colors.scaleType === 'linear') {
            if (this.type === 'standard') {
                color = this.colors.getColor(value);
            }
            else {
                color = this.colors.getColor(d.d1);
            }
        }
        else {
            color = this.colors.getColor(seriesName);
        }
        const data = Object.assign({}, d, {
            series: seriesName,
            value,
            name: label
        });
        return {
            classNames: [`circle-data-${i}`],
            value,
            label,
            data,
            cx,
            cy,
            radius,
            height,
            tooltipLabel,
            color,
            opacity,
            seriesName,
            gradientStops: this.getGradientStops(color),
            min: d.min,
            max: d.max
        };
    }
    getTooltipText({ tooltipLabel, value, seriesName, min, max }) {
        return `
      <span class="tooltip-label">${escapeLabel(seriesName)} • ${escapeLabel(tooltipLabel)}</span>
      <span class="tooltip-val">${value.toLocaleString()}${this.getTooltipMinMaxText(min, max)}</span>
    `;
    }
    getTooltipMinMaxText(min, max) {
        if (min !== undefined || max !== undefined) {
            let result = ' (';
            if (min !== undefined) {
                if (max === undefined) {
                    result += '≥';
                }
                result += min.toLocaleString();
                if (max !== undefined) {
                    result += ' - ';
                }
            }
            else if (max !== undefined) {
                result += '≤';
            }
            if (max !== undefined) {
                result += max.toLocaleString();
            }
            result += ')';
            return result;
        }
        else {
            return '';
        }
    }
    getGradientStops(color) {
        return [
            {
                offset: 0,
                color,
                opacity: 0.2
            },
            {
                offset: 100,
                color,
                opacity: 1
            }
        ];
    }
    onClick(data) {
        this.select.emit(data);
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find(d => {
            return entry.name === d.name;
        });
        return item !== undefined;
    }
    activateCircle() {
        this.barVisible = true;
        this.activate.emit({ name: this.data.name });
    }
    deactivateCircle() {
        this.barVisible = false;
        this.circle.opacity = 0;
        this.deactivate.emit({ name: this.data.name });
    }
};
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SvgLinearGradientComponent, ɵngcc3.CircleComponent, ɵngcc4.TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
__decorate([
    Input()
], CircleSeriesComponent.prototype, "data", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "type", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "xScale", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "yScale", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "colors", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "scaleType", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "visibleValue", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "activeEntries", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "tooltipDisabled", void 0);
__decorate([
    Input()
], CircleSeriesComponent.prototype, "tooltipTemplate", void 0);
__decorate([
    Output()
], CircleSeriesComponent.prototype, "select", void 0);
__decorate([
    Output()
], CircleSeriesComponent.prototype, "activate", void 0);
__decorate([
    Output()
], CircleSeriesComponent.prototype, "deactivate", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: `
    <svg:g *ngIf="circle">
      <defs>
        <svg:g
          ngx-charts-svg-linear-gradient
          orientation="vertical"
          [name]="gradientId"
          [stops]="circle.gradientStops"
        />
      </defs>
      <svg:rect
        *ngIf="barVisible && type === 'standard'"
        [@animationState]="'active'"
        [attr.x]="circle.cx - circle.radius"
        [attr.y]="circle.cy"
        [attr.width]="circle.radius * 2"
        [attr.height]="circle.height"
        [attr.fill]="gradientFill"
        class="tooltip-bar"
      />
      <svg:g
        ngx-charts-circle
        class="circle"
        [cx]="circle.cx"
        [cy]="circle.cy"
        [r]="circle.radius"
        [fill]="circle.color"
        [class.active]="isActive({ name: circle.seriesName })"
        [pointerEvents]="circle.value === 0 ? 'none' : 'all'"
        [data]="circle.value"
        [classNames]="circle.classNames"
        (select)="onClick(circle.data)"
        (activate)="activateCircle()"
        (deactivate)="deactivateCircle()"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="'top'"
        [tooltipType]="'tooltip'"
        [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="circle.data"
      />
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
export { CircleSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvY29tbW9uL2NpcmNsZS1zZXJpZXMuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQXFKRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQXVDd0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkE0RGhDIiwiZmlsZSI6ImNpcmNsZS1zZXJpZXMuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgZm9ybWF0TGFiZWwsIGVzY2FwZUxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsLmhlbHBlcic7XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4uL3V0aWxzL2lkJztcbmxldCBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSBjbGFzcyBDaXJjbGVTZXJpZXNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhbmRhcmQnO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJhclZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBgdXJsKCMke3RoaXMuZ3JhZGllbnRJZH0pYDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuY2lyY2xlID0gdGhpcy5nZXRBY3RpdmVDaXJjbGUoKTtcbiAgICB9XG4gICAgZ2V0QWN0aXZlQ2lyY2xlKCkge1xuICAgICAgICBjb25zdCBpbmRleEFjdGl2ZURhdGFQb2ludCA9IHRoaXMuZGF0YS5zZXJpZXMuZmluZEluZGV4KGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgJiYgdGhpcy52aXNpYmxlVmFsdWUgJiYgbGFiZWwudG9TdHJpbmcoKSA9PT0gdGhpcy52aXNpYmxlVmFsdWUudG9TdHJpbmcoKSAmJiBkLnZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXhBY3RpdmVEYXRhUG9pbnQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBObyB2YWxpZCBwb2ludCBpcyAnYWN0aXZlL2hvdmVyZWQgb3ZlcicgYXQgdGhpcyBtb21lbnQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcERhdGFQb2ludFRvQ2lyY2xlKHRoaXMuZGF0YS5zZXJpZXNbaW5kZXhBY3RpdmVEYXRhUG9pbnRdLCBpbmRleEFjdGl2ZURhdGFQb2ludCk7XG4gICAgfVxuICAgIG1hcERhdGFQb2ludFRvQ2lyY2xlKGQsIGkpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZC5uYW1lO1xuICAgICAgICBjb25zdCB0b29sdGlwTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICAgIGxldCBjeDtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgY3ggPSB0aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN5ID0gdGhpcy55U2NhbGUodGhpcy50eXBlID09PSAnc3RhbmRhcmQnID8gdmFsdWUgOiBkLmQxKTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gNTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy55U2NhbGUucmFuZ2UoKVswXSAtIGN5O1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gMTtcbiAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICBpZiAodGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihkLmQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3Ioc2VyaWVzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbmFtZTogbGFiZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbYGNpcmNsZS1kYXRhLSR7aX1gXSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY3gsXG4gICAgICAgICAgICBjeSxcbiAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHRvb2x0aXBMYWJlbCxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgIHNlcmllc05hbWUsXG4gICAgICAgICAgICBncmFkaWVudFN0b3BzOiB0aGlzLmdldEdyYWRpZW50U3RvcHMoY29sb3IpLFxuICAgICAgICAgICAgbWluOiBkLm1pbixcbiAgICAgICAgICAgIG1heDogZC5tYXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcFRleHQoeyB0b29sdGlwTGFiZWwsIHZhbHVlLCBzZXJpZXNOYW1lLCBtaW4sIG1heCB9KSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgICA8c3BhbiBjbGFzcz1cInRvb2x0aXAtbGFiZWxcIj4ke2VzY2FwZUxhYmVsKHNlcmllc05hbWUpfSDigKIgJHtlc2NhcGVMYWJlbCh0b29sdGlwTGFiZWwpfTwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidG9vbHRpcC12YWxcIj4ke3ZhbHVlLnRvTG9jYWxlU3RyaW5nKCl9JHt0aGlzLmdldFRvb2x0aXBNaW5NYXhUZXh0KG1pbiwgbWF4KX08L3NwYW4+XG4gICAgYDtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcE1pbk1heFRleHQobWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkIHx8IG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyAoJztcbiAgICAgICAgICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ+KJpSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtaW4udG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1heC50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcpJztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R3JhZGllbnRTdG9wcyhjb2xvcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9XG4gICAgaXNBY3RpdmUoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhY3RpdmF0ZUNpcmNsZSgpIHtcbiAgICAgICAgdGhpcy5iYXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5kYXRhLm5hbWUgfSk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGVDaXJjbGUoKSB7XG4gICAgICAgIHRoaXMuYmFyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpcmNsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpXG5dLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbkNpcmNsZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNdJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOmcgKm5nSWY9XCJjaXJjbGVcIj5cbiAgICAgIDxkZWZzPlxuICAgICAgICA8c3ZnOmdcbiAgICAgICAgICBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnRcbiAgICAgICAgICBvcmllbnRhdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICBbbmFtZV09XCJncmFkaWVudElkXCJcbiAgICAgICAgICBbc3RvcHNdPVwiY2lyY2xlLmdyYWRpZW50U3RvcHNcIlxuICAgICAgICAvPlxuICAgICAgPC9kZWZzPlxuICAgICAgPHN2ZzpyZWN0XG4gICAgICAgICpuZ0lmPVwiYmFyVmlzaWJsZSAmJiB0eXBlID09PSAnc3RhbmRhcmQnXCJcbiAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XCInYWN0aXZlJ1wiXG4gICAgICAgIFthdHRyLnhdPVwiY2lyY2xlLmN4IC0gY2lyY2xlLnJhZGl1c1wiXG4gICAgICAgIFthdHRyLnldPVwiY2lyY2xlLmN5XCJcbiAgICAgICAgW2F0dHIud2lkdGhdPVwiY2lyY2xlLnJhZGl1cyAqIDJcIlxuICAgICAgICBbYXR0ci5oZWlnaHRdPVwiY2lyY2xlLmhlaWdodFwiXG4gICAgICAgIFthdHRyLmZpbGxdPVwiZ3JhZGllbnRGaWxsXCJcbiAgICAgICAgY2xhc3M9XCJ0b29sdGlwLWJhclwiXG4gICAgICAvPlxuICAgICAgPHN2ZzpnXG4gICAgICAgIG5neC1jaGFydHMtY2lyY2xlXG4gICAgICAgIGNsYXNzPVwiY2lyY2xlXCJcbiAgICAgICAgW2N4XT1cImNpcmNsZS5jeFwiXG4gICAgICAgIFtjeV09XCJjaXJjbGUuY3lcIlxuICAgICAgICBbcl09XCJjaXJjbGUucmFkaXVzXCJcbiAgICAgICAgW2ZpbGxdPVwiY2lyY2xlLmNvbG9yXCJcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJpc0FjdGl2ZSh7IG5hbWU6IGNpcmNsZS5zZXJpZXNOYW1lIH0pXCJcbiAgICAgICAgW3BvaW50ZXJFdmVudHNdPVwiY2lyY2xlLnZhbHVlID09PSAwID8gJ25vbmUnIDogJ2FsbCdcIlxuICAgICAgICBbZGF0YV09XCJjaXJjbGUudmFsdWVcIlxuICAgICAgICBbY2xhc3NOYW1lc109XCJjaXJjbGUuY2xhc3NOYW1lc1wiXG4gICAgICAgIChzZWxlY3QpPVwib25DbGljayhjaXJjbGUuZGF0YSlcIlxuICAgICAgICAoYWN0aXZhdGUpPVwiYWN0aXZhdGVDaXJjbGUoKVwiXG4gICAgICAgIChkZWFjdGl2YXRlKT1cImRlYWN0aXZhdGVDaXJjbGUoKVwiXG4gICAgICAgIG5neC10b29sdGlwXG4gICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVwidG9vbHRpcERpc2FibGVkXCJcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVwiJ3RvcCdcIlxuICAgICAgICBbdG9vbHRpcFR5cGVdPVwiJ3Rvb2x0aXAnXCJcbiAgICAgICAgW3Rvb2x0aXBUaXRsZV09XCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXCJcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XCJ0b29sdGlwVGVtcGxhdGVcIlxuICAgICAgICBbdG9vbHRpcENvbnRleHRdPVwiY2lyY2xlLmRhdGFcIlxuICAgICAgLz5cbiAgICA8L3N2ZzpnPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSlcbl0sIENpcmNsZVNlcmllc0NvbXBvbmVudCk7XG5leHBvcnQgeyBDaXJjbGVTZXJpZXNDb21wb25lbnQgfTtcbiJdfQ==