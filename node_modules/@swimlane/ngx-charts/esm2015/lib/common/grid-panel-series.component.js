import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './grid-panel.component';

const _c0 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 1);
} if (rf & 2) {
    const gridPanel_r49 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("grid-panel", true)("odd", gridPanel_r49.class === "odd")("even", gridPanel_r49.class === "even");
    ɵngcc0.ɵɵproperty("height", gridPanel_r49.height)("width", gridPanel_r49.width)("x", gridPanel_r49.x)("y", gridPanel_r49.y);
} }
let GridPanelSeriesComponent = class GridPanelSeriesComponent {
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.gridPanels = this.getGridPanels();
    }
    getGridPanels() {
        return this.data.map(d => {
            let offset;
            let width;
            let height;
            let x;
            let y;
            let className = 'odd';
            if (this.orient === 'vertical') {
                const position = this.xScale(d.name);
                const positionIndex = Number.parseInt((position / this.xScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = this.xScale.bandwidth() * this.xScale.paddingInner();
                width = this.xScale.bandwidth() + offset;
                height = this.dims.height;
                x = this.xScale(d.name) - offset / 2;
                y = 0;
            }
            else if (this.orient === 'horizontal') {
                const position = this.yScale(d.name);
                const positionIndex = Number.parseInt((position / this.yScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = this.yScale.bandwidth() * this.yScale.paddingInner();
                width = this.dims.width;
                height = this.yScale.bandwidth() + offset;
                x = 0;
                y = this.yScale(d.name) - offset / 2;
            }
            return {
                name: d.name,
                class: className,
                height,
                width,
                x,
                y
            };
        });
    }
};
GridPanelSeriesComponent.ɵfac = function GridPanelSeriesComponent_Factory(t) { return new (t || GridPanelSeriesComponent)(); };
GridPanelSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelSeriesComponent, selectors: [["g", "ngx-charts-grid-panel-series", ""]], inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale", orient: "orient" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 1, consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]], template: function GridPanelSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.gridPanels);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc2.GridPanelComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], GridPanelSeriesComponent.prototype, "data", void 0);
__decorate([
    Input()
], GridPanelSeriesComponent.prototype, "dims", void 0);
__decorate([
    Input()
], GridPanelSeriesComponent.prototype, "xScale", void 0);
__decorate([
    Input()
], GridPanelSeriesComponent.prototype, "yScale", void 0);
__decorate([
    Input()
], GridPanelSeriesComponent.prototype, "orient", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridPanelSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel-series]',
                template: `
    <svg:g
      ngx-charts-grid-panel
      *ngFor="let gridPanel of gridPanels"
      [height]="gridPanel.height"
      [width]="gridPanel.width"
      [x]="gridPanel.x"
      [y]="gridPanel.y"
      [class.grid-panel]="true"
      [class.odd]="gridPanel.class === 'odd'"
      [class.even]="gridPanel.class === 'even'"
    ></svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { data: [{
            type: Input
        }], dims: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], orient: [{
            type: Input
        }] }); })();
export { GridPanelSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvY29tbW9uL2dyaWQtcGFuZWwtc2VyaWVzLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEdBaURFOzs7Ozs7Ozs7Ozs7Ozs7eURBZXVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBbUI1QiIsImZpbGUiOiJncmlkLXBhbmVsLXNlcmllcy5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xubGV0IEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCA9IGNsYXNzIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCB7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZ3JpZFBhbmVscyA9IHRoaXMuZ2V0R3JpZFBhbmVscygpO1xuICAgIH1cbiAgICBnZXRHcmlkUGFuZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChkID0+IHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSAnb2RkJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy54U2NhbGUoZC5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkluZGV4ID0gTnVtYmVyLnBhcnNlSW50KChwb3NpdGlvbiAvIHRoaXMueFNjYWxlLnN0ZXAoKSkudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkluZGV4ICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAnZXZlbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMueFNjYWxlLmJhbmR3aWR0aCgpICogdGhpcy54U2NhbGUucGFkZGluZ0lubmVyKCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmRpbXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLnhTY2FsZShkLm5hbWUpIC0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMueVNjYWxlKGQubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25JbmRleCA9IE51bWJlci5wYXJzZUludCgocG9zaXRpb24gLyB0aGlzLnlTY2FsZS5zdGVwKCkpLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2V2ZW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSAqIHRoaXMueVNjYWxlLnBhZGRpbmdJbm5lcigpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMueVNjYWxlLmJhbmR3aWR0aCgpICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSB0aGlzLnlTY2FsZShkLm5hbWUpIC0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50XCIsIHZvaWQgMCk7XG5HcmlkUGFuZWxTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1ncmlkLXBhbmVsLXNlcmllc10nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6Z1xuICAgICAgbmd4LWNoYXJ0cy1ncmlkLXBhbmVsXG4gICAgICAqbmdGb3I9XCJsZXQgZ3JpZFBhbmVsIG9mIGdyaWRQYW5lbHNcIlxuICAgICAgW2hlaWdodF09XCJncmlkUGFuZWwuaGVpZ2h0XCJcbiAgICAgIFt3aWR0aF09XCJncmlkUGFuZWwud2lkdGhcIlxuICAgICAgW3hdPVwiZ3JpZFBhbmVsLnhcIlxuICAgICAgW3ldPVwiZ3JpZFBhbmVsLnlcIlxuICAgICAgW2NsYXNzLmdyaWQtcGFuZWxdPVwidHJ1ZVwiXG4gICAgICBbY2xhc3Mub2RkXT1cImdyaWRQYW5lbC5jbGFzcyA9PT0gJ29kZCdcIlxuICAgICAgW2NsYXNzLmV2ZW5dPVwiZ3JpZFBhbmVsLmNsYXNzID09PSAnZXZlbidcIlxuICAgID48L3N2ZzpnPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQpO1xuZXhwb3J0IHsgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50IH07XG4iXX0=