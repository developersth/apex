import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { area } from 'd3-shape';
import { sortLinear, sortByTime, sortByDomain } from '../utils/sort';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../common/area.component';

const _c0 = ["ngx-charts-area-series", ""];
let AreaSeriesComponent = class AreaSeriesComponent {
    constructor() {
        this.baseValue = 'auto';
        this.stacked = false;
        this.normalized = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.updateGradient();
        let currentArea;
        let startingArea;
        const xProperty = d => {
            const label = d.name;
            return this.xScale(label);
        };
        if (this.stacked || this.normalized) {
            currentArea = area()
                .x(xProperty)
                .y0((d, i) => this.yScale(d.d0))
                .y1((d, i) => this.yScale(d.d1));
            startingArea = area()
                .x(xProperty)
                .y0(d => this.yScale.range()[0])
                .y1(d => this.yScale.range()[0]);
        }
        else {
            currentArea = area()
                .x(xProperty)
                .y0(() => (this.baseValue === 'auto' ? this.yScale.range()[0] : this.yScale(this.baseValue)))
                .y1(d => this.yScale(d.value));
            startingArea = area()
                .x(xProperty)
                .y0(d => (this.baseValue === 'auto' ? this.yScale.range()[0] : this.yScale(this.baseValue)))
                .y1(d => (this.baseValue === 'auto' ? this.yScale.range()[0] : this.yScale(this.baseValue)));
        }
        currentArea.curve(this.curve);
        startingArea.curve(this.curve);
        this.opacity = 0.8;
        let data = this.data.series;
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        this.path = currentArea(data);
        this.startingPath = startingArea(data);
    }
    updateGradient() {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            if (this.stacked || this.normalized) {
                const d0values = this.data.series.map(d => d.d0);
                const d1values = this.data.series.map(d => d.d1);
                const max = Math.max(...d1values);
                const min = Math.min(...d0values);
                this.gradientStops = this.colors.getLinearGradientStops(max, min);
            }
            else {
                const values = this.data.series.map(d => d.value);
                const max = Math.max(...values);
                this.gradientStops = this.colors.getLinearGradientStops(max);
            }
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
        }
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find(d => {
            return entry.name === d.name;
        });
        return item !== undefined;
    }
    isInactive(entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        const item = this.activeEntries.find(d => {
            return entry.name === d.name;
        });
        return item === undefined;
    }
};
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [ɵngcc1.AreaComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], AreaSeriesComponent.prototype, "data", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "xScale", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "yScale", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "baseValue", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "colors", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "scaleType", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "stacked", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "normalized", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "gradient", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "curve", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "activeEntries", void 0);
__decorate([
    Input()
], AreaSeriesComponent.prototype, "animations", void 0);
__decorate([
    Output()
], AreaSeriesComponent.prototype, "select", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: `
    <svg:g
      ngx-charts-area
      class="area-series"
      [data]="data"
      [path]="path"
      [fill]="colors.getColor(data.name)"
      [stops]="gradientStops"
      [startingPath]="startingPath"
      [opacity]="opacity"
      [gradient]="gradient || hasGradient"
      [animations]="animations"
      [class.active]="isActive(data)"
      [class.inactive]="isInactive(data)"
    />
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: Input
        }], stacked: [{
            type: Input
        }], normalized: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
export { AreaSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtMjAxNS9saWIvYXJlYS1jaGFydC9hcmVhLXNlcmllcy5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUZBNEZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBdUNrRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFzQjVCIiwiZmlsZSI6ImFyZWEtc2VyaWVzLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgYXJlYSB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IHNvcnRMaW5lYXIsIHNvcnRCeVRpbWUsIHNvcnRCeURvbWFpbiB9IGZyb20gJy4uL3V0aWxzL3NvcnQnO1xubGV0IEFyZWFTZXJpZXNDb21wb25lbnQgPSBjbGFzcyBBcmVhU2VyaWVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iYXNlVmFsdWUgPSAnYXV0byc7XG4gICAgICAgIHRoaXMuc3RhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUdyYWRpZW50KCk7XG4gICAgICAgIGxldCBjdXJyZW50QXJlYTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nQXJlYTtcbiAgICAgICAgY29uc3QgeFByb3BlcnR5ID0gZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhTY2FsZShsYWJlbCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YWNrZWQgfHwgdGhpcy5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjdXJyZW50QXJlYSA9IGFyZWEoKVxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAueTAoKGQsIGkpID0+IHRoaXMueVNjYWxlKGQuZDApKVxuICAgICAgICAgICAgICAgIC55MSgoZCwgaSkgPT4gdGhpcy55U2NhbGUoZC5kMSkpO1xuICAgICAgICAgICAgc3RhcnRpbmdBcmVhID0gYXJlYSgpXG4gICAgICAgICAgICAgICAgLngoeFByb3BlcnR5KVxuICAgICAgICAgICAgICAgIC55MChkID0+IHRoaXMueVNjYWxlLnJhbmdlKClbMF0pXG4gICAgICAgICAgICAgICAgLnkxKGQgPT4gdGhpcy55U2NhbGUucmFuZ2UoKVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50QXJlYSA9IGFyZWEoKVxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAueTAoKCkgPT4gKHRoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyB0aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogdGhpcy55U2NhbGUodGhpcy5iYXNlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICAueTEoZCA9PiB0aGlzLnlTY2FsZShkLnZhbHVlKSk7XG4gICAgICAgICAgICBzdGFydGluZ0FyZWEgPSBhcmVhKClcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXG4gICAgICAgICAgICAgICAgLnkwKGQgPT4gKHRoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyB0aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogdGhpcy55U2NhbGUodGhpcy5iYXNlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICAueTEoZCA9PiAodGhpcy5iYXNlVmFsdWUgPT09ICdhdXRvJyA/IHRoaXMueVNjYWxlLnJhbmdlKClbMF0gOiB0aGlzLnlTY2FsZSh0aGlzLmJhc2VWYWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJlYS5jdXJ2ZSh0aGlzLmN1cnZlKTtcbiAgICAgICAgc3RhcnRpbmdBcmVhLmN1cnZlKHRoaXMuY3VydmUpO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAwLjg7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhLnNlcmllcztcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeURvbWFpbihkYXRhLCAnbmFtZScsICdhc2MnLCB0aGlzLnhTY2FsZS5kb21haW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRoID0gY3VycmVudEFyZWEoZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhcnRpbmdQYXRoID0gc3RhcnRpbmdBcmVhKGRhdGEpO1xuICAgIH1cbiAgICB1cGRhdGVHcmFkaWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkMHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGQgPT4gZC5kMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZDF2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChkID0+IGQuZDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLmQxdmFsdWVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5kMHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgsIG1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChkID0+IGQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQWN0aXZlKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNJbmFjdGl2ZShlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcyB8fCB0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2VWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInN0YWNrZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuQXJlYVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnXG4gICAgICBuZ3gtY2hhcnRzLWFyZWFcbiAgICAgIGNsYXNzPVwiYXJlYS1zZXJpZXNcIlxuICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICBbcGF0aF09XCJwYXRoXCJcbiAgICAgIFtmaWxsXT1cImNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXCJcbiAgICAgIFtzdG9wc109XCJncmFkaWVudFN0b3BzXCJcbiAgICAgIFtzdGFydGluZ1BhdGhdPVwic3RhcnRpbmdQYXRoXCJcbiAgICAgIFtvcGFjaXR5XT1cIm9wYWNpdHlcIlxuICAgICAgW2dyYWRpZW50XT1cImdyYWRpZW50IHx8IGhhc0dyYWRpZW50XCJcbiAgICAgIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIlxuICAgICAgW2NsYXNzLmFjdGl2ZV09XCJpc0FjdGl2ZShkYXRhKVwiXG4gICAgICBbY2xhc3MuaW5hY3RpdmVdPVwiaXNJbmFjdGl2ZShkYXRhKVwiXG4gICAgLz5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KVxuXSwgQXJlYVNlcmllc0NvbXBvbmVudCk7XG5leHBvcnQgeyBBcmVhU2VyaWVzQ29tcG9uZW50IH07XG4iXX0=