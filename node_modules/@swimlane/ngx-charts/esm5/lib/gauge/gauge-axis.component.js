import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { line } from 'd3-shape';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r413 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r413.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r414 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r414.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r414.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r414.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r415 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r415.line);
} }
var GaugeAxisComponent = /** @class */ (function () {
    function GaugeAxisComponent() {
        this.rotate = '';
    }
    GaugeAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GaugeAxisComponent.prototype.update = function () {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = "rotate(" + this.rotationAngle + ")";
        this.ticks = this.getTicks();
    };
    GaugeAxisComponent.prototype.getTicks = function () {
        var bigTickSegment = this.angleSpan / this.bigSegments;
        var smallTickSegment = bigTickSegment / this.smallSegments;
        var tickLength = 20;
        var ticks = {
            big: [],
            small: []
        };
        var startDistance = this.radius + 10;
        var textDist = startDistance + tickLength + 10;
        for (var i = 0; i <= this.bigSegments; i++) {
            var angleDeg = i * bigTickSegment;
            var angle = (angleDeg * Math.PI) / 180;
            var textAnchor = this.getTextAnchor(angleDeg);
            var skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                var text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor: textAnchor,
                    text: text,
                    textTransform: "\n            translate(" + textDist * Math.cos(angle) + ", " + textDist * Math.sin(angle) + ") rotate(" + -this.rotationAngle + ")\n          "
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (var j = 1; j <= this.smallSegments; j++) {
                var smallAngleDeg = angleDeg + j * smallTickSegment;
                var smallAngle = (smallAngleDeg * Math.PI) / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    };
    GaugeAxisComponent.prototype.getTextAnchor = function (angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        var textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    };
    GaugeAxisComponent.prototype.getTickPath = function (startDistance, tickLength, angle) {
        var y1 = startDistance * Math.sin(angle);
        var y2 = (startDistance + tickLength) * Math.sin(angle);
        var x1 = startDistance * Math.cos(angle);
        var x2 = (startDistance + tickLength) * Math.cos(angle);
        var points = [
            { x: x1, y: y1 },
            { x: x2, y: y2 }
        ];
        var lineGenerator = line()
            .x(function (d) { return d.x; })
            .y(function (d) { return d.y; });
        return lineGenerator(points);
    };
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "min", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "max", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "startAngle", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "radius", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "valueScale", void 0);
    __decorate([
        Input()
    ], GaugeAxisComponent.prototype, "tickFormatting", void 0);
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: "\n    <svg:g [attr.transform]=\"rotate\">\n      <svg:g *ngFor=\"let tick of ticks.big\" class=\"gauge-tick gauge-tick-large\">\n        <svg:path [attr.d]=\"tick.line\" />\n      </svg:g>\n      <svg:g *ngFor=\"let tick of ticks.big\" class=\"gauge-tick gauge-tick-large\">\n        <svg:text\n          [style.textAnchor]=\"tick.textAnchor\"\n          [attr.transform]=\"tick.textTransform\"\n          alignment-baseline=\"central\"\n        >\n          {{ tick.text }}\n        </svg:text>\n      </svg:g>\n      <svg:g *ngFor=\"let tick of ticks.small\" class=\"gauge-tick gauge-tick-small\">\n        <svg:path [attr.d]=\"tick.line\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
    return GaugeAxisComponent;
}());
export { GaugeAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvZ2F1Z2UvZ2F1Z2UtYXhpcy5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrREE4RytEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU9wQyIsImZpbGUiOiJnYXVnZS1heGlzLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBsaW5lIH0gZnJvbSAnZDMtc2hhcGUnO1xudmFyIEdhdWdlQXhpc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXVnZUF4aXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMucm90YXRlID0gJyc7XG4gICAgfVxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm90YXRpb25BbmdsZSA9IC05MCArIHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSBcInJvdGF0ZShcIiArIHRoaXMucm90YXRpb25BbmdsZSArIFwiKVwiO1xuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICAgIH07XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUaWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpZ1RpY2tTZWdtZW50ID0gdGhpcy5hbmdsZVNwYW4gLyB0aGlzLmJpZ1NlZ21lbnRzO1xuICAgICAgICB2YXIgc21hbGxUaWNrU2VnbWVudCA9IGJpZ1RpY2tTZWdtZW50IC8gdGhpcy5zbWFsbFNlZ21lbnRzO1xuICAgICAgICB2YXIgdGlja0xlbmd0aCA9IDIwO1xuICAgICAgICB2YXIgdGlja3MgPSB7XG4gICAgICAgICAgICBiaWc6IFtdLFxuICAgICAgICAgICAgc21hbGw6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydERpc3RhbmNlID0gdGhpcy5yYWRpdXMgKyAxMDtcbiAgICAgICAgdmFyIHRleHREaXN0ID0gc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGggKyAxMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5iaWdTZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGVEZWcgPSBpICogYmlnVGlja1NlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAoYW5nbGVEZWcgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICAgICAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5nZXRUZXh0QW5jaG9yKGFuZ2xlRGVnKTtcbiAgICAgICAgICAgIHZhciBza2lwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmFuZ2xlU3BhbiA9PT0gMzYwKSB7XG4gICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMudmFsdWVTY2FsZS5pbnZlcnQoYW5nbGVEZWcpLnRvU3RyaW5nKCkpLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMudGlja0Zvcm1hdHRpbmcodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpY2tzLmJpZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm06IFwiXFxuICAgICAgICAgICAgdHJhbnNsYXRlKFwiICsgdGV4dERpc3QgKiBNYXRoLmNvcyhhbmdsZSkgKyBcIiwgXCIgKyB0ZXh0RGlzdCAqIE1hdGguc2luKGFuZ2xlKSArIFwiKSByb3RhdGUoXCIgKyAtdGhpcy5yb3RhdGlvbkFuZ2xlICsgXCIpXFxuICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5iaWdTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gdGhpcy5zbWFsbFNlZ21lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxBbmdsZURlZyA9IGFuZ2xlRGVnICsgaiAqIHNtYWxsVGlja1NlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQW5nbGUgPSAoc21hbGxBbmdsZURlZyAqIE1hdGguUEkpIC8gMTgwO1xuICAgICAgICAgICAgICAgIHRpY2tzLnNtYWxsLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmdldFRpY2tQYXRoKHN0YXJ0RGlzdGFuY2UsIHRpY2tMZW5ndGggLyAyLCBzbWFsbEFuZ2xlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGV4dEFuY2hvciA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAvLyBbMCwgNDVdID0gJ21pZGRsZSc7XG4gICAgICAgIC8vIFs0NiwgMTM1XSA9ICdzdGFydCc7XG4gICAgICAgIC8vIFsxMzYsIDIyNV0gPSAnbWlkZGxlJztcbiAgICAgICAgLy8gWzIyNiwgMzE1XSA9ICdlbmQnO1xuICAgICAgICBhbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyBhbmdsZSkgJSAzNjA7XG4gICAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgIGlmIChhbmdsZSA+IDQ1ICYmIGFuZ2xlIDw9IDEzNSkge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5nbGUgPiAyMjUgJiYgYW5nbGUgPD0gMzE1KSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRBbmNob3I7XG4gICAgfTtcbiAgICBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLmdldFRpY2tQYXRoID0gZnVuY3Rpb24gKHN0YXJ0RGlzdGFuY2UsIHRpY2tMZW5ndGgsIGFuZ2xlKSB7XG4gICAgICAgIHZhciB5MSA9IHN0YXJ0RGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHZhciB5MiA9IChzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHZhciB4MSA9IHN0YXJ0RGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciB4MiA9IChzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgICAgICB7IHg6IHgxLCB5OiB5MSB9LFxuICAgICAgICAgICAgeyB4OiB4MiwgeTogeTIgfVxuICAgICAgICBdO1xuICAgICAgICB2YXIgbGluZUdlbmVyYXRvciA9IGxpbmUoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnk7IH0pO1xuICAgICAgICByZXR1cm4gbGluZUdlbmVyYXRvcihwb2ludHMpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImJpZ1NlZ21lbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNtYWxsU2VnbWVudHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmdsZVNwYW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIEdhdWdlQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ2F1Z2UtYXhpc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJyb3RhdGVcXFwiPlxcbiAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRpY2tzLmJpZ1xcXCIgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVxcXCI+XFxuICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XFxcInRpY2subGluZVxcXCIgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRpY2tzLmJpZ1xcXCIgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVxcXCI+XFxuICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCJ0aWNrLnRleHRBbmNob3JcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpY2sudGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJjZW50cmFsXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICB7eyB0aWNrLnRleHQgfX1cXG4gICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrcy5zbWFsbFxcXCIgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1zbWFsbFxcXCI+XFxuICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XFxcInRpY2subGluZVxcXCIgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIEdhdWdlQXhpc0NvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBHYXVnZUF4aXNDb21wb25lbnQgfTtcbiJdfQ==