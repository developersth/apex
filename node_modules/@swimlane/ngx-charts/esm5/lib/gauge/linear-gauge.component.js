import { __decorate, __extends } from "tslib";
import { Component, Input, ViewChild, ViewEncapsulation, ChangeDetectionStrategy } from '@angular/core';
import { scaleLinear } from 'd3-scale';
import { BaseChartComponent } from '../common/base-chart.component';
import { calculateViewDimensions } from '../common/view-dimensions.helper';
import { ColorHelper } from '../common/color.helper';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../common/charts/chart.component';
import * as ɵngcc2 from '../bar-chart/bar.component';
import * as ɵngcc3 from '@angular/common';

var _c0 = ["valueTextEl"];
var _c1 = ["unitsTextEl"];
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 10);
} if (rf & 2) {
    var ctx_r397 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r397.transformLine)("stroke", ctx_r397.colors.getColor(ctx_r397.units));
} }
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 11);
} if (rf & 2) {
    var ctx_r398 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r398.transformLine)("stroke", ctx_r398.colors.getColor(ctx_r398.units));
} }
var _c2 = function (a0, a1) { return [a0, a1]; };
var _c3 = function () { return {}; };
var LinearGaugeComponent = /** @class */ (function (_super) {
    __extends(LinearGaugeComponent, _super);
    function LinearGaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.min = 0;
        _this.max = 100;
        _this.value = 0;
        _this.margin = [10, 20, 10, 20];
        _this.valueResizeScale = 1;
        _this.unitsResizeScale = 1;
        _this.valueTextTransform = '';
        _this.valueTranslate = '';
        _this.unitsTextTransform = '';
        _this.unitsTranslate = '';
        return _this;
    }
    LinearGaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () {
            _this.scaleText('value');
            _this.scaleText('units');
        });
    };
    LinearGaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.hasPreviousValue = this.previousValue !== undefined;
        this.max = Math.max(this.max, this.value);
        this.min = Math.min(this.min, this.value);
        if (this.hasPreviousValue) {
            this.max = Math.max(this.max, this.previousValue);
            this.min = Math.min(this.min, this.previousValue);
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.transformLine = "translate(" + (this.margin[3] + this.valueScale(this.previousValue)) + ", " + yOffset + ")";
        this.valueTranslate = "translate(0, -15)";
        this.unitsTranslate = "translate(0, 15)";
        setTimeout(function () { return _this.scaleText('value'); }, 50);
        setTimeout(function () { return _this.scaleText('units'); }, 50);
    };
    LinearGaugeComponent.prototype.getValueDomain = function () {
        return [this.min, this.max];
    };
    LinearGaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
    };
    LinearGaugeComponent.prototype.getDisplayValue = function () {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.value.toLocaleString();
    };
    LinearGaugeComponent.prototype.scaleText = function (element, repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        var el;
        var resizeScale;
        if (element === 'value') {
            el = this.valueTextEl;
            resizeScale = this.valueResizeScale;
        }
        else {
            el = this.unitsTextEl;
            resizeScale = this.unitsResizeScale;
        }
        var _a = el.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
        if (width === 0 || height === 0)
            return;
        var oldScale = resizeScale;
        var availableWidth = this.dims.width;
        var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
        var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
        var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
        resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
        if (resizeScale !== oldScale) {
            if (element === 'value') {
                this.valueResizeScale = resizeScale;
                this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            else {
                this.unitsResizeScale = resizeScale;
                this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () {
                    _this.scaleText(element, false);
                }, 50);
            }
        }
    };
    LinearGaugeComponent.prototype.onClick = function () {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    };
    LinearGaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', [this.value], this.customColors);
    };
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "min", void 0);
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "max", void 0);
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "value", void 0);
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "units", void 0);
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "previousValue", void 0);
    __decorate([
        Input()
    ], LinearGaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        ViewChild('valueTextEl')
    ], LinearGaugeComponent.prototype, "valueTextEl", void 0);
    __decorate([
        ViewChild('unitsTextEl')
    ], LinearGaugeComponent.prototype, "unitsTextEl", void 0);
LinearGaugeComponent.ɵfac = function LinearGaugeComponent_Factory(t) { return ɵLinearGaugeComponent_BaseFactory(t || LinearGaugeComponent); };
LinearGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["ngx-charts-linear-gauge"]], viewQuery: function LinearGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.unitsTextEl = _t.first);
    } }, inputs: { max: "max", min: "min", value: "value", units: "units", previousValue: "previousValue", valueFormatting: "valueFormatting" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 38, consts: [[3, "view", "showLegend", "animations", "click"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["valueTextEl", ""], ["alignment-baseline", "before-edge", 1, "units"], ["unitsTextEl", ""], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener($event) { return ctx.onClick(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵelement(3, "g", 3);
        ɵngcc0.ɵɵtemplate(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 4);
        ɵngcc0.ɵɵtemplate(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 5);
        ɵngcc0.ɵɵelementStart(6, "g");
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵelementStart(8, "text", 6, 7);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "g");
        ɵngcc0.ɵɵelementStart(12, "text", 8, 9);
        ɵngcc0.ɵɵtext(14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(33, _c2, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", ɵngcc0.ɵɵpureFunction0(36, _c3))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", ɵngcc0.ɵɵpureFunction0(37, _c3))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.valueTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.valueTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.units, " ");
    } }, directives: [ɵngcc1.ChartComponent, ɵngcc2.BarComponent, ɵngcc3.NgIf], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"], encapsulation: 2, changeDetection: 0 });
var ɵLinearGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LinearGaugeComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-linear-gauge',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\" (click)=\"onClick()\">\n      <svg:g class=\"linear-gauge chart\">\n        <svg:g\n          ngx-charts-bar\n          class=\"background-bar\"\n          [width]=\"dims.width\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-bar\n          [width]=\"valueScale(value)\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [fill]=\"colors.getColor(units)\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"5\"\n          x2=\"0\"\n          y2=\"15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"-5\"\n          x2=\"0\"\n          y2=\"-15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:g [attr.transform]=\"transform\">\n          <svg:g [attr.transform]=\"valueTranslate\">\n            <svg:text\n              #valueTextEl\n              class=\"value\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"valueTextTransform\"\n              alignment-baseline=\"after-edge\"\n            >\n              {{ displayValue }}\n            </svg:text>\n          </svg:g>\n\n          <svg:g [attr.transform]=\"unitsTranslate\">\n            <svg:text\n              #unitsTextEl\n              class=\"units\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"unitsTextTransform\"\n              alignment-baseline=\"before-edge\"\n            >\n              {{ units }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{-webkit-transition:opacity .1s ease-in-out;transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"]
            }]
    }], null, { max: [{
            type: Input
        }], min: [{
            type: Input
        }], value: [{
            type: Input
        }], units: [{
            type: Input
        }], previousValue: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], valueTextEl: [{
            type: ViewChild,
            args: ['valueTextEl']
        }], unitsTextEl: [{
            type: ViewChild,
            args: ['unitsTextEl']
        }] }); })();
    return LinearGaugeComponent;
}(BaseChartComponent));
export { LinearGaugeComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvZ2F1Z2UvbGluZWFyLWdhdWdlLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OERBeUk4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVNqQyIsImZpbGUiOiJsaW5lYXItZ2F1Z2UuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBWaWV3Q2hpbGQsIFZpZXdFbmNhcHN1bGF0aW9uLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBCYXNlQ2hhcnRDb21wb25lbnQgfSBmcm9tICcuLi9jb21tb24vYmFzZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMgfSBmcm9tICcuLi9jb21tb24vdmlldy1kaW1lbnNpb25zLmhlbHBlcic7XG5pbXBvcnQgeyBDb2xvckhlbHBlciB9IGZyb20gJy4uL2NvbW1vbi9jb2xvci5oZWxwZXInO1xudmFyIExpbmVhckdhdWdlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lYXJHYXVnZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJHYXVnZUNvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1pbiA9IDA7XG4gICAgICAgIF90aGlzLm1heCA9IDEwMDtcbiAgICAgICAgX3RoaXMudmFsdWUgPSAwO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICBfdGhpcy52YWx1ZVJlc2l6ZVNjYWxlID0gMTtcbiAgICAgICAgX3RoaXMudW5pdHNSZXNpemVTY2FsZSA9IDE7XG4gICAgICAgIF90aGlzLnZhbHVlVGV4dFRyYW5zZm9ybSA9ICcnO1xuICAgICAgICBfdGhpcy52YWx1ZVRyYW5zbGF0ZSA9ICcnO1xuICAgICAgICBfdGhpcy51bml0c1RleHRUcmFuc2Zvcm0gPSAnJztcbiAgICAgICAgX3RoaXMudW5pdHNUcmFuc2xhdGUgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dCgndmFsdWUnKTtcbiAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dCgndW5pdHMnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmhhc1ByZXZpb3VzVmFsdWUgPSB0aGlzLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5oYXNQcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLnByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZVNjYWxlID0gdGhpcy5nZXRWYWx1ZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5nZXREaXNwbGF5VmFsdWUoKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLm1hcmdpblszXSArIHRoaXMuZGltcy53aWR0aCAvIDI7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXQgKyBcIiwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTGluZSA9IFwidHJhbnNsYXRlKFwiICsgKHRoaXMubWFyZ2luWzNdICsgdGhpcy52YWx1ZVNjYWxlKHRoaXMucHJldmlvdXNWYWx1ZSkpICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xuICAgICAgICB0aGlzLnZhbHVlVHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoMCwgLTE1KVwiO1xuICAgICAgICB0aGlzLnVuaXRzVHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoMCwgMTUpXCI7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCd2YWx1ZScpOyB9LCA1MCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCd1bml0cycpOyB9LCA1MCk7XG4gICAgfTtcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5taW4sIHRoaXMubWF4XTtcbiAgICB9O1xuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcbiAgICB9O1xuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXREaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlRm9ybWF0dGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVGb3JtYXR0aW5nKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfTtcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuc2NhbGVUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlcGVhdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmVwZWF0ID09PSB2b2lkIDApIHsgcmVwZWF0ID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgZWw7XG4gICAgICAgIHZhciByZXNpemVTY2FsZTtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy52YWx1ZVRleHRFbDtcbiAgICAgICAgICAgIHJlc2l6ZVNjYWxlID0gdGhpcy52YWx1ZVJlc2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwgPSB0aGlzLnVuaXRzVGV4dEVsO1xuICAgICAgICAgICAgcmVzaXplU2NhbGUgPSB0aGlzLnVuaXRzUmVzaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb2xkU2NhbGUgPSByZXNpemVTY2FsZTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5kaW1zLmhlaWdodCAvIDIgLSAxNSwgMCk7XG4gICAgICAgIHZhciByZXNpemVTY2FsZVdpZHRoID0gTWF0aC5mbG9vcigoYXZhaWxhYmxlV2lkdGggLyAod2lkdGggLyByZXNpemVTY2FsZSkpICogMTAwKSAvIDEwMDtcbiAgICAgICAgdmFyIHJlc2l6ZVNjYWxlSGVpZ2h0ID0gTWF0aC5mbG9vcigoYXZhaWxhYmxlSGVpZ2h0IC8gKGhlaWdodCAvIHJlc2l6ZVNjYWxlKSkgKiAxMDApIC8gMTAwO1xuICAgICAgICByZXNpemVTY2FsZSA9IE1hdGgubWluKHJlc2l6ZVNjYWxlSGVpZ2h0LCByZXNpemVTY2FsZVdpZHRoKTtcbiAgICAgICAgaWYgKHJlc2l6ZVNjYWxlICE9PSBvbGRTY2FsZSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUmVzaXplU2NhbGUgPSByZXNpemVTY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlVGV4dFRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyByZXNpemVTY2FsZSArIFwiLCBcIiArIHJlc2l6ZVNjYWxlICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXRzUmVzaXplU2NhbGUgPSByZXNpemVTY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXRzVGV4dFRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyByZXNpemVTY2FsZSArIFwiLCBcIiArIHJlc2l6ZVNjYWxlICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY2FsZVRleHQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoe1xuICAgICAgICAgICAgbmFtZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgW3RoaXMudmFsdWVdLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInVuaXRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJldmlvdXNWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBWaWV3Q2hpbGQoJ3ZhbHVlVGV4dEVsJylcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVUZXh0RWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKCd1bml0c1RleHRFbCcpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInVuaXRzVGV4dEVsXCIsIHZvaWQgMCk7XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1saW5lYXItZ2F1Z2UnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiIChjbGljayk9XFxcIm9uQ2xpY2soKVxcXCI+XFxuICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJsaW5lYXItZ2F1Z2UgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgICAgIGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWJhclxcXCJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgICAgW2hlaWdodF09XFxcIjNcXFwiXFxuICAgICAgICAgIFt4XT1cXFwibWFyZ2luWzNdXFxcIlxcbiAgICAgICAgICBbeV09XFxcImRpbXMuaGVpZ2h0IC8gMiArIG1hcmdpblswXSAtIDJcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwie31cXFwiXFxuICAgICAgICAgIFtvcmllbnRhdGlvbl09XFxcIidob3Jpem9udGFsJ1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWJhclxcbiAgICAgICAgICBbd2lkdGhdPVxcXCJ2YWx1ZVNjYWxlKHZhbHVlKVxcXCJcXG4gICAgICAgICAgW2hlaWdodF09XFxcIjNcXFwiXFxuICAgICAgICAgIFt4XT1cXFwibWFyZ2luWzNdXFxcIlxcbiAgICAgICAgICBbeV09XFxcImRpbXMuaGVpZ2h0IC8gMiArIG1hcmdpblswXSAtIDJcXFwiXFxuICAgICAgICAgIFtmaWxsXT1cXFwiY29sb3JzLmdldENvbG9yKHVuaXRzKVxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJ7fVxcXCJcXG4gICAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgICAgICBbcm91bmRFZGdlc109XFxcInRydWVcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcblxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICpuZ0lmPVxcXCJoYXNQcmV2aW91c1ZhbHVlXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1MaW5lXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgeTE9XFxcIjVcXFwiXFxuICAgICAgICAgIHgyPVxcXCIwXFxcIlxcbiAgICAgICAgICB5Mj1cXFwiMTVcXFwiXFxuICAgICAgICAgIFthdHRyLnN0cm9rZV09XFxcImNvbG9ycy5nZXRDb2xvcih1bml0cylcXFwiXFxuICAgICAgICAvPlxcblxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICpuZ0lmPVxcXCJoYXNQcmV2aW91c1ZhbHVlXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1MaW5lXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgeTE9XFxcIi01XFxcIlxcbiAgICAgICAgICB4Mj1cXFwiMFxcXCJcXG4gICAgICAgICAgeTI9XFxcIi0xNVxcXCJcXG4gICAgICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwiY29sb3JzLmdldENvbG9yKHVuaXRzKVxcXCJcXG4gICAgICAgIC8+XFxuXFxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInZhbHVlVHJhbnNsYXRlXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAgICN2YWx1ZVRleHRFbFxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCInbWlkZGxlJ1xcXCJcXG4gICAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInZhbHVlVGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiYWZ0ZXItZWRnZVxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICB7eyBkaXNwbGF5VmFsdWUgfX1cXG4gICAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidW5pdHNUcmFuc2xhdGVcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICAgI3VuaXRzVGV4dEVsXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwidW5pdHNcXFwiXFxuICAgICAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcIidtaWRkbGUnXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidW5pdHNUZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJiZWZvcmUtZWRnZVxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICB7eyB1bml0cyB9fVxcbiAgICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLmxpbmVhci1nYXVnZXtjdXJzb3I6cG9pbnRlcn0ubGluZWFyLWdhdWdlIC5iYWNrZ3JvdW5kLWJhciBwYXRoe2ZpbGw6cmdiYSgwLDAsMCwuMDUpfS5saW5lYXItZ2F1Z2UgLnVuaXRze2ZpbGw6IzY2Nn1cIl1cbiAgICAgICAgfSlcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIExpbmVhckdhdWdlQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcbmV4cG9ydCB7IExpbmVhckdhdWdlQ29tcG9uZW50IH07XG4iXX0=