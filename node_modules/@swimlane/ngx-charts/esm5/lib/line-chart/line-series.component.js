import { __decorate, __read, __spread } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { area, line } from 'd3-shape';
import { id } from '../utils/id';
import { sortLinear, sortByTime, sortByDomain } from '../utils/sort';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/area.component';
import * as ɵngcc3 from './line.component';
import * as ɵngcc4 from '../common/svg-linear-gradient.component';

var _c0 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r326 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r326.gradientId)("stops", ctx_r326.gradientStops);
} }
function LineSeriesComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 5);
} if (rf & 2) {
    var ctx_r327 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r327.isActive(ctx_r327.data))("inactive", ctx_r327.isInactive(ctx_r327.data));
    ɵngcc0.ɵɵproperty("data", ctx_r327.data)("path", ctx_r327.outerPath)("fill", ctx_r327.hasGradient ? ctx_r327.gradientUrl : ctx_r327.colors.getColor(ctx_r327.data.name))("opacity", ctx_r327.rangeFillOpacity)("animations", ctx_r327.animations);
} }
var LineSeriesComponent = /** @class */ (function () {
    function LineSeriesComponent() {
        this.animations = true;
    }
    LineSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LineSeriesComponent.prototype.update = function () {
        this.updateGradients();
        var data = this.sortData(this.data.series);
        var lineGen = this.getLineGenerator();
        this.path = lineGen(data) || '';
        var areaGen = this.getAreaGenerator();
        this.areaPath = areaGen(data) || '';
        if (this.hasRange) {
            var range = this.getRangeGenerator();
            this.outerPath = range(data) || '';
        }
        if (this.hasGradient) {
            this.stroke = this.gradientUrl;
            var values = this.data.series.map(function (d) { return d.value; });
            var max = Math.max.apply(Math, __spread(values));
            var min = Math.min.apply(Math, __spread(values));
            if (max === min) {
                this.stroke = this.colors.getColor(max);
            }
        }
        else {
            this.stroke = this.colors.getColor(this.data.name);
        }
    };
    LineSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return line()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getRangeGenerator = function () {
        var _this = this;
        return area()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y0(function (d) { return _this.yScale(typeof d.min === 'number' ? d.min : d.value); })
            .y1(function (d) { return _this.yScale(typeof d.max === 'number' ? d.max : d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getAreaGenerator = function () {
        var _this = this;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        return area()
            .x(xProperty)
            .y0(function () { return _this.yScale.range()[0]; })
            .y1(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        return data;
    };
    LineSeriesComponent.prototype.updateGradients = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            var values = this.data.series.map(function (d) { return d.value; });
            var max = Math.max.apply(Math, __spread(values));
            var min = Math.min.apply(Math, __spread(values));
            this.gradientStops = this.colors.getLinearGradientStops(max, min);
            this.areaGradientStops = this.colors.getLinearGradientStops(max);
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
            this.areaGradientStops = undefined;
        }
    };
    LineSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    LineSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "hasRange", void 0);
    __decorate([
        Input()
    ], LineSeriesComponent.prototype, "animations", void 0);
LineSeriesComponent.ɵfac = function LineSeriesComponent_Factory(t) { return new (t || LineSeriesComponent)(); };
LineSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineSeriesComponent, selectors: [["g", "ngx-charts-line-series", ""]], inputs: { animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", hasRange: "hasRange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 6, vars: 22, consts: [["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]], template: function LineSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, LineSeriesComponent__svg_g_2_Template, 1, 2, "g", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 1);
        ɵngcc0.ɵɵelement(4, "g", 2);
        ɵngcc0.ɵɵtemplate(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRange);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.AreaComponent, ɵngcc3.LineComponent, ɵngcc4.SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line-series]',
                template: "\n    <svg:g>\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-area\n        class=\"line-highlight\"\n        [data]=\"data\"\n        [path]=\"areaPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [opacity]=\"0.25\"\n        [startOpacity]=\"0\"\n        [gradient]=\"true\"\n        [stops]=\"areaGradientStops\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-line\n        class=\"line-series\"\n        [data]=\"data\"\n        [path]=\"path\"\n        [stroke]=\"stroke\"\n        [animations]=\"animations\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n      />\n      <svg:g\n        ngx-charts-area\n        *ngIf=\"hasRange\"\n        class=\"line-series-range\"\n        [data]=\"data\"\n        [path]=\"outerPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [opacity]=\"rangeFillOpacity\"\n        [animations]=\"animations\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], hasRange: [{
            type: Input
        }] }); })();
    return LineSeriesComponent;
}());
export { LineSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvbGluZS1jaGFydC9saW5lLXNlcmllcy5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0REE4SjREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT2hDIiwiZmlsZSI6ImxpbmUtc2VyaWVzLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUsIF9fcmVhZCwgX19zcHJlYWQgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhcmVhLCBsaW5lIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgaWQgfSBmcm9tICcuLi91dGlscy9pZCc7XG5pbXBvcnQgeyBzb3J0TGluZWFyLCBzb3J0QnlUaW1lLCBzb3J0QnlEb21haW4gfSBmcm9tICcuLi91dGlscy9zb3J0JztcbnZhciBMaW5lU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVTZXJpZXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgfVxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFkaWVudHMoKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNvcnREYXRhKHRoaXMuZGF0YS5zZXJpZXMpO1xuICAgICAgICB2YXIgbGluZUdlbiA9IHRoaXMuZ2V0TGluZUdlbmVyYXRvcigpO1xuICAgICAgICB0aGlzLnBhdGggPSBsaW5lR2VuKGRhdGEpIHx8ICcnO1xuICAgICAgICB2YXIgYXJlYUdlbiA9IHRoaXMuZ2V0QXJlYUdlbmVyYXRvcigpO1xuICAgICAgICB0aGlzLmFyZWFQYXRoID0gYXJlYUdlbihkYXRhKSB8fCAnJztcbiAgICAgICAgaWYgKHRoaXMuaGFzUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZXJQYXRoID0gcmFuZ2UoZGF0YSkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzR3JhZGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5ncmFkaWVudFVybDtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuY29sb3JzLmdldENvbG9yKG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuY29sb3JzLmdldENvbG9yKHRoaXMuZGF0YS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGluZUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpbmUoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC52YWx1ZSk7IH0pXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSYW5nZUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFyZWEoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKHR5cGVvZiBkLm1pbiA9PT0gJ251bWJlcicgPyBkLm1pbiA6IGQudmFsdWUpOyB9KVxuICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUodHlwZW9mIGQubWF4ID09PSAnbnVtYmVyJyA/IGQubWF4IDogZC52YWx1ZSk7IH0pXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBcmVhR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeFByb3BlcnR5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJlYSgpXG4gICAgICAgICAgICAueCh4UHJvcGVydHkpXG4gICAgICAgICAgICAueTAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMueVNjYWxlLnJhbmdlKClbMF07IH0pXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLnZhbHVlKTsgfSlcbiAgICAgICAgICAgIC5jdXJ2ZSh0aGlzLmN1cnZlKTtcbiAgICB9O1xuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnNvcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeURvbWFpbihkYXRhLCAnbmFtZScsICdhc2MnLCB0aGlzLnhTY2FsZS5kb21haW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCwgbWluKTtcbiAgICAgICAgICAgIHRoaXMuYXJlYUdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmFyZWFHcmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNSYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIExpbmVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWxpbmUtc2VyaWVzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnPlxcbiAgICAgIDxkZWZzPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudFxcbiAgICAgICAgICAqbmdJZj1cXFwiaGFzR3JhZGllbnRcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWFyZWFcXG4gICAgICAgIGNsYXNzPVxcXCJsaW5lLWhpZ2hsaWdodFxcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwiYXJlYVBhdGhcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImhhc0dyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBjb2xvcnMuZ2V0Q29sb3IoZGF0YS5uYW1lKVxcXCJcXG4gICAgICAgIFtvcGFjaXR5XT1cXFwiMC4yNVxcXCJcXG4gICAgICAgIFtzdGFydE9wYWNpdHldPVxcXCIwXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgIFtzdG9wc109XFxcImFyZWFHcmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1saW5lXFxuICAgICAgICBjbGFzcz1cXFwibGluZS1zZXJpZXNcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgICBbcGF0aF09XFxcInBhdGhcXFwiXFxuICAgICAgICBbc3Ryb2tlXT1cXFwic3Ryb2tlXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1hcmVhXFxuICAgICAgICAqbmdJZj1cXFwiaGFzUmFuZ2VcXFwiXFxuICAgICAgICBjbGFzcz1cXFwibGluZS1zZXJpZXMtcmFuZ2VcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgICBbcGF0aF09XFxcIm91dGVyUGF0aFxcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IGNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFtvcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBMaW5lU2VyaWVzQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IExpbmVTZXJpZXNDb21wb25lbnQgfTtcbiJdfQ==