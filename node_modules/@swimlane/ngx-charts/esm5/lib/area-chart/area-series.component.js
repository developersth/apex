import { __decorate, __read, __spread } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { area } from 'd3-shape';
import { sortLinear, sortByTime, sortByDomain } from '../utils/sort';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../common/area.component';

var _c0 = ["ngx-charts-area-series", ""];
var AreaSeriesComponent = /** @class */ (function () {
    function AreaSeriesComponent() {
        this.baseValue = 'auto';
        this.stacked = false;
        this.normalized = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    AreaSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AreaSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradient();
        var currentArea;
        var startingArea;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        if (this.stacked || this.normalized) {
            currentArea = area()
                .x(xProperty)
                .y0(function (d, i) { return _this.yScale(d.d0); })
                .y1(function (d, i) { return _this.yScale(d.d1); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.yScale.range()[0]; })
                .y1(function (d) { return _this.yScale.range()[0]; });
        }
        else {
            currentArea = area()
                .x(xProperty)
                .y0(function () { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); })
                .y1(function (d) { return _this.yScale(d.value); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); })
                .y1(function (d) { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); });
        }
        currentArea.curve(this.curve);
        startingArea.curve(this.curve);
        this.opacity = 0.8;
        var data = this.data.series;
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        this.path = currentArea(data);
        this.startingPath = startingArea(data);
    };
    AreaSeriesComponent.prototype.updateGradient = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            if (this.stacked || this.normalized) {
                var d0values = this.data.series.map(function (d) { return d.d0; });
                var d1values = this.data.series.map(function (d) { return d.d1; });
                var max = Math.max.apply(Math, __spread(d1values));
                var min = Math.min.apply(Math, __spread(d0values));
                this.gradientStops = this.colors.getLinearGradientStops(max, min);
            }
            else {
                var values = this.data.series.map(function (d) { return d.value; });
                var max = Math.max.apply(Math, __spread(values));
                this.gradientStops = this.colors.getLinearGradientStops(max);
            }
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
        }
    };
    AreaSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    AreaSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "baseValue", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "stacked", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "normalized", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input()
    ], AreaSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output()
    ], AreaSeriesComponent.prototype, "select", void 0);
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [ɵngcc1.AreaComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: "\n    <svg:g\n      ngx-charts-area\n      class=\"area-series\"\n      [data]=\"data\"\n      [path]=\"path\"\n      [fill]=\"colors.getColor(data.name)\"\n      [stops]=\"gradientStops\"\n      [startingPath]=\"startingPath\"\n      [opacity]=\"opacity\"\n      [gradient]=\"gradient || hasGradient\"\n      [animations]=\"animations\"\n      [class.active]=\"isActive(data)\"\n      [class.inactive]=\"isInactive(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: Input
        }], stacked: [{
            type: Input
        }], normalized: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return AreaSeriesComponent;
}());
export { AreaSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvYXJlYS1jaGFydC9hcmVhLXNlcmllcy5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dEQW1Jd0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPNUIiLCJmaWxlIjoiYXJlYS1zZXJpZXMuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19yZWFkLCBfX3NwcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhcmVhIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgc29ydExpbmVhciwgc29ydEJ5VGltZSwgc29ydEJ5RG9tYWluIH0gZnJvbSAnLi4vdXRpbHMvc29ydCc7XG52YXIgQXJlYVNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmVhU2VyaWVzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLmJhc2VWYWx1ZSA9ICdhdXRvJztcbiAgICAgICAgdGhpcy5zdGFja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyYWRpZW50KCk7XG4gICAgICAgIHZhciBjdXJyZW50QXJlYTtcbiAgICAgICAgdmFyIHN0YXJ0aW5nQXJlYTtcbiAgICAgICAgdmFyIHhQcm9wZXJ0eSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYSgpXG4gICAgICAgICAgICAgICAgLngoeFByb3BlcnR5KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQuZDApOyB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQuZDEpOyB9KTtcbiAgICAgICAgICAgIHN0YXJ0aW5nQXJlYSA9IGFyZWEoKVxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdOyB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlLnJhbmdlKClbMF07IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEFyZWEgPSBhcmVhKClcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXG4gICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy5iYXNlVmFsdWUgPT09ICdhdXRvJyA/IF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogX3RoaXMueVNjYWxlKF90aGlzLmJhc2VWYWx1ZSkpOyB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQudmFsdWUpOyB9KTtcbiAgICAgICAgICAgIHN0YXJ0aW5nQXJlYSA9IGFyZWEoKVxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChfdGhpcy5iYXNlVmFsdWUgPT09ICdhdXRvJyA/IF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogX3RoaXMueVNjYWxlKF90aGlzLmJhc2VWYWx1ZSkpOyB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gKF90aGlzLmJhc2VWYWx1ZSA9PT0gJ2F1dG8nID8gX3RoaXMueVNjYWxlLnJhbmdlKClbMF0gOiBfdGhpcy55U2NhbGUoX3RoaXMuYmFzZVZhbHVlKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmVhLmN1cnZlKHRoaXMuY3VydmUpO1xuICAgICAgICBzdGFydGluZ0FyZWEuY3VydmUodGhpcy5jdXJ2ZSk7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDAuODtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuc2VyaWVzO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydExpbmVhcihkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0QnlUaW1lKGRhdGEsICduYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5RG9tYWluKGRhdGEsICduYW1lJywgJ2FzYycsIHRoaXMueFNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGggPSBjdXJyZW50QXJlYShkYXRhKTtcbiAgICAgICAgdGhpcy5zdGFydGluZ1BhdGggPSBzdGFydGluZ0FyZWEoZGF0YSk7XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kMDsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGQxdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZDE7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZChkMXZhbHVlcykpO1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZChkMHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMobWF4LCBtaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzZVZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhY2tlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibm9ybWFsaXplZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgQXJlYVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXJlYS1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLWFyZWFcXG4gICAgICBjbGFzcz1cXFwiYXJlYS1zZXJpZXNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgIFtwYXRoXT1cXFwicGF0aFxcXCJcXG4gICAgICBbZmlsbF09XFxcImNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXFxcIlxcbiAgICAgIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgW3N0YXJ0aW5nUGF0aF09XFxcInN0YXJ0aW5nUGF0aFxcXCJcXG4gICAgICBbb3BhY2l0eV09XFxcIm9wYWNpdHlcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnQgfHwgaGFzR3JhZGllbnRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZShkYXRhKVxcXCJcXG4gICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBBcmVhU2VyaWVzQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IEFyZWFTZXJpZXNDb21wb25lbnQgfTtcbiJdfQ==