import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { formatLabel, escapeLabel } from '../common/label.helper';
import { D0Types } from './series-vertical.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './bar.component';
import * as ɵngcc3 from '../common/tooltip/tooltip.directive';
import * as ɵngcc4 from './bar-label.component';

var _c0 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r262 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesHorizontal__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r262); var ctx_r261 = ɵngcc0.ɵɵnextContext(); return ctx_r261.click($event); })("activate", function SeriesHorizontal__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r262); var ctx_r263 = ɵngcc0.ɵɵnextContext(); return ctx_r263.activate.emit($event); })("deactivate", function SeriesHorizontal__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r262); var ctx_r264 = ɵngcc0.ɵɵnextContext(); return ctx_r264.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r260 = ctx.$implicit;
    var ctx_r258 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("width", bar_r260.width)("height", bar_r260.height)("x", bar_r260.x)("y", bar_r260.y)("fill", bar_r260.color)("stops", bar_r260.gradientStops)("data", bar_r260.data)("orientation", "horizontal")("roundEdges", bar_r260.roundEdges)("gradient", ctx_r258.gradient)("isActive", ctx_r258.isActive(bar_r260.data))("ariaLabel", bar_r260.ariaLabel)("animations", ctx_r258.animations)("tooltipDisabled", ctx_r258.tooltipDisabled)("tooltipPlacement", ctx_r258.tooltipPlacement)("tooltipType", ctx_r258.tooltipType)("tooltipTitle", ctx_r258.tooltipTemplate ? undefined : bar_r260.tooltipText)("tooltipTemplate", ctx_r258.tooltipTemplate)("tooltipContext", bar_r260.data)("noBarWhenZero", ctx_r258.noBarWhenZero);
} }
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r269 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r269); var i_r267 = ctx.index; var ctx_r268 = ɵngcc0.ɵɵnextContext(2); return ctx_r268.dataLabelWidthChanged.emit({ size: $event, index: i_r267 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r266 = ctx.$implicit;
    var ctx_r265 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r266.x)("barY", b_r266.y)("barWidth", b_r266.width)("barHeight", b_r266.height)("value", b_r266.total)("valueFormatting", ctx_r265.dataLabelFormatting)("orientation", "horizontal");
} }
function SeriesHorizontal__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r259 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r259.barsForDataLabels)("ngForTrackBy", ctx_r259.trackDataLabelBy);
} }
var SeriesHorizontal = /** @class */ (function () {
    function SeriesHorizontal() {
        this.barsForDataLabels = [];
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelWidthChanged = new EventEmitter();
    }
    SeriesHorizontal.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesHorizontal.prototype.update = function () {
        var _a;
        var _this = this;
        this.updateTooltipSettings();
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type;
        d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        var xScaleMin = Math.max(this.xScale.domain()[0], 0);
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                formattedLabel: formattedLabel
            };
            bar.height = _this.yScale.bandwidth();
            if (_this.type === 'standard') {
                bar.width = Math.abs(_this.xScale(value) - _this.xScale(xScaleMin));
                if (value < 0) {
                    bar.x = _this.xScale(value);
                }
                else {
                    bar.x = _this.xScale(xScaleMin);
                }
                bar.y = _this.yScale(label);
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + escapeLabel(tooltipLabel) + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesHorizontal.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            // if total is positive then we show it on the right, otherwise on the left
            if (section.total > 0) {
                section.width = this.xScale(totalPositive);
            }
            else {
                section.width = this.xScale(totalNegative);
            }
            section.height = this.yScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(0);
                section.y = _this.yScale(d.label);
                section.width = _this.xScale(section.total) - _this.xScale(0);
                section.height = _this.yScale.bandwidth();
                return section;
            });
        }
    };
    SeriesHorizontal.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesHorizontal.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesHorizontal.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesHorizontal.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesHorizontal.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    SeriesHorizontal.prototype.click = function (data) {
        this.select.emit(data);
    };
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "dims", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "type", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "series", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "yScale", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "colors", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "gradient", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "activeEntries", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "seriesName", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "roundEdges", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "animations", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "showDataLabel", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input()
    ], SeriesHorizontal.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output()
    ], SeriesHorizontal.prototype, "select", void 0);
    __decorate([
        Output()
    ], SeriesHorizontal.prototype, "activate", void 0);
    __decorate([
        Output()
    ], SeriesHorizontal.prototype, "deactivate", void 0);
    __decorate([
        Output()
    ], SeriesHorizontal.prototype, "dataLabelWidthChanged", void 0);
SeriesHorizontal.ɵfac = function SeriesHorizontal_Factory(t) { return new (t || SeriesHorizontal)(); };
SeriesHorizontal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesHorizontal, selectors: [["g", "ngx-charts-series-horizontal", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelWidthChanged: "dataLabelWidthChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesHorizontal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc2.BarComponent, ɵngcc3.TooltipDirective, ɵngcc4.BarLabelComponent], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SeriesHorizontal, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-horizontal]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'horizontal'\"\n      [roundEdges]=\"bar.roundEdges\"\n      (select)=\"click($event)\"\n      [gradient]=\"gradient\"\n      [isActive]=\"isActive(bar.data)\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [animations]=\"animations\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'horizontal'\"\n        (dimensionsChanged)=\"dataLabelWidthChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelWidthChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesHorizontal;
}());
export { SeriesHorizontal };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvYmFyLWNoYXJ0L3Nlcmllcy1ob3Jpem9udGFsLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29FQXVPb0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUIzQyIsImZpbGUiOiJzZXJpZXMtaG9yaXpvbnRhbC5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBmb3JtYXRMYWJlbCwgZXNjYXBlTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwuaGVscGVyJztcbmltcG9ydCB7IEQwVHlwZXMgfSBmcm9tICcuL3Nlcmllcy12ZXJ0aWNhbC5jb21wb25lbnQnO1xudmFyIFNlcmllc0hvcml6b250YWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWVzSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IFtdO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhbmRhcmQnO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRhTGFiZWxXaWR0aENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBTZXR0aW5ncygpO1xuICAgICAgICB2YXIgZDAgPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0QwVHlwZXMucG9zaXRpdmVdID0gMCxcbiAgICAgICAgICAgIF9hW0QwVHlwZXMubmVnYXRpdmVdID0gMCxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgdmFyIGQwVHlwZTtcbiAgICAgICAgZDBUeXBlID0gRDBUeXBlcy5wb3NpdGl2ZTtcbiAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gc3VtICsgZDsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhTY2FsZU1pbiA9IE1hdGgubWF4KHRoaXMueFNjYWxlLmRvbWFpbigpWzBdLCAwKTtcbiAgICAgICAgdGhpcy5iYXJzID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IF90aGlzLmdldExhYmVsKGQpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwpO1xuICAgICAgICAgICAgdmFyIHJvdW5kRWRnZXMgPSBfdGhpcy5yb3VuZEVkZ2VzO1xuICAgICAgICAgICAgZDBUeXBlID0gdmFsdWUgPiAwID8gRDBUeXBlcy5wb3NpdGl2ZSA6IEQwVHlwZXMubmVnYXRpdmU7XG4gICAgICAgICAgICB2YXIgYmFyID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgcm91bmRFZGdlczogcm91bmRFZGdlcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZExhYmVsOiBmb3JtYXR0ZWRMYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJhci5oZWlnaHQgPSBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IE1hdGguYWJzKF90aGlzLnhTY2FsZSh2YWx1ZSkgLSBfdGhpcy54U2NhbGUoeFNjYWxlTWluKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZSh4U2NhbGVNaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZShsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBvZmZzZXQwICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBiYXIud2lkdGggPSBfdGhpcy54U2NhbGUob2Zmc2V0MSkgLSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XG4gICAgICAgICAgICAgICAgYmFyLnggPSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XG4gICAgICAgICAgICAgICAgYmFyLnkgPSAwO1xuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MSA9IG9mZnNldDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBvZmZzZXQwICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG90YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDAgPSAob2Zmc2V0MCAqIDEwMCkgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IChvZmZzZXQxICogMTAwKSAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDEgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXIud2lkdGggPSBfdGhpcy54U2NhbGUob2Zmc2V0MSkgLSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XG4gICAgICAgICAgICAgICAgYmFyLnggPSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XG4gICAgICAgICAgICAgICAgYmFyLnkgPSAwO1xuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MSA9IG9mZnNldDE7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAob2Zmc2V0MSAtIG9mZnNldDApLnRvRml4ZWQoMikgKyAnJSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJhci5ncmFkaWVudFN0b3BzID0gX3RoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGJhci5vZmZzZXQxKTtcbiAgICAgICAgICAgICAgICAgICAgYmFyLmdyYWRpZW50U3RvcHMgPSBfdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhiYXIub2Zmc2V0MSwgYmFyLm9mZnNldDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBmb3JtYXR0ZWRMYWJlbDtcbiAgICAgICAgICAgIGJhci5hcmlhTGFiZWwgPSBmb3JtYXR0ZWRMYWJlbCArICcgJyArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyBcIiBcXHUyMDIyIFwiICsgZm9ybWF0dGVkTGFiZWw7XG4gICAgICAgICAgICAgICAgYmFyLmRhdGEuc2VyaWVzID0gX3RoaXMuc2VyaWVzTmFtZTtcbiAgICAgICAgICAgICAgICBiYXIuYXJpYUxhYmVsID0gX3RoaXMuc2VyaWVzTmFtZSArICcgJyArIGJhci5hcmlhTGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXIudG9vbHRpcFRleHQgPSBfdGhpcy50b29sdGlwRGlzYWJsZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogXCJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGVzY2FwZUxhYmVsKHRvb2x0aXBMYWJlbCkgKyBcIjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgXCI8L3NwYW4+XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm4gYmFyO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhTGFiZWxzKCk7XG4gICAgfTtcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS51cGRhdGVEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XG4gICAgICAgICAgICBzZWN0aW9uLnNlcmllcyA9IHRoaXMuc2VyaWVzTmFtZTtcbiAgICAgICAgICAgIHZhciB0b3RhbFBvc2l0aXZlID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gKGQgPiAwID8gc3VtICsgZCA6IHN1bSk7IH0sIDApO1xuICAgICAgICAgICAgdmFyIHRvdGFsTmVnYXRpdmUgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiAoZCA8IDAgPyBzdW0gKyBkIDogc3VtKTsgfSwgMCk7XG4gICAgICAgICAgICBzZWN0aW9uLnRvdGFsID0gdG90YWxQb3NpdGl2ZSArIHRvdGFsTmVnYXRpdmU7XG4gICAgICAgICAgICBzZWN0aW9uLnggPSAwO1xuICAgICAgICAgICAgc2VjdGlvbi55ID0gMDtcbiAgICAgICAgICAgIC8vIGlmIHRvdGFsIGlzIHBvc2l0aXZlIHRoZW4gd2Ugc2hvdyBpdCBvbiB0aGUgcmlnaHQsIG90aGVyd2lzZSBvbiB0aGUgbGVmdFxuICAgICAgICAgICAgaWYgKHNlY3Rpb24udG90YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IHRoaXMueFNjYWxlKHRvdGFsUG9zaXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IHRoaXMueFNjYWxlKHRvdGFsTmVnYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSB0aGlzLnlTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMucHVzaChzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VjdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gX3RoaXMuc2VyaWVzTmFtZSA/IF90aGlzLnNlcmllc05hbWUgOiBkLmxhYmVsO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSBkLnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24ueCA9IF90aGlzLnhTY2FsZSgwKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnkgPSBfdGhpcy55U2NhbGUoZC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IF90aGlzLnhTY2FsZShzZWN0aW9uLnRvdGFsKSAtIF90aGlzLnhTY2FsZSgwKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmhlaWdodCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS51cGRhdGVUb29sdGlwU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcFBsYWNlbWVudCA9IHRoaXMudG9vbHRpcERpc2FibGVkID8gdW5kZWZpbmVkIDogJ3RvcCc7XG4gICAgICAgIHRoaXMudG9vbHRpcFR5cGUgPSB0aGlzLnRvb2x0aXBEaXNhYmxlZCA/IHVuZGVmaW5lZCA6ICd0b29sdGlwJztcbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgaWYgKGRhdGFJdGVtLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFJdGVtLm5hbWU7XG4gICAgfTtcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBiYXIpIHtcbiAgICAgICAgcmV0dXJuIGJhci5sYWJlbDtcbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnRyYWNrRGF0YUxhYmVsQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhckxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpbmRleCArICcjJyArIGJhckxhYmVsLnNlcmllcyArICcjJyArIGJhckxhYmVsLnRvdGFsO1xuICAgIH07XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInNlcmllc05hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwicm91bmRFZGdlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImRhdGFMYWJlbFdpZHRoQ2hhbmdlZFwiLCB2b2lkIDApO1xuICAgIFNlcmllc0hvcml6b250YWwgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnXFxuICAgICAgbmd4LWNoYXJ0cy1iYXJcXG4gICAgICAqbmdGb3I9XFxcImxldCBiYXIgb2YgYmFyczsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYmFyLndpZHRoXFxcIlxcbiAgICAgIFtoZWlnaHRdPVxcXCJiYXIuaGVpZ2h0XFxcIlxcbiAgICAgIFt4XT1cXFwiYmFyLnhcXFwiXFxuICAgICAgW3ldPVxcXCJiYXIueVxcXCJcXG4gICAgICBbZmlsbF09XFxcImJhci5jb2xvclxcXCJcXG4gICAgICBbc3RvcHNdPVxcXCJiYXIuZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICBbZGF0YV09XFxcImJhci5kYXRhXFxcIlxcbiAgICAgIFtvcmllbnRhdGlvbl09XFxcIidob3Jpem9udGFsJ1xcXCJcXG4gICAgICBbcm91bmRFZGdlc109XFxcImJhci5yb3VuZEVkZ2VzXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJjbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGJhci5kYXRhKVxcXCJcXG4gICAgICBbYXJpYUxhYmVsXT1cXFwiYmFyLmFyaWFMYWJlbFxcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwidG9vbHRpcFBsYWNlbWVudFxcXCJcXG4gICAgICBbdG9vbHRpcFR5cGVdPVxcXCJ0b29sdGlwVHlwZVxcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogYmFyLnRvb2x0aXBUZXh0XFxcIlxcbiAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwiYmFyLmRhdGFcXFwiXFxuICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICA+PC9zdmc6Zz5cXG4gICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93RGF0YUxhYmVsXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtYmFyLWxhYmVsXFxuICAgICAgICAqbmdGb3I9XFxcImxldCBiIG9mIGJhcnNGb3JEYXRhTGFiZWxzOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0RhdGFMYWJlbEJ5XFxcIlxcbiAgICAgICAgW2JhclhdPVxcXCJiLnhcXFwiXFxuICAgICAgICBbYmFyWV09XFxcImIueVxcXCJcXG4gICAgICAgIFtiYXJXaWR0aF09XFxcImIud2lkdGhcXFwiXFxuICAgICAgICBbYmFySGVpZ2h0XT1cXFwiYi5oZWlnaHRcXFwiXFxuICAgICAgICBbdmFsdWVdPVxcXCJiLnRvdGFsXFxcIlxcbiAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICBbb3JpZW50YXRpb25dPVxcXCInaG9yaXpvbnRhbCdcXFwiXFxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJkYXRhTGFiZWxXaWR0aENoYW5nZWQuZW1pdCh7IHNpemU6ICRldmVudCwgaW5kZXg6IGkgfSlcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsKTtcbiAgICByZXR1cm4gU2VyaWVzSG9yaXpvbnRhbDtcbn0oKSk7XG5leHBvcnQgeyBTZXJpZXNIb3Jpem9udGFsIH07XG4iXX0=