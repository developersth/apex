import { __decorate } from "tslib";
import { Component, Input, Output, SimpleChanges, EventEmitter, ElementRef, OnChanges, ChangeDetectionStrategy } from '@angular/core';
import { select } from 'd3-selection';
import { id } from '../utils/id';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './svg-linear-gradient.component';

var _c0 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r54 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r54.gradientId)("stops", ctx_r54.gradientStops);
} }
var AreaComponent = /** @class */ (function () {
    function AreaComponent(element) {
        this.opacity = 1;
        this.startOpacity = 0.5;
        this.endOpacity = 1;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.element = element.nativeElement;
    }
    AreaComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    AreaComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
    };
    AreaComponent.prototype.loadAnimation = function () {
        this.areaPath = this.startingPath;
        setTimeout(this.update.bind(this), 100);
    };
    AreaComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.area');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    AreaComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: this.endOpacity
            }
        ];
    };
    AreaComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], AreaComponent.prototype, "data", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "path", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "startingPath", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "fill", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "opacity", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "activeLabel", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "gradient", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "stops", void 0);
    __decorate([
        Input()
    ], AreaComponent.prototype, "animations", void 0);
    __decorate([
        Output()
    ], AreaComponent.prototype, "select", void 0);
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["g", "ngx-charts-area", ""]], inputs: { opacity: "opacity", startOpacity: "startOpacity", endOpacity: "endOpacity", gradient: "gradient", animations: "animations", data: "data", path: "path", startingPath: "startingPath", fill: "fill", activeLabel: "activeLabel", stops: "stops" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 2, vars: 5, consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent__svg_defs_0_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity);
        ɵngcc0.ɵɵattribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area]',
                template: "\n    <svg:defs *ngIf=\"gradient\">\n      <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path class=\"area\" [attr.d]=\"areaPath\" [attr.fill]=\"gradient ? gradientFill : fill\" [style.opacity]=\"opacity\" />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { opacity: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }], endOpacity: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], path: [{
            type: Input
        }], startingPath: [{
            type: Input
        }], fill: [{
            type: Input
        }], activeLabel: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return AreaComponent;
}());
export { AreaComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvY29tbW9uL2FyZWEuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tEQXdHa0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzVCIiwiZmlsZSI6ImFyZWEuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4uL3V0aWxzL2lkJztcbnZhciBBcmVhQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZWFDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0T3BhY2l0eSA9IDAuNTtcbiAgICAgICAgdGhpcy5lbmRPcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5zdG9wcykge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5nZXRHcmFkaWVudCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcbiAgICB9O1xuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSB0aGlzLnN0YXJ0aW5nUGF0aDtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpLCAxMDApO1xuICAgIH07XG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlUGF0aEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmFyZWEnKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgdGhpcy5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cignZCcsIHRoaXMucGF0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZW5kT3BhY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQXJlYUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbiAgICBdOyB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGF0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRpbmdQYXRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydE9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImVuZE9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBBcmVhQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1hcmVhXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpkZWZzICpuZ0lmPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCIgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCIgLz5cXG4gICAgPC9zdmc6ZGVmcz5cXG4gICAgPHN2ZzpwYXRoIGNsYXNzPVxcXCJhcmVhXFxcIiBbYXR0ci5kXT1cXFwiYXJlYVBhdGhcXFwiIFthdHRyLmZpbGxdPVxcXCJncmFkaWVudCA/IGdyYWRpZW50RmlsbCA6IGZpbGxcXFwiIFtzdHlsZS5vcGFjaXR5XT1cXFwib3BhY2l0eVxcXCIgLz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBBcmVhQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQXJlYUNvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBBcmVhQ29tcG9uZW50IH07XG4iXX0=