import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { trimLabel } from '../trim-label.helper';
import { reduceTicks } from './ticks.helper';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["ticksel"];
var _c1 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r16 = ctx.$implicit;
    var ctx_r14 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r14.tickTransform(tick_r16));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.tickFormat(tick_r16));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r14.textAnchor)("transform", ctx_r14.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r14.tickTrim(ctx_r14.tickFormat(tick_r16)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r18.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", 0 - ctx_r18.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r17 = ctx.$implicit;
    var ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r15.tickTransform(tick_r17));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r15.showGridLines);
} }
var XAxisTicksComponent = /** @class */ (function () {
    function XAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.rotateTicks = true;
        this.dimensionsChanged = new EventEmitter();
        this.verticalSpacing = 20;
        this.rotateLabels = false;
        this.innerTickSize = 6;
        this.outerTickSize = 6;
        this.tickPadding = 3;
        this.textAnchor = 'middle';
        this.maxTicksLength = 0;
        this.maxAllowedLength = 16;
        this.height = 0;
    }
    XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
        if (height !== this.height) {
            this.height = height;
            this.dimensionsChanged.emit({ height: height });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    XAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
        this.adjustedScale = this.scale.bandwidth
            ? function (d) {
                return this.scale(d) + this.scale.bandwidth() * 0.5;
            }
            : this.scale;
        this.textTransform = '';
        if (angle && angle !== 0) {
            this.textTransform = "rotate(" + angle + ")";
            this.textAnchor = 'end';
            this.verticalSpacing = 10;
        }
        else {
            this.textAnchor = 'middle';
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
        var angle = 0;
        this.maxTicksLength = 0;
        for (var i = 0; i < ticks.length; i++) {
            var tick = this.tickFormat(ticks[i]).toString();
            var tickLength = tick.length;
            if (this.trimTicks) {
                tickLength = this.tickTrim(tick).length;
            }
            if (tickLength > this.maxTicksLength) {
                this.maxTicksLength = tickLength;
            }
        }
        var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
        var charWidth = 8; // need to measure this
        var wordWidth = len * charWidth;
        var baseWidth = wordWidth;
        var maxBaseWidth = Math.floor(this.width / ticks.length);
        // calculate optimal angle
        while (baseWidth > maxBaseWidth && angle > -90) {
            angle -= 30;
            baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
        }
        return angle;
    };
    XAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(100);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
        return Math.floor(this.width / tickWidth);
    };
    XAxisTicksComponent.prototype.tickTransform = function (tick) {
        return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
    };
    XAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(0," + (-this.verticalSpacing - 5) + ")";
    };
    XAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "gridLineHeight", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "width", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Output()
    ], XAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel')
    ], XAxisTicksComponent.prototype, "ticksElement", void 0);
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(); };
XAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c1, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], rotateTicks: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineHeight: [{
            type: Input
        }], width: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel']
        }] }); })();
    return XAxisTicksComponent;
}());
export { XAxisTicksComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvY29tbW9uL2F4ZXMveC1heGlzLXRpY2tzLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhEQW9LOEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT2xDIiwiZmlsZSI6IngtYXhpcy10aWNrcy5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVmlld0NoaWxkLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdHJpbUxhYmVsIH0gZnJvbSAnLi4vdHJpbS1sYWJlbC5oZWxwZXInO1xuaW1wb3J0IHsgcmVkdWNlVGlja3MgfSBmcm9tICcuL3RpY2tzLmhlbHBlcic7XG52YXIgWEF4aXNUaWNrc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYQXhpc1RpY2tzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbNV07XG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjY2NjJztcbiAgICAgICAgdGhpcy50cmltVGlja3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heFRpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgdGhpcy5zaG93R3JpZExpbmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm90YXRlVGlja3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDIwO1xuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlubmVyVGlja1NpemUgPSA2O1xuICAgICAgICB0aGlzLm91dGVyVGlja1NpemUgPSA2O1xuICAgICAgICB0aGlzLnRpY2tQYWRkaW5nID0gMztcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMubWF4VGlja3NMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1heEFsbG93ZWRMZW5ndGggPSAxNjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIH1cbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcbiAgICB9O1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURpbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludCh0aGlzLnRpY2tzRWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCwgMTApO1xuICAgICAgICBpZiAoaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICAgICAgICBpZiAodGhpcy50aWNrRm9ybWF0dGluZykge1xuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gdGhpcy50aWNrRm9ybWF0dGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2FsZS50aWNrRm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aGlzLnRpY2tBcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMucm90YXRlVGlja3MgPyB0aGlzLmdldFJvdGF0aW9uQW5nbGUodGhpcy50aWNrcykgOiBudWxsO1xuICAgICAgICB0aGlzLmFkanVzdGVkU2NhbGUgPSB0aGlzLnNjYWxlLmJhbmR3aWR0aFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKGQpICsgdGhpcy5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy50ZXh0VHJhbnNmb3JtID0gJyc7XG4gICAgICAgIGlmIChhbmdsZSAmJiBhbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0VHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyBhbmdsZSArIFwiKVwiO1xuICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Um90YXRpb25BbmdsZSA9IGZ1bmN0aW9uICh0aWNrcykge1xuICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICB0aGlzLm1heFRpY2tzTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRpY2sgPSB0aGlzLnRpY2tGb3JtYXQodGlja3NbaV0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgdGlja0xlbmd0aCA9IHRpY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJpbVRpY2tzKSB7XG4gICAgICAgICAgICAgICAgdGlja0xlbmd0aCA9IHRoaXMudGlja1RyaW0odGljaykubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpY2tMZW5ndGggPiB0aGlzLm1heFRpY2tzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhUaWNrc0xlbmd0aCA9IHRpY2tMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMubWF4VGlja3NMZW5ndGgsIHRoaXMubWF4QWxsb3dlZExlbmd0aCk7XG4gICAgICAgIHZhciBjaGFyV2lkdGggPSA4OyAvLyBuZWVkIHRvIG1lYXN1cmUgdGhpc1xuICAgICAgICB2YXIgd29yZFdpZHRoID0gbGVuICogY2hhcldpZHRoO1xuICAgICAgICB2YXIgYmFzZVdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICB2YXIgbWF4QmFzZVdpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gdGlja3MubGVuZ3RoKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIG9wdGltYWwgYW5nbGVcbiAgICAgICAgd2hpbGUgKGJhc2VXaWR0aCA+IG1heEJhc2VXaWR0aCAmJiBhbmdsZSA+IC05MCkge1xuICAgICAgICAgICAgYW5nbGUgLT0gMzA7XG4gICAgICAgICAgICBiYXNlV2lkdGggPSBNYXRoLmNvcyhhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSkgKiB3b3JkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aWNrcztcbiAgICAgICAgdmFyIG1heFRpY2tzID0gdGhpcy5nZXRNYXhUaWNrcygyMCk7XG4gICAgICAgIHZhciBtYXhTY2FsZVRpY2tzID0gdGhpcy5nZXRNYXhUaWNrcygxMDApO1xuICAgICAgICBpZiAodGhpcy50aWNrVmFsdWVzKSB7XG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlLnRpY2tzKSB7XG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUudGlja3MuYXBwbHkodGhpcy5zY2FsZSwgW21heFNjYWxlVGlja3NdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tzID0gdGhpcy5zY2FsZS5kb21haW4oKTtcbiAgICAgICAgICAgIHRpY2tzID0gcmVkdWNlVGlja3ModGlja3MsIG1heFRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRNYXhUaWNrcyA9IGZ1bmN0aW9uICh0aWNrV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy53aWR0aCAvIHRpY2tXaWR0aCk7XG4gICAgfTtcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS50aWNrVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcsJyArIHRoaXMudmVydGljYWxTcGFjaW5nICsgJyknO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ3JpZExpbmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKC10aGlzLnZlcnRpY2FsU3BhY2luZyAtIDUpICsgXCIpXCI7XG4gICAgfTtcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS50aWNrVHJpbSA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmltVGlja3MgPyB0cmltTGFiZWwobGFiZWwsIHRoaXMubWF4VGlja0xlbmd0aCkgOiBsYWJlbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0FyZ3VtZW50c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja1ZhbHVlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja1N0cm9rZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVRpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JpZExpbmVIZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcImRpbWVuc2lvbnNDaGFuZ2VkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIFZpZXdDaGlsZCgndGlja3NlbCcpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NFbGVtZW50XCIsIHZvaWQgMCk7XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteC1heGlzLXRpY2tzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnICN0aWNrc2VsPlxcbiAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRpY2tzXFxcIiBjbGFzcz1cXFwidGlja1xcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidGlja1RyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgICA8dGl0bGU+e3sgdGlja0Zvcm1hdCh0aWNrKSB9fTwvdGl0bGU+XFxuICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVxcXCIwLjAxXFxcIlxcbiAgICAgICAgICBbYXR0ci50ZXh0LWFuY2hvcl09XFxcInRleHRBbmNob3JcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRleHRUcmFuc2Zvcm1cXFwiXFxuICAgICAgICAgIFtzdHlsZS5mb250LXNpemVdPVxcXCInMTJweCdcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIHt7IHRpY2tUcmltKHRpY2tGb3JtYXQodGljaykpIH19XFxuICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuXFxuICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRpY2tzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aWNrVHJhbnNmb3JtKHRpY2spXFxcIj5cXG4gICAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dHcmlkTGluZXNcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcImdyaWRMaW5lVHJhbnNmb3JtKClcXFwiPlxcbiAgICAgICAgPHN2ZzpsaW5lIGNsYXNzPVxcXCJncmlkbGluZS1wYXRoIGdyaWRsaW5lLXBhdGgtdmVydGljYWxcXFwiIFthdHRyLnkxXT1cXFwiLWdyaWRMaW5lSGVpZ2h0XFxcIiB5Mj1cXFwiMFxcXCIgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQpO1xuICAgIHJldHVybiBYQXhpc1RpY2tzQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IFhBeGlzVGlja3NDb21wb25lbnQgfTtcbiJdfQ==