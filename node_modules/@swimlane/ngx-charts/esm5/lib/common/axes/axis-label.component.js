import { __decorate } from "tslib";
import { Component, Input, ElementRef, OnChanges, SimpleChanges, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';

var _c0 = ["ngx-charts-axis-label", ""];
var AxisLabelComponent = /** @class */ (function () {
    function AxisLabelComponent(element) {
        this.textHeight = 25;
        this.margin = 5;
        this.element = element.nativeElement;
    }
    AxisLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AxisLabelComponent.prototype.update = function () {
        this.strokeWidth = '0.01';
        this.textAnchor = 'middle';
        this.transform = '';
        switch (this.orient) {
            case 'top':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'bottom':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'left':
                this.y = -(this.offset + this.textHeight + this.margin);
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            case 'right':
                this.y = this.offset + this.margin;
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            default:
        }
    };
    AxisLabelComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], AxisLabelComponent.prototype, "orient", void 0);
    __decorate([
        Input()
    ], AxisLabelComponent.prototype, "label", void 0);
    __decorate([
        Input()
    ], AxisLabelComponent.prototype, "offset", void 0);
    __decorate([
        Input()
    ], AxisLabelComponent.prototype, "width", void 0);
    __decorate([
        Input()
    ], AxisLabelComponent.prototype, "height", void 0);
AxisLabelComponent.ɵfac = function AxisLabelComponent_Factory(t) { return new (t || AxisLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AxisLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisLabelComponent, selectors: [["g", "ngx-charts-axis-label", ""]], inputs: { orient: "orient", label: "label", offset: "offset", width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 2, vars: 6, template: function AxisLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AxisLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-axis-label]',
                template: "\n    <svg:text\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n    >\n      {{ label }}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { orient: [{
            type: Input
        }], label: [{
            type: Input
        }], offset: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }] }); })();
    return AxisLabelComponent;
}());
export { AxisLabelComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvY29tbW9uL2F4ZXMvYXhpcy1sYWJlbC5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dURBb0R1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzVCIiwiZmlsZSI6ImF4aXMtbGFiZWwuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRWxlbWVudFJlZiwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIEF4aXNMYWJlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBeGlzTGFiZWxDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAyNTtcbiAgICAgICAgdGhpcy5tYXJnaW4gPSA1O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAnMC4wMSc7XG4gICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3JpZW50KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IC0odGhpcy5vZmZzZXQgKyB0aGlzLnRleHRIZWlnaHQgKyB0aGlzLm1hcmdpbik7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICdyb3RhdGUoMjcwKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5vZmZzZXQgKyB0aGlzLm1hcmdpbjtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gJ3JvdGF0ZSgyNzApJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF4aXNMYWJlbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbiAgICBdOyB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuICAgIEF4aXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXhpcy1sYWJlbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6dGV4dFxcbiAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XFxcInN0cm9rZVdpZHRoXFxcIlxcbiAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiXFxuICAgID5cXG4gICAgICB7eyBsYWJlbCB9fVxcbiAgICA8L3N2Zzp0ZXh0PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEF4aXNMYWJlbENvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBBeGlzTGFiZWxDb21wb25lbnQgfTtcbiJdfQ==