import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { XAxisTicksComponent } from './x-axis-ticks.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './x-axis-ticks.component';
import * as ɵngcc3 from './axis-label.component';

var _c0 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r19 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r19.trimTicks)("rotateTicks", ctx_r19.rotateTicks)("maxTickLength", ctx_r19.maxTickLength)("tickFormatting", ctx_r19.tickFormatting)("tickArguments", ctx_r19.tickArguments)("tickStroke", ctx_r19.tickStroke)("scale", ctx_r19.xScale)("orient", ctx_r19.xOrient)("showGridLines", ctx_r19.showGridLines)("gridLineHeight", ctx_r19.dims.height)("width", ctx_r19.dims.width)("tickValues", ctx_r19.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r20 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r20.labelText)("offset", ctx_r20.labelOffset)("orient", "bottom")("height", ctx_r20.dims.height)("width", ctx_r20.dims.width);
} }
var XAxisComponent = /** @class */ (function () {
    function XAxisComponent() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    XAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisComponent.prototype.update = function () {
        this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    };
    XAxisComponent.prototype.emitTicksHeight = function (_a) {
        var _this = this;
        var height = _a.height;
        var newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ height: height });
            }, 0);
        }
    };
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisTickInterval", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisTickCount", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xOrient", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisOffset", void 0);
    __decorate([
        Output()
    ], XAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(XAxisTicksComponent)
    ], XAxisComponent.prototype, "ticksComponent", void 0);
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.XAxisTicksComponent, ɵngcc3.AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent]
        }] }); })();
    return XAxisComponent;
}());
export { XAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvY29tbW9uL2F4ZXMveC1heGlzLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyREFrRjJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT3BDIiwiZmlsZSI6IngtYXhpcy5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVmlld0NoaWxkLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgWEF4aXNUaWNrc0NvbXBvbmVudCB9IGZyb20gJy4veC1heGlzLXRpY2tzLmNvbXBvbmVudCc7XG52YXIgWEF4aXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWEF4aXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMucm90YXRlVGlja3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy54T3JpZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgIHRoaXMueEF4aXNPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnhBeGlzQ2xhc3NOYW1lID0gJ3ggYXhpcyc7XG4gICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZpbGwgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJ3N0cm9rZSc7XG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjY2NjJztcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9ICdub25lJztcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB9XG4gICAgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCxcIiArICh0aGlzLnhBeGlzT2Zmc2V0ICsgdGhpcy5wYWRkaW5nICsgdGhpcy5kaW1zLmhlaWdodCkgKyBcIilcIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnhBeGlzVGlja0NvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy50aWNrQXJndW1lbnRzID0gW3RoaXMueEF4aXNUaWNrQ291bnRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUuZW1pdFRpY2tzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHZhciBuZXdMYWJlbE9mZnNldCA9IGhlaWdodCArIDI1ICsgNTtcbiAgICAgICAgaWYgKG5ld0xhYmVsT2Zmc2V0ICE9PSB0aGlzLmxhYmVsT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gbmV3TGFiZWxPZmZzZXQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1UaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVRpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4VGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrSW50ZXJ2YWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tDb3VudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhPcmllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc09mZnNldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBWaWV3Q2hpbGQoWEF4aXNUaWNrc0NvbXBvbmVudClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NDb21wb25lbnRcIiwgdm9pZCAwKTtcbiAgICBYQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteC1heGlzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLmNsYXNzXT1cXFwieEF4aXNDbGFzc05hbWVcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpcy10aWNrc1xcbiAgICAgICAgKm5nSWY9XFxcInhTY2FsZVxcXCJcXG4gICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltVGlja3NcXFwiXFxuICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVUaWNrc1xcXCJcXG4gICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4VGlja0xlbmd0aFxcXCJcXG4gICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInRpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW3RpY2tBcmd1bWVudHNdPVxcXCJ0aWNrQXJndW1lbnRzXFxcIlxcbiAgICAgICAgW3RpY2tTdHJva2VdPVxcXCJ0aWNrU3Ryb2tlXFxcIlxcbiAgICAgICAgW3NjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgW29yaWVudF09XFxcInhPcmllbnRcXFwiXFxuICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICBbZ3JpZExpbmVIZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICBbdGlja1ZhbHVlc109XFxcInRpY2tzXFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZW1pdFRpY2tzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtYXhpcy1sYWJlbFxcbiAgICAgICAgKm5nSWY9XFxcInNob3dMYWJlbFxcXCJcXG4gICAgICAgIFtsYWJlbF09XFxcImxhYmVsVGV4dFxcXCJcXG4gICAgICAgIFtvZmZzZXRdPVxcXCJsYWJlbE9mZnNldFxcXCJcXG4gICAgICAgIFtvcmllbnRdPVxcXCInYm90dG9tJ1xcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgWEF4aXNDb21wb25lbnQpO1xuICAgIHJldHVybiBYQXhpc0NvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBYQXhpc0NvbXBvbmVudCB9O1xuIl19