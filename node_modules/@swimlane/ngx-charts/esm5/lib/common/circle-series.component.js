import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { formatLabel, escapeLabel } from '../common/label.helper';
import { id } from '../utils/id';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './svg-linear-gradient.component';
import * as ɵngcc3 from './circle.component';
import * as ɵngcc4 from './tooltip/tooltip.directive';

var _c0 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    var ctx_r43 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r43.circle.cx - ctx_r43.circle.radius)("y", ctx_r43.circle.cy)("width", ctx_r43.circle.radius * 2)("height", ctx_r43.circle.height)("fill", ctx_r43.gradientFill);
} }
var _c1 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r45 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); var ctx_r44 = ɵngcc0.ɵɵnextContext(); return ctx_r44.onClick(ctx_r44.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); var ctx_r46 = ɵngcc0.ɵɵnextContext(); return ctx_r46.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); var ctx_r47 = ɵngcc0.ɵɵnextContext(); return ctx_r47.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r42 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r42.gradientId)("stops", ctx_r42.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r42.barVisible && ctx_r42.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r42.isActive(ɵngcc0.ɵɵpureFunction1(18, _c1, ctx_r42.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r42.circle.cx)("cy", ctx_r42.circle.cy)("r", ctx_r42.circle.radius)("fill", ctx_r42.circle.color)("pointerEvents", ctx_r42.circle.value === 0 ? "none" : "all")("data", ctx_r42.circle.value)("classNames", ctx_r42.circle.classNames)("tooltipDisabled", ctx_r42.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r42.tooltipTemplate ? undefined : ctx_r42.getTooltipText(ctx_r42.circle))("tooltipTemplate", ctx_r42.tooltipTemplate)("tooltipContext", ctx_r42.circle.data);
} }
var CircleSeriesComponent = /** @class */ (function () {
    function CircleSeriesComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.barVisible = false;
    }
    CircleSeriesComponent.prototype.ngOnInit = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
    };
    CircleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CircleSeriesComponent.prototype.update = function () {
        this.circle = this.getActiveCircle();
    };
    CircleSeriesComponent.prototype.getActiveCircle = function () {
        var _this = this;
        var indexActiveDataPoint = this.data.series.findIndex(function (d) {
            var label = d.name;
            return label && _this.visibleValue && label.toString() === _this.visibleValue.toString() && d.value !== undefined;
        });
        if (indexActiveDataPoint === -1) {
            // No valid point is 'active/hovered over' at this moment.
            return undefined;
        }
        return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
    };
    CircleSeriesComponent.prototype.mapDataPointToCircle = function (d, i) {
        var seriesName = this.data.name;
        var value = d.value;
        var label = d.name;
        var tooltipLabel = formatLabel(label);
        var cx;
        if (this.scaleType === 'time') {
            cx = this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            cx = this.xScale(Number(label));
        }
        else {
            cx = this.xScale(label);
        }
        var cy = this.yScale(this.type === 'standard' ? value : d.d1);
        var radius = 5;
        var height = this.yScale.range()[0] - cy;
        var opacity = 1;
        var color;
        if (this.colors.scaleType === 'linear') {
            if (this.type === 'standard') {
                color = this.colors.getColor(value);
            }
            else {
                color = this.colors.getColor(d.d1);
            }
        }
        else {
            color = this.colors.getColor(seriesName);
        }
        var data = Object.assign({}, d, {
            series: seriesName,
            value: value,
            name: label
        });
        return {
            classNames: ["circle-data-" + i],
            value: value,
            label: label,
            data: data,
            cx: cx,
            cy: cy,
            radius: radius,
            height: height,
            tooltipLabel: tooltipLabel,
            color: color,
            opacity: opacity,
            seriesName: seriesName,
            gradientStops: this.getGradientStops(color),
            min: d.min,
            max: d.max
        };
    };
    CircleSeriesComponent.prototype.getTooltipText = function (_a) {
        var tooltipLabel = _a.tooltipLabel, value = _a.value, seriesName = _a.seriesName, min = _a.min, max = _a.max;
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(seriesName) + " \u2022 " + escapeLabel(tooltipLabel) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + this.getTooltipMinMaxText(min, max) + "</span>\n    ";
    };
    CircleSeriesComponent.prototype.getTooltipMinMaxText = function (min, max) {
        if (min !== undefined || max !== undefined) {
            var result = ' (';
            if (min !== undefined) {
                if (max === undefined) {
                    result += '≥';
                }
                result += min.toLocaleString();
                if (max !== undefined) {
                    result += ' - ';
                }
            }
            else if (max !== undefined) {
                result += '≤';
            }
            if (max !== undefined) {
                result += max.toLocaleString();
            }
            result += ')';
            return result;
        }
        else {
            return '';
        }
    };
    CircleSeriesComponent.prototype.getGradientStops = function (color) {
        return [
            {
                offset: 0,
                color: color,
                opacity: 0.2
            },
            {
                offset: 100,
                color: color,
                opacity: 1
            }
        ];
    };
    CircleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    CircleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    CircleSeriesComponent.prototype.activateCircle = function () {
        this.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    CircleSeriesComponent.prototype.deactivateCircle = function () {
        this.barVisible = false;
        this.circle.opacity = 0;
        this.deactivate.emit({ name: this.data.name });
    };
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "type", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input()
    ], CircleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output()
    ], CircleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output()
    ], CircleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output()
    ], CircleSeriesComponent.prototype, "deactivate", void 0);
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SvgLinearGradientComponent, ɵngcc3.CircleComponent, ɵngcc4.TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: "\n    <svg:g *ngIf=\"circle\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"circle.gradientStops\"\n        />\n      </defs>\n      <svg:rect\n        *ngIf=\"barVisible && type === 'standard'\"\n        [@animationState]=\"'active'\"\n        [attr.x]=\"circle.cx - circle.radius\"\n        [attr.y]=\"circle.cy\"\n        [attr.width]=\"circle.radius * 2\"\n        [attr.height]=\"circle.height\"\n        [attr.fill]=\"gradientFill\"\n        class=\"tooltip-bar\"\n      />\n      <svg:g\n        ngx-charts-circle\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circle.radius\"\n        [fill]=\"circle.color\"\n        [class.active]=\"isActive({ name: circle.seriesName })\"\n        [pointerEvents]=\"circle.value === 0 ? 'none' : 'all'\"\n        [data]=\"circle.value\"\n        [classNames]=\"circle.classNames\"\n        (select)=\"onClick(circle.data)\"\n        (activate)=\"activateCircle()\"\n        (deactivate)=\"deactivateCircle()\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return CircleSeriesComponent;
}());
export { CircleSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNwcm8va3JpdHNhZGVlL1NWTi9DeWJlcnNvZnQvYXBleC9ub2RlX21vZHVsZXMvQHN3aW1sYW5lL25neC1jaGFydHMvZXNtNS9saWIvY29tbW9uL2NpcmNsZS1zZXJpZXMuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4REEwTDhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFpQmhDIiwiZmlsZSI6ImNpcmNsZS1zZXJpZXMuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgZm9ybWF0TGFiZWwsIGVzY2FwZUxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsLmhlbHBlcic7XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4uL3V0aWxzL2lkJztcbnZhciBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2lyY2xlU2VyaWVzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhbmRhcmQnO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJhclZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmdyYWRpZW50RmlsbCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaXJjbGUgPSB0aGlzLmdldEFjdGl2ZUNpcmNsZSgpO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBY3RpdmVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbmRleEFjdGl2ZURhdGFQb2ludCA9IHRoaXMuZGF0YS5zZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgJiYgX3RoaXMudmlzaWJsZVZhbHVlICYmIGxhYmVsLnRvU3RyaW5nKCkgPT09IF90aGlzLnZpc2libGVWYWx1ZS50b1N0cmluZygpICYmIGQudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleEFjdGl2ZURhdGFQb2ludCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIHBvaW50IGlzICdhY3RpdmUvaG92ZXJlZCBvdmVyJyBhdCB0aGlzIG1vbWVudC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVBvaW50VG9DaXJjbGUodGhpcy5kYXRhLnNlcmllc1tpbmRleEFjdGl2ZURhdGFQb2ludF0sIGluZGV4QWN0aXZlRGF0YVBvaW50KTtcbiAgICB9O1xuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubWFwRGF0YVBvaW50VG9DaXJjbGUgPSBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xuICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICAgIHZhciBjeDtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgY3ggPSB0aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjeSA9IHRoaXMueVNjYWxlKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJyA/IHZhbHVlIDogZC5kMSk7XG4gICAgICAgIHZhciByYWRpdXMgPSA1O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy55U2NhbGUucmFuZ2UoKVswXSAtIGN5O1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDE7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IoZC5kMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHNlcmllc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZCwge1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbmFtZTogbGFiZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbXCJjaXJjbGUtZGF0YS1cIiArIGldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB0b29sdGlwTGFiZWw6IHRvb2x0aXBMYWJlbCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5nZXRHcmFkaWVudFN0b3BzKGNvbG9yKSxcbiAgICAgICAgICAgIG1pbjogZC5taW4sXG4gICAgICAgICAgICBtYXg6IGQubWF4XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBfYS50b29sdGlwTGFiZWwsIHZhbHVlID0gX2EudmFsdWUsIHNlcmllc05hbWUgPSBfYS5zZXJpZXNOYW1lLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heDtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgZXNjYXBlTGFiZWwoc2VyaWVzTmFtZSkgKyBcIiBcXHUyMDIyIFwiICsgZXNjYXBlTGFiZWwodG9vbHRpcExhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgdGhpcy5nZXRUb29sdGlwTWluTWF4VGV4dChtaW4sIG1heCkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBNaW5NYXhUZXh0ID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCB8fCBtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcgKCc7XG4gICAgICAgICAgICBpZiAobWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbWluLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIC0gJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAn4omkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtYXgudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50U3RvcHMgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5kYXRhLm5hbWUgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmFyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpcmNsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKVxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKVxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgKm5nSWY9XFxcImNpcmNsZVxcXCI+XFxuICAgICAgPGRlZnM+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zdmctbGluZWFyLWdyYWRpZW50XFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJjaXJjbGUuZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgKm5nSWY9XFxcImJhclZpc2libGUgJiYgdHlwZSA9PT0gJ3N0YW5kYXJkJ1xcXCJcXG4gICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJjaXJjbGUuY3ggLSBjaXJjbGUucmFkaXVzXFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcImNpcmNsZS5jeVxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwiY2lyY2xlLnJhZGl1cyAqIDJcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJjaXJjbGUuaGVpZ2h0XFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50RmlsbFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJ0b29sdGlwLWJhclxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGVcXG4gICAgICAgIGNsYXNzPVxcXCJjaXJjbGVcXFwiXFxuICAgICAgICBbY3hdPVxcXCJjaXJjbGUuY3hcXFwiXFxuICAgICAgICBbY3ldPVxcXCJjaXJjbGUuY3lcXFwiXFxuICAgICAgICBbcl09XFxcImNpcmNsZS5yYWRpdXNcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImNpcmNsZS5jb2xvclxcXCJcXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZSh7IG5hbWU6IGNpcmNsZS5zZXJpZXNOYW1lIH0pXFxcIlxcbiAgICAgICAgW3BvaW50ZXJFdmVudHNdPVxcXCJjaXJjbGUudmFsdWUgPT09IDAgPyAnbm9uZScgOiAnYWxsJ1xcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiY2lyY2xlLnZhbHVlXFxcIlxcbiAgICAgICAgW2NsYXNzTmFtZXNdPVxcXCJjaXJjbGUuY2xhc3NOYW1lc1xcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKGNpcmNsZS5kYXRhKVxcXCJcXG4gICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlQ2lyY2xlKClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGVDaXJjbGUoKVxcXCJcXG4gICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImNpcmNsZS5kYXRhXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQ2lyY2xlU2VyaWVzQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IENpcmNsZVNlcmllc0NvbXBvbmVudCB9O1xuIl19